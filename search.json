[{"title":"LeetCode腾讯精选练习50题-292.Nim游戏","url":"/archives/5b7d327e.html","content":"题目描述\n两个人一起玩 Nim 游戏：\n桌子上有一堆石头。你们轮流进行自己的回合， 你作为先手。\n每一回合，轮到的人拿掉 1 - 3 块石头。拿掉最后一块石头的人就是获胜者。\n假设你们每一步都是最优解。请编写一个函数，来判断你是否可以在给定石头数量为 n 的情况下赢得游戏。\n如果可以赢，返回 true；否则，返回 false。\n\nexample\ninput  : n = 4\noutput : false\nnote   : 1. 你移除1颗石头；你的朋友移走了3块石头，包括最后一块。你的朋友赢了。\n         2. 你移除2颗石头；你的朋友移走2块石头，包括最后一块。你的朋友赢了。\n         3. 你移走3颗石头；你的朋友移走了最后一块石头。你的朋友赢了。\n         => 在所有结果中，你的朋友是赢家。\ninput  : n = 1\noutput : true\nnote   : 你移除1颗石头。你赢了。\ninput  : n = 2\noutput : true\nnote   : 你移除2个石头。你赢了。\n\n\n\n解题思路\n逐步增加石头数量来做分析\n明确条件：你作为先手，你们每一步都是最优解（对于自己来说是最优解，目的是让对方输掉游戏）\n1、石头数量在[1,3]之间，你可以直接取走所有的石头，你胜定。\n2、石头数量恰好为 4 颗，参考 example 中的第一个例子，不论你取走几颗（1~3颗），按对自身最优解的原则，对手肯定会取走剩下的所有石头，对手胜定；\n同理，反过来思考，如果轮到对手时，只剩4颗石头，那不论对手取走几颗，按对自身最优解的原则，你肯定会取走剩下所有的石头，你胜定。\n\n\n3、石头数量在[5,7]之间，你如果想取胜，参考上一条的思路，就要保证让对手面临4颗石头（如，5颗的时候你取走1颗，7颗的时候你取走3颗）你胜定\n4、石头数量恰好为 8 颗，参考上述分析1和分析2，不论你取走几颗（1~3颗），剩下的石头数量必然大于4，按对自身最优解的原则，对手只需要且肯定会让你下一次取的时候面对4颗石头，对手胜定。\n5、拓展到[9,+∞)范围中，参考上述分析 1 — 4\n只要轮到你取的时候，面临的是 4的倍数 颗石头，不论你取几颗，按对自身最优解的原则，对手只需要让你接下来每一次都继续面临 4 或 4的倍数颗石头，对手胜定。\n反之，只要你能让对方先面临 4的倍数 颗石头，你胜定。\n\n\n总结：在你先手的情况下，\n如果游戏开始的时候是 4 或 4的倍数 颗石头，不论你怎么取，输定。\n如果游戏开始的时候不是 4 或 4的倍数 颗石头，一定可以做到在你取了之后，马上让对手面对 4 或 4 的倍数颗石头，胜定。\n\n\n\n代码（Java）public class Solution &#123;\n    public boolean canWinNim(int n) &#123;\n        // 代码只需要判断先手面对的石头数，是不是4的倍数就好了。\n        // 不是则返回 true，是则返回 false。\n        return (n % 4) != 0;\n    &#125;\n&#125;","categories":["LeetCode"],"tags":["Java","LeetCode","数学","博弈"]},{"title":"LeetCode腾讯精选练习50题-009.回文数","url":"/archives/688ebbf7.html","content":"题目描述\n给定一个整数 x ，如果 x 是一个回文整数，返回 true ；否则，返回 false 。\n回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。\n进阶：不将整数转为字符串来解决这个问题\n\nexample\ninput  : 121\noutput : true\ninput  : -121\noutput : false\n\n\n\n解题思路\n先把一些很明确的情况排除掉\n负数直接返回false即可，肯定不是回文数\n[1, 10]内的数和10的倍数都肯定不是回文数\n\n思路1 借助字符串\n\n转成字符串后取其反转，再使用equals()函数做对比\n时间复杂度：O(n)\n空间复杂度：O(1)\n\n思路2 同时取前后对比\n\n先计算出x的长度len\n借助循环，每一步都取出当前x的首位和末尾做对比\n只要有一组不想等则直接返回false\n每一步中若相等则将x先去掉首位再除以10获取新的x，并将len除以100，对应于新的x长度\n\n\n时间复杂度：O(log(n))\n空间复杂度：O(1)\n\n思路3 反转一半后对比\n\n将x的后半部分逐步取下，并通过数学运算不断拼接成新的整数 half\n当x不再大于后半部分（x的长度比half短，或者长度相等但是x&lt;=half）时结束拼接\n判断以下两种情况是否成立，有一个成立则证明是回文数，可以返回true；两组都不成立则不是回文数\n当前x 和 half 相等 （原 x 长度为偶数）\n当前x 和 half / 10 相等 （原 x 长度为奇数；中间的数值x不论是几，x都是回文数）\n\n\n时间复杂度：O(log(n))\n空间复杂度：O(1)\n\n代码（Java）思路1代码\npublic class Solution1 &#123;\n    public boolean isPalindrome(int x) &#123;\n        if (x &lt; 0 || (x % 10 == 0) &amp;&amp; x != 0) &#123;\n            return false;\n        &#125;\n        String sb = new StringBuffer(String.valueOf(x)).reverse().toString();\n\n        return sb.equals(x + \"\");\n    &#125;\n&#125;\n思路2代码\npublic class Solution2 &#123;\n    public boolean isPalindrome(int x) &#123;\n        if (x &lt; 0 || (x % 10 == 0) &amp;&amp; x != 0) &#123;\n            return false;\n        &#125;\n        int len = 1;\n        int y = x;\n        while (y >= 10) &#123;\n            len *= 10;\n            y /= 10;\n        &#125;\n        y = x;\n        while (y != 0) &#123;\n            if (y / len != y % 10) &#123;\n                return false;\n            &#125;\n            y = (y % len) / 10;\n            len /= 100;\n        &#125;\n        return true;\n    &#125;\n&#125;\n思路3代码\npublic class Solution3 &#123;\n    public boolean isPalindrome(int x) &#123;\n        if (x &lt; 0 || (x % 10 == 0) &amp;&amp; x != 0) &#123;\n            return false;\n        &#125;\n        int rightHalf = 0;\n        int y = x;\n        while (y > rightHalf) &#123;\n            rightHalf = rightHalf * 10 + y % 10;\n            y /= 10;\n        &#125;\n        // 前者是偶数位数，后者是奇数位数\n        return y == rightHalf || y == rightHalf / 10;\n    &#125;\n&#125;","categories":["LeetCode"],"tags":["Java","LeetCode","字符串","数学","回文"]},{"title":"Python使用Pandas计算相关系数","url":"/archives/4e858b60.html","content":"问题：\n给定成分数据，使用Pandas计算各成分之间的相关系数\n\n代码\n调用函数：pandas.corr()\n\n\n\n1、单个文件的情况import pandas as pd\n\n# 指定文件名称，这里假设数据文件data.csv与此文件位于相同的目录\nfile_name = './data.csv'\n\n# 读取数据文件\ndata = pd.read_csv(file_name)\n\n# 可以通过打印数据表的行、列信息以级前几行来简单的了解数据\n# print(data.shape)\n# print(data.head())\n\n# 调用corr()函数计算数据列之间的相关系数\ncorr = data.corr();\n\n# 把相关系数结果存储到新的文件中，路径默认为当前文件夹 \ncorr.to_csv('correlation.csv')\n\n2、多个文件的情况import pandas as pd\n\n# 指定数据文件的路径 \nfile_name_1 = '../dic1/dic2/name1.csv'\nfile_name_2 = '../dic1/dic2/name2.csv'\nfile_name_3 = '../dic1/dic2/name3.csv'\nfile_name_4 = '../dic1/dic2/name4.csv'\n\n# 将数据文件的路径统一到列表中\nlists = &#123;file_name_1, file_name_2, file_name_3, file_name_4&#125;\n\n# 使用循环来对数据文件逐个操作\nfor file_name in lists:\n    # 读取数据文件\n    data = pd.read_csv(file_name)\n    \n    # 计算数据列之间的相关系数\n    corr = data.corr();\n    \n    # 为了区分不同的文件计算得到的相关系数，此处通过数据文件名做区分，用split()函数截取原始的数据文件名\n    out_name = file_name.split('/')[3]\n    \n    # 将每个数据文件的相关系数计算结果存储到当前路径下，文件名以“correlation与文件名”做拼接\n    corr.to_csv('./correlation_' + out_name)\n\n","categories":["其他"],"tags":["Python","其他"]},{"title":"LeetCode精选TOP面试题50.Pow(x, n)","url":"/archives/42e9890.html","content":"题目描述\n实现 pow(x, n) ，即计算 x 的 n 次幂函数（即，xn ）。\n\nexample\ninput  : x = 2.00000, n = 10\noutput : 1024.00000\ninput  : x = 2.10000, n = 3\noutput : 9.26100\ninput  : x = 2.00000, n = -2\noutput : 0.25000\nnote   : 2^-2 = 1/2^2 = 1/4 = 0.25\n\n\n\n解题思路\n公式：\n\n思路1 递归\n\n参数：初始值 x，指数 m\n退出边界：m = 0，返回1，任何数的0次幂都是1\n递归主体：y = loop(x, m / 2)，此处y等价于公式中的 x^⌊n/2⌋次幂，⌊n/2⌋代表下取整，如⌊7/2⌋ = 3\n返回值：当 m 是奇数，返回 y * y * x；当 m 是偶数，返回 y * y\n时间复杂度：O(log n)\n空间复杂度：O(log n)\n\n思路2 迭代\n\n当 n 为奇数时，二分后会多出一项 x （当前的x值，不是初始的x值） 。\n可通过循环 x = x^2 操作，每次把幂从 n 降至 ⌊n/2⌋ ，直至将幂降为 0；\n设 res = 1，则初始状态 x^n = x^n · res ；\n在循环二分时，每当 n 为奇数时，将多出的一项 x 乘入 res ，则最终可化至 xn = x0 · res = res；\n最后返回 res 即可。\n算法主要流程：\n当n &lt; 0时，把问题转化到 |n| &gt;= 0 的范围内，即执行 n = -n，x = 1 / x操作 \n初始化res = 1\n循环，当n = 0时结束：\n当 n % 2 = 1时，将 当前的x 乘入 res\n执行 x = x^2，令当前 x 扩大至其平方值\n执行 ⌊n/2⌋，降幂（降至n = 0时循环结束）\n\n\n\n\n时间复杂度：O(log n)\n空间复杂度：O(1)\n参考自题解\n\n思路3 暴力\n\nfor循环逐个乘\n无法通过测试，超出时间限制\n时间复杂度：O(n)\n空间复杂度：O(1)\n\n代码（Java）思路1代码\npublic class Solution1 &#123;\n    public double myPow(double x, int n) &#123;\n        // 为了防止n由负数转为正数时的溢出，先用long接收n\n        long m = n;\n        return m > 0 ? loop(x, m) : 1.0 / loop(x, -m);\n    &#125;\n\n    private double loop(double x, long m)&#123;\n        if (m == 0) &#123;\n            return 1.0;\n        &#125;\n        double y = loop(x, m /2);\n        return m % 2 == 0 ? y * y : y * y * x;\n    &#125;\n&#125;\n思路2代码\npublic class Solution2 &#123;\n    public double myPow(double x, int n) &#123;\n        if (x == 1) &#123;\n            return 1;\n        &#125;\n        long m = n;\n        if (m &lt; 0) &#123;\n            x = 1.0 / x;\n            m = -m;\n        &#125;\n        double result = 1.0;\n        while (m > 0) &#123;\n            if (m % 2 == 1) &#123;\n                result = result * x;\n            &#125;\n            x = x * x;\n            m /= 2;\n        &#125;\n        return result;\n    &#125;\n&#125;\n\n思路3代码\npublic class Solution3 &#123;\n    public double myPow(double x, int n) &#123;\n        if (x == 1) &#123;\n            return 1;\n        &#125;\n        long m = n;\n        if (m &lt; 0) &#123;\n            x = 1.0 / x;\n            m = -m;\n        &#125;\n        double result = 1.0;\n        for(long i = 0; i &lt; m; i ++)&#123;\n            result = result * x;\n        &#125;\n        return result;\n    &#125;\n&#125;","categories":["LeetCode"],"tags":["Java","LeetCode","分治","数学","递归"]},{"title":"webstorm取消vue标签的高亮状态","url":"/archives/774c957b.html","content":"WebStorm中vue标签高亮，影响编程体验\n\n\n原因：WebStorm对未知html标签会使用高亮来提示\n关闭方法，找到File -&gt; Settings -&gt; Editor -&gt; Inspections -&gt; HTML\n取消勾选 Unknow HTML tags，点击ok即可取消vue标签的高亮显示状态\n\n\n","categories":["SpringBoot+Vue"],"tags":["其他","Vue","WebStorm"]},{"title":"LeetCode精选TOP面试题138. 复制带随机指针的链表","url":"/archives/952dea56.html","content":"题目描述\n给定一个长度为 n 的链表，每个节点包含一个额外增加的随机指针 random ，该指针可以指向链表中的任何节点或空节点。\n构造这个链表的 深拷贝。 深拷贝应该正好由 n 个 全新 节点组成，其中每个新节点的值都设为其对应的原节点的值。新节点的 next 指针和 random 指针也都应指向复制链表中的新节点，并使原链表和复制链表中的这些指针能够表示相同的链表状态。复制链表中的指针都不应指向原链表中的节点 。\n\nexample\ninput  : head = [[7,null],[13,0],[11,4],[10,2],[1,0]]\noutput : [[7,null],[13,0],[11,4],[10,2],[1,0]]  \ninput  : head = [[3,null],[3,0],[3,null]]\noutput : [[3,null],[3,0],[3,null]]\n\n\n\n\n例如，如果原链表中有 X 和 Y 两个节点，其中 X.random –&gt; Y 。那么在复制链表中对应的两个节点 x 和 y ，同样有 x.random –&gt; y 。\n返回复制链表的头节点。\n\n用一个由 n 个节点组成的链表来表示输入/输出中的链表。每个节点用一个 [val, random_index] 表示：\nval：一个表示 Node.val 的整数。\nrandom_index：随机指针指向的节点索引（范围从 0 到 n-1）；如果不指向任何节点，则为  null 。\n代码 只 接受原链表的头节点 head 作为传入参数。\n\n解题思路思路1 哈希表\n\n遍历原链表，暂不考虑 random 指针，逐个深拷贝原节点并形成新链表，在此过程中用 哈希表map 记录每一对&lt;老节点，新节点&gt;。\n遍历原链表和新链表，判断当前原节点 oldNode 的 random 指针是否为空，若不为空，则可让 newNode.random 指向 map 中以 oldNode.random 作为键的值，即 newNode.random = map.get(oldNode.random)\n\n\n时间复杂度：O(n)\n空间复杂度：O(n)\n\n思路2 原地算法\n\n暂不考虑 random 指针，先在原链表的每个节点后 深拷贝并插入 一个与其值相同的节点\n\n即，假设原链表为 1 -&gt; 2 -&gt; 3，遍历并插入后，列表更新为 1 -&gt; 1 -&gt; 2 -&gt; 2 -&gt; 3 -&gt; 3\n\n再次遍历该链表，根据当前链表中的前后关系，把 原列表节点的 random 指针关系复制给间隔的新链表\n\n即假设当前节点为 node，则当 node.random 不为空时，node.next.random = node.random.next\n\n然后node前进两个位置，绕过新复制出来的链表节点\n\n最后把新老链表拆分开并返回新链表即可\n\n时间复杂度：O(n)\n\n空间复杂度：O(1)\n\n\n思路3 回溯 + 哈希表\n\n利用 回溯 的方式，让每个节点的拷贝操作相互独立。\n\n对于当前节点 node ，首先要进行拷贝，用 哈希表 记录每一对&lt;老节点，新节点&gt;。\n\n递归创建 当前节点的后继节点 node.next 和 当前节点的随机指针指向的节点 node.random。\n\n由于一个节点可能被多个其他节点指向，因此可能会在递归过程中多次尝试拷贝某个节点。\n\n为防止重复拷贝，需要首先检查当前节点是否被拷贝过，即是否已经作为值存在于哈希表中，如果已经拷贝过，可以直接从哈希表中将其取出并返回。\n\n时间复杂度：O(n)\n\n空间复杂度：O(n)\n\n\n代码（Java）思路1代码\npublic class Solution1 &#123;\n    public Node copyRandomList(Node head) &#123;\n        if (head == null) &#123;\n            return null;\n        &#125;\n        Map&lt;Node, Node> map = new HashMap&lt;>();\n\n        Node newHead = new Node(-1);\n        Node scan = head;\n        Node append = newHead;\n        while (scan != null) &#123;\n            Node newNode = new Node(scan.val);\n            map.put(scan, newNode);\n            append.next = newNode;\n            scan = scan.next;\n            append = append.next;\n        &#125;\n        scan = head;\n        append = newHead.next;\n        while (scan != null) &#123;\n            if (scan.random != null) &#123;\n                append.random = map.get(scan.random);\n            &#125;\n            scan = scan.next;\n            append = append.next;\n        &#125;\n        return newHead.next;\n    &#125;\n&#125;\n思路2代码\npublic class Solution2 &#123;\n    public Node copyRandomList(Node head) &#123;\n        if (head == null) &#123;\n            return null;\n        &#125;\n        Node scan = head;\n        while (scan != null) &#123;\n            Node newNode = new Node(scan.val);\n            newNode.next = scan.next;\n            scan.next = newNode;\n            scan = newNode.next;\n        &#125;\n        scan = head;\n        while (scan != null) &#123;\n            if (scan.random != null) &#123;\n                scan.next.random = scan.random.next;\n            &#125;\n            scan = scan.next.next;\n        &#125;\n\n        Node newList = head.next;\n        Node oldList = head;\n        Node res = head.next;\n        while (newList != null &amp;&amp; oldList != null) &#123;\n            oldList.next = newList.next;\n            oldList = oldList.next;\n            if (oldList != null) &#123;\n                newList.next = oldList.next;\n                newList = newList.next;\n            &#125;\n        &#125;\n        return res;\n    &#125;\n&#125;\npublic class Solution3 &#123;\n    private Map&lt;Node, Node> map = new HashMap&lt;>();\n    public Node copyRandomList(Node head) &#123;\n        if (head == null) &#123;\n            return null;\n        &#125;\n        if (!map.containsKey(head)) &#123;\n            Node headNew = new Node(head.val);\n            map.put(head, headNew);\n            headNew.next = copyRandomList(head.next);\n            headNew.random = copyRandomList(head.random);\n        &#125;\n        return map.get(head);\n\n    &#125;\n&#125;","categories":["LeetCode"],"tags":["Java","LeetCode","哈希表","链表","模拟","回溯"]},{"title":"LeetCode精选TOP面试题341.扁平化嵌套列表迭代器","url":"/archives/6ffca0a6.html","content":"题目描述\n给定一个嵌套的整数列表 nestedList 。\n每个元素要么是一个整数，要么是一个列表；该列表的元素也可能是整数或者是其他列表。\n实现一个迭代器将其扁平化，使之能够遍历这个列表中的所有整数。\n实现扁平迭代器类 NestedIterator ：\nNestedIterator(List nestedList) 用嵌套列表 nestedList 初始化迭代器。\nint next() 返回嵌套列表的下一个整数。\nboolean hasNext() 如果仍然存在待迭代的整数，返回 true ；否则，返回 false 。\n\nexample\ninput  : nestedList = [[1,1],2,[1,1]]\noutput : [1,1,2,1,1]\ninput  : nestedList = [1,[4,[6]]]\noutput : [1,4,6]\n\n\n\n\n代码将会用下述伪代码检测：initialize iterator with nestedList\nres = []\nwhile iterator.hasNext()\n    append iterator.next() to the end of res\nreturn res\n如果 res 与预期的扁平化列表匹配，那么代码将会被判为正确。\n\n解题思路\n本质上与树的遍历相同，嵌套列表可看作一棵树，其中数值元素就是叶子节点，列表元素就是非叶子节点\nnestedList = [[1,1],2,[1,1]] 可画图为    nestedList\n   /   |   \\\nlist1  2   list2\n / \\        / \\\n1   1      1   1\nnestedList = [1,[4,[6]]] 可画图为  nestedList\n  /   \\\n 1   list2\n      / \\\n     4  list3\n        /\n       6\n\n\n\n思路1 队列+DFS+递归\n\nNestedIterator(List nestedList)：\n\n调用自定义的 深度优先搜索函数 dfs()，把输入的 nestedList 遍历一遍，并把所有数值元素逐个添加到队列 queue 中\n\n\nhasNext()：\n\n调用isEmpty()方法判断队列 queue 是否为空，\n若不为空则仍然存在待迭代的整数，返回 true ；否则，返回 false \n\n\nnext()： \n\n调用hashNext()判断是否存在下一个 整数，\n若存在，队列的队首元素并返回，若不存在则返回 -1。\n\n\ndfs(List nestedList):  遍历 nestedList，如果是整数，则把该整数添加到队列末尾，如果是列表 list，则递归调用dfs，传入参数为当前列表 list\n\n\n思路2 栈+递归\n\nNestedIterator(List nestedList)：\n\n调用自定义的 pushStack() 方法，倒序遍历列表 nestedList，实现列表元素入栈\n\n\nhasNext()：\n\n若当前栈空，则返回false\n否则判断栈顶元素是否为整数\n若是整数则返回true\n若是列表则将栈顶列表 item 弹出栈，后续操作同 NestedIterator，然后递归调用 hasNext() 本身\n\n\n\n\nnext()： \n\n调用hashNext()判断是否存在下一个 整数，\n若存在，弹出栈顶元素并返回，若不存在则返回 -1。\n\n\npushStack(List nestedList):\n\n倒序遍历列表 nestedList，把当前列表元素（不考虑其类型为Integer还是List）依次到栈顶\n\n\n\n代码（Java）思路1代码\npublic class NestedIterator1 implements Iterator&lt;Integer> &#123;\n    private Deque&lt;Integer> queue = new ArrayDeque&lt;>();\n\n    private void dfs(List&lt;NestedInteger> nestedList) &#123;\n        for (NestedInteger nest : nestedList) &#123;\n            if (nest.isInteger()) &#123;\n                queue.addLast(nest.getInteger());\n            &#125; else &#123;\n                dfs(nest.getList());\n            &#125;\n        &#125;\n    &#125;\n\n    public NestedIterator1(List&lt;NestedInteger> nestedList) &#123;\n        dfs(nestedList);\n    &#125;\n\n    @Override\n    public Integer next() &#123;\n        return hasNext() ? queue.pollFirst() : -1;\n    &#125;\n\n    @Override\n    public boolean hasNext() &#123;\n        return !queue.isEmpty();\n    &#125;\n&#125;\n思路2代码\npublic class NestedIterator2 implements Iterator&lt;Integer> &#123;\n    private Stack&lt;NestedInteger> stack = new Stack&lt;>();\n\n    private void pushStack(List&lt;NestedInteger> list) &#123;\n        for (int index = list.size() - 1; index >= 0; index--) &#123;\n            stack.add(list.get(index));\n        &#125;\n    &#125;\n\n    public NestedIterator2(List&lt;NestedInteger> nestedList) &#123;\n        pushStack(nestedList);\n    &#125;\n\n    @Override\n    public Integer next() &#123;\n        return hasNext() ? stack.pop().getInteger() : -1;\n    &#125;\n\n    @Override\n    public boolean hasNext() &#123;\n        if (stack.isEmpty()) &#123;\n            return false;\n        &#125; else &#123;\n            NestedInteger item = stack.peek();\n            if (item.isInteger()) &#123;\n                return true;\n            &#125; else &#123;\n                item = stack.pop();\n                List&lt;NestedInteger> list = item.getList();\n                pushStack(list);\n                return hasNext();\n            &#125;\n        &#125;\n    &#125;\n&#125;","categories":["LeetCode"],"tags":["Java","LeetCode","DFS","队列","栈"]},{"title":"LeetCode精选TOP面试题236.二叉树的最近公共祖先","url":"/archives/92af397c.html","content":"题目描述\n给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。\n最近公共祖先的定义为：\n对于有根树 T 的两个节点 p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。\n\nexample\ninput  : root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1\noutput : 3\ninput  : root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4\noutput : 5\ninput  : root = [1,2], p = 1, q = 2\noutput : 1\n\n\n\n解题思路\n深度优先搜索\n\n思路1\n\n递归，dfs\n若当前被递归的节点 i 是 p 或者 q，则直接返回\n递归 i 的左子树\n递归 i 的右子树\n若左子树递归结果为空，说明 p 和 q 都在 i 的右子树里，返回右子树的递归结果\n若右子树递归结果为空，说明 p 和 q 都在 i 的左子树里，返回左子树的递归结果\n若左右子树的递归结果都不为空，说明 p 和 q 分别位于 i 的两侧，直接返回 i 即可。\n\n思路2 存储父节点\n\n借助map和set\n先对二叉树进行一次dfs，借助map存储每个节点的父节点，键值对设置为&lt;当前节点，当前节点的父节点&gt;\n对 p 节点进行祖先节点（从 root 到 p 的最短路径中，除了 p 以外的节点，都是 p 的祖先节点）的追溯，在set中记录已经被访问过的节点（从 p 一直到根节点 root ）\n对 p 节点进行祖先节点（从 root 到 q 的最短路径中，除了 q 以外的节点，都是 q 的祖先节点）的追溯，如果set中已经包含了 q 或 q 的某个祖先节点 i （i可以为q），说明节点 i 是 p 和 q 的最近公共祖先 LCA\n\n代码（Java）思路1代码\npublic class Solution &#123;\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) &#123;\n        if (root == null) &#123;\n            return null;\n        &#125;\n        if (root == p || root == q) &#123;\n            return root;\n        &#125;\n        TreeNode left = lowestCommonAncestor(root.left, p, q);\n        TreeNode right = lowestCommonAncestor(root.right, p, q);\n        if (left == null) &#123;\n            return right;\n        &#125;\n        if (right == null) &#123;\n            return left;\n        &#125;\n        return root;\n    &#125;\n&#125;\n思路2代码\npublic class Solution2 &#123;\n    Map&lt;Integer, TreeNode> map = new HashMap&lt;Integer, TreeNode>();\n    Set&lt;Integer> visited = new HashSet&lt;Integer>();\n\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) &#123;\n        dfs(root);\n\n        while (p != null)&#123;\n            visited.add(p.val);\n            p = map.get(p.val);\n        &#125;\n        while (q != null)&#123;\n            if ( visited.contains(q.val)) &#123;\n               return q;\n            &#125;\n            q = map.get(q.val);\n        &#125;\n        return null;\n    &#125;\n\n    private void dfs(TreeNode root) &#123;\n        if (root.left != null) &#123;\n            map.put(root.left.val, root);\n            dfs(root.left);\n        &#125;\n        if (root.right != null) &#123;\n            map.put(root.right.val, root);\n            dfs(root.right);\n        &#125;\n    &#125;\n&#125;","categories":["LeetCode"],"tags":["Java","LeetCode","递归","二叉树","DFS","树"]},{"title":"LeetCode精选TOP面试题103.二叉树的锯齿形层序遍历","url":"/archives/909ffbac.html","content":"题目描述\n给定二叉树的根节点 root ，返回其节点值的 锯齿形层序遍历 。\n即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行。\n\nexample\ninput  : root = [3,9,20,null,null,15,7]\noutput : [[3],[20,9],[15,7]]\nnote   :     3\n            / \\\n           9  20\n             /  \\\n            15   7\ninput  : root = []\noutput : []\n\n\n\n解题思路\n原理仍然是二叉树的层次遍历，见题目 102.二叉树的层次遍历\n\n借助队列 queue 实现二叉树的层次遍历（广度优先搜索）\n\n根节点入队\n\n使用循环判断队列是否为空\n\n每次循环时，队列的长度 queue.size()，即为当前层的节点数量\n使用for循环，把队列中当前层的节点 treeNode 逐个移除队列并访问\n把每个 treeNode 的值逐个添加到每一层的列表中\n当前被访问的节点 treeNode 若有左子树（treeNode.left != null），则左子树入队\n当前被访问的节点 treeNode 若有右子树（treeNode.right != null），则右子树入队\n\n\n把每层的节点值列表，添加到结果列表 lists 中\n\n\n队列为空时，说明遍历结束\n\n然后遍历lists，将奇数下标的子列表中元素顺序反转，即可满足锯齿遍历的要求\n\n时间复杂度：O(n) \n\n空间复杂度：O(n)\n\n\n代码（Java）public class Solution &#123;\n    public List&lt;List&lt;Integer>> zigzagLevelOrder(TreeNode root) &#123;\n        // 空树直接返回空列表\n        List&lt;List&lt;Integer>> lists = new ArrayList&lt;>();\n        if (root == null) &#123;\n            return lists;\n        &#125;\n        Queue&lt;TreeNode> queue = new LinkedList&lt;>();\n        // 根节点先入队\n        queue.add(root);\n        while (!queue.isEmpty()) &#123;\n            int currentSize = queue.size();\n            List&lt;Integer> list = new ArrayList&lt;>();\n            for (int i = 0; i &lt; currentSize; i++) &#123;\n                TreeNode treeNode = queue.poll();\n                list.add(treeNode.val);\n                if (treeNode.left != null) &#123;\n                    queue.add(treeNode.left);\n                &#125;\n                if (treeNode.right != null) &#123;\n                    queue.add(treeNode.right);\n                &#125;\n            &#125;\n            lists.add(list);\n        &#125;\n        for (int i = 0; i &lt; lists.size(); i++) &#123;\n            if (i % 2 == 1) &#123;\n                Collections.reverse(lists.get(i));\n            &#125;\n            /* 输出检查\n            for (Integer item : lists.get(i)) &#123;\n                System.out.print(item + \" \");\n            &#125;\n            System.out.println();\n            */\n        &#125;\n        return lists;\n    &#125;\n&#125;","categories":["LeetCode"],"tags":["Java","LeetCode","二叉树","树","BFS","队列"]},{"title":"LeetCode精选TOP面试题098.验证二叉搜索树","url":"/archives/1f6759ea.html","content":"题目描述\n给定一个二叉树的根节点 root ，判断其是否是一个有效的二叉搜索树。\n有效 二叉搜索树 定义如下：\n节点的左子树只包含 小于 当前节点的数。\n节点的右子树只包含 大于 当前节点的数。\n所有左子树和右子树自身必须也是二叉搜索树。\n\nexample\ninput  : root = [2,1,3]\noutput : true\ninput  : root = [5,1,4,null,null,3,6]\noutput : false\n\n\n\n解题思路\n深度优先搜索\n中序遍历\n\n思路1 递归\n\n中序DFS，套模板，将树的各节点值存放到列表中\n遍历列表，如果出现后一个元素≤前一个元素的情况，则不是有效的二叉搜索树\n\n思路2 栈模拟\n\n用栈模拟中序DFS，套模板，将树的各节点值存放到列表中\n遍历列表，如果出现后一个元素≤前一个元素的情况，则不是有效的二叉搜索树\n\n代码（Java）思路1代码\npublic class Solution1 &#123;\n    public List&lt;Integer> tree = new ArrayList&lt;Integer>();\n\n    public boolean isValidBST(TreeNode root) &#123;\n        // 中序遍历，DFS\n        dfs(root);\n\n        for (int i = 0; i &lt; tree.size() - 1; i++) &#123;\n            if (tree.get(i) >= tree.get(i + 1)) &#123;\n                return false;\n            &#125;\n        &#125;\n        return true;\n    &#125;\n\n    private void dfs(TreeNode root) &#123;\n        if (root == null) &#123;\n            return;\n        &#125;\n        dfs(root.left);\n        tree.add(root.val);\n        dfs(root.right);\n    &#125;\n&#125;\n思路2代码\npublic class Solution2 &#123;\n    public boolean isValidBST(TreeNode root) &#123;\n        List&lt;Integer> tree = new ArrayList&lt;Integer>();\n        // 用栈模拟DFS中序遍历\n        Stack&lt;TreeNode> stack = new Stack&lt;>();\n        while (!stack.isEmpty() || root != null) &#123;\n            while (root != null) &#123;\n                stack.push(root);\n                root = root.left;\n            &#125;\n            TreeNode tmp = stack.pop();\n            if (!tree.isEmpty() &amp;&amp; (tmp.val &lt;= tree.get(tree.size() - 1))) &#123;\n                return false;\n            &#125;\n            tree.add(tmp.val);\n            root = tmp.right;\n        &#125;\n        return true;\n    &#125;\n&#125;","categories":["LeetCode"],"tags":["Java","LeetCode","中序遍历","二叉树","二叉搜索树","DFS"]},{"title":"LeetCode精选TOP面试题204.计数质数","url":"/archives/37e360ba.html","content":"题目描述\n给定整数 n ，返回 所有小于非负整数 n 的质数的数量 。\n\nexample\ninput  : n = 10\noutput : 4\ninput  : n = 499979\noutput : 41537\ninput  : n = 1\noutput : 0\n\n\n\n解题思路\n思路4在leetcode平台提交性能最好：\n66 / 66 个通过测试用例状态：通过执行用时: 40 ms内存消耗: 45.6 MB\n\n\n\n思路1 枚举\n\n遍历 [2, n) 的所有整数，逐个判断是否为质数，若是则计数结果累加1\n时间复杂度：O(n √n})\n空间复杂度：O(1)\n\n思路2 埃氏筛\n\n当前元素 x 如果是质数，则其倍数 2x, 3x, …… 一定是合数。\n每次遍历到一个质数，就可以筛掉众多是其倍数的合数。\n此方法存在的一个问题是重复筛选，如 15 是 3和5 的倍数，15会被筛两次，虽然不影响结果，但实际上只筛1次就足够了。\n时间复杂度：O(n log(log n))\n空间复杂度：O(n)\n\n思路3 线性筛\n\n让每个合数只被标记一次，相较于埃氏筛，多维护一个 primes 数组表示当前得到的质数集合。\n从小到大遍历，如果当前的数 x 是质数，就将其加入 primes 数组。\n详见官方题解给出的思路\n\n思路4 减法\n\n首先，除2以外的所有偶数都不是质数，因此在 [1, n] 范围内有最多 n / 2 个质数\n其次，筛选所有奇数，把所有是合数的奇数都从 n / 2 这个最大值中减去\n最后，剩下的差值就是 [1, n] 内所有的质数了\n时间复杂度：O(n)。\n空间复杂度：O(n)。\n\n代码（Java）思路1代码\npublic class Solution1 &#123;\n    public int countPrimes(int n) &#123;\n        int result = 0;\n        for (int i = 2; i &lt; n; i++) &#123;\n            if (judgePrime(i)) &#123;\n                result++;\n            &#125;\n        &#125;\n        return result;\n    &#125;\n\n    private boolean judgePrime(int number) &#123;\n        for (int j = 2; j * j &lt;= number; j++) &#123;\n            if (number % j == 0) &#123;\n                return false;\n            &#125;\n        &#125;\n        return true;\n    &#125;\n&#125;\n思路2代码\npublic class Solution2 &#123;\n    public int countPrimes(int n) &#123;\n        int[] isPrime = new int[n];\n        Arrays.fill(isPrime, 1);\n        int result = 0;\n        for (int i = 2; i &lt; n; i++) &#123;\n            if (isPrime[i] == 1) &#123;\n                result++;\n                if ((long) i * i &lt; n) &#123;\n                    for (int k = i; k * i &lt; n; k++) &#123;\n                        isPrime[k * i] = 0;\n                    &#125;\n                &#125;\n            &#125;\n        &#125;\n        return result;\n    &#125;\n&#125;\n思路3代码\npublic class Solution3 &#123;\n    public int countPrimes(int n) &#123;\n        List&lt;Integer> primes = new ArrayList&lt;Integer>();\n        int[] isPrime = new int[n];\n        Arrays.fill(isPrime, 1);\n        for (int i = 2; i &lt; n; i++) &#123;\n            if (isPrime[i] == 1) &#123;\n                primes.add(i);\n            &#125;\n            for (int k = 0; k &lt; primes.size() &amp;&amp; primes.get(k) * i &lt; n; k++) &#123;\n                isPrime[primes.get(k) * i] = 0;\n                if (i % primes.get(k) == 0) &#123;\n                    break;\n                &#125;\n            &#125;\n\n        &#125;\n        return primes.size();\n    &#125;\n&#125;\n思路4代码\npublic class Solution4 &#123;\n    public int countPrimes(int n) &#123;\n        if (n &lt;= 2) &#123;\n            return 0;\n        &#125;\n        // 除了2以外，所有偶数肯定不是质数，假设所有奇数全是质数，然后所有奇数中排除非质数，此过程即做减法\n        int count = n / 2;\n\n        boolean[] notPrime = new boolean[n];\n        // 因为是做减法，且循环内会有对倍数的遍历操作\n        // 所以外层循环只需要以 sqrt(n) 为边界\n        // 内层遍历会遍历到整个范围内的倍数并作减法\n        // 所有 √n 到 n 之间的奇数，若它是 2 到 √n 内某个质数的倍数，则 count 肯定减1\n        // 所有 √n 到 n 之间的奇数，若它不是 2 到 √n 内某个质数的倍数，则它肯定是\n        for (int i = 3; i * i &lt; n; i += 2) &#123;\n\n            if (notPrime[i]) &#123;\n                // 如果是合数，继续遍历\n                continue;\n            &#125;\n            // 此处遍历i的所有i倍及大于i倍的数，并全部标记为合数\n            // 因为i的2到i-1倍的倍数在此之前肯定被遍历从2到i-1时标记过了，不需要重复遍历\n            // 之所以每次循环加两倍的i，是因为所有的偶数倍数早已经在遍历之前就被默认减去了（n / 2），故不需要再对其做减法。 \n            // 举例，i = 5，则以下循环中只需遍历 5*5，7*5， 9*5， 因为 6*5，8*5肯定是偶数，在遍历之前就被默认减掉了。\n            for (int k = i * i; k &lt; n; k += 2 * i) &#123;\n                if (!notPrime[k]) &#123;\n                    // 把质数 i 的 大于等于i倍的倍数都标记为合数，且count对应减去这些倍数的个数\n                    notPrime[k] = true;\n                    count--;\n                &#125;\n            &#125;\n        &#125;\n        return count;\n    &#125;\n&#125;","categories":["LeetCode"],"tags":["Java","LeetCode","数组","数学"]},{"title":"LeetCode精选TOP面试题49.字母异位词分组","url":"/archives/c3a6759d.html","content":"题目描述\n给定一个字符串数组，将 字母异位词 组合在一起。可以按任意顺序返回结果列表。\n字母异位词 是由重新排列源单词的字母得到的一个新单词，所有源单词中的字母通常恰好只用一次。\n\nexample\ninput  : strs = [\"eat\", \"tea\", \"tan\", \"ate\", \"nat\", \"bat\"]\noutput : [[\"bat\"],[\"nat\",\"tan\"],[\"ate\",\"eat\",\"tea\"]]\ninput  : strs = [\"\"]\noutput : [[\"\"]]\n\n\n\n解题思路思路 排序 + 哈希表\n\n对所有字符串进行排序，可以获得有相同字母的字符串，然后把每个排序后字符串对应的原字符串归为一组即可。\n\n遍历字符串数组，用 for (String item : strings) 的方式遍历，可以不改变item本身\n\n使用字符数组 chs 获取 item ，然后对 chs 进行排序，再将排序后的 chs 放入到新的临时字符串 key 中\n\n判断 map 中是否已经存在了以key为键值的键值对\n\n若不存在则在 map 中新增以 key 为键值，以 空列表 为值的键值对\n\n\n为 map 中键值为 key 的键值对，进行 add 操作，将未被修改的 item 本身添加到键值对的值列表中\n\n遍历结束即可得到所有异位词分组\n\n\n代码（Java）public class Solution &#123;\n    public List&lt;List&lt;String>> groupAnagrams(String[] strs) &#123;\n        Map&lt;String, List> map = new HashMap&lt;String, List>();\n        for (String str : strs) &#123;\n            char[] chs = str.toCharArray();\n            Arrays.sort(chs);\n            String key = String.valueOf(chs);\n            if (!map.containsKey(key)) &#123;\n                map.put(key, new ArrayList());\n            &#125;\n            map.get(key).add(str);\n        &#125;\n        return new ArrayList(map.values());\n    &#125;\n&#125;","categories":["LeetCode"],"tags":["Java","LeetCode","字符串","排序","哈希表"]},{"title":"LeetCode精选TOP面试题238.除自身以外数组的乘积","url":"/archives/302f5648.html","content":"题目描述\n给定一个整数数组 nums，返回 数组 answer ，其中 answer[i] 等于 nums 中除 nums[i] 之外其余各元素的乘积 。\n\n题目数据 保证 数组 nums之中任意元素的全部前缀元素和后缀的乘积都在  32 位 整数范围内。\n\n不能使用除法，且在 O(n) 时间复杂度内完成此题。\n\n\nexample\ninput  : nums = [1,2,3,4]\noutput : [24,12,8,6]\ninput  : nums = [-1,1,0,-3,3]\noutput : [0,0,9,0,0]\n\n\n\n解题思路思路 左右遍历\n\n从左向右遍历一次，对每个位置的元素，记录其左侧所有元素的乘积\n再从右向左遍历一次，对每个位置的元素，在上一步乘积的基础上，累乘其右侧所有元素的乘积\n时间复杂度O(n)\n空间复杂度O(n)\n\n代码（Java）public class Solution &#123;\n    public int[] productExceptSelf(int[] nums) &#123;\n        int[] result = new int[nums.length];\n        int sum = 1;\n        result[0] = 1;\n        for (int i = 0; i &lt; nums.length - 1; i++) &#123;\n            sum *= nums[i];\n            result[i + 1] = sum;\n        &#125;\n\n        sum = 1;\n        for (int i = nums.length - 1; i > 0; i--) &#123;\n            sum *= nums[i];\n            result[i - 1] *= sum;\n        &#125;\n\n        return result;\n    &#125;\n&#125;","categories":["LeetCode"],"tags":["Java","LeetCode","数组","前缀和"]},{"title":"router-link跳转失败（Vue router命名路由）","url":"/archives/6cb8f3c5.html","content":"问题及解决办法\n在.vue文件中，使用router-link并指定命名路由时跳转失败\nrouter-link的:to后指定的命名路由参数name，需要和src/router/index.js文件中定义的路由的name和对应。例如想跳转到index.js文件中已定义好的命名路由A中，:to后的name就需要写成A。\n\n\n\n使用方式创建 Router 实例的时候，在 routes 配置中给某个路由设置名称。如在src/router/index.js文件中定义以下路由\nimport Vue from 'vue'\nimport VueRouter from 'vue-router'\nVue.use(VueRouter)\nconst routes = [\n    &#123;\n        path: '/blog/:blogId',\n        name: 'BlogDetail',\n        component: BlogDetail,\n    &#125;\n]\n\n在.vue文件中链接到命名路由时，可以给 router-link 的 to 属性传一个对象：\n&lt;router-link :to&#x3D;&quot;&#123; name: &#39;BlogDetail&#39;, params: &#123; blogId: 123 &#125;&#125;&quot;&gt;文章标题&lt;&#x2F;router-link&gt;\n\n与代码调用 router.push() 等价：\nrouter.push(&#123; name: 'BlogDetail', params: &#123; blogId: 123 &#125; &#125;)\n\n官方文档","categories":["SpringBoot+Vue"],"tags":["Vue","router-link"]},{"title":"LeetCode精选TOP面试题378.有序矩阵中第 K 小的元素","url":"/archives/6443ff3e.html","content":"题目描述\n给定一个 n x n 矩阵 matrix ，其中每行和每列元素均按升序排序，找到矩阵中第 k 小的元素。\n是 排序后 的第 k 小元素，而不是第 k 个 不同 的元素。\n\nexample\ninput  : matrix = [[1,5,9],[10,11,13],[12,13,15]], k = 8\noutput : 13\ninput  : matrix = [[-5]], k = 1\noutput : -5\n\n\n\n解题思路思路1 排序\n\n将二维数组转换为一维数组\n对一维数组进行排序\n第k小的元素即一维数组中第k个元素，下标为k-1\n\n思路2 二分查找\n\n因为二维数组在行和列方向上都是递增的，因此，第k小的元素的 左上方，都是小于或等于它的元素\n即，假设 target 是矩阵中第k小的元素，则矩阵中有 k 个元素是小于或等于target的，这些元素在矩阵中的位置，都处于target的左上方\n利用数组的行列递增性质，实现二分查找定位\n初始选中左上角元素和右下角元素作为区间两端，即left = matrix[0][0]，right = matrix[n - 1][n - 1]，则 mid = (left + right) / 2\n可知矩阵中其他元素x都满足：left &lt; x &lt; right\n⭐从左下角开始，统计矩阵中值小于或等于mid的元素个数 count ，此时的mid就可以看作target，当count = k时，说明有k个小于或等于mid的元素，此时的mid就是结果\n利用数组性质完成count的计数\n当前元素 matrix[i][j] &lt;= mid 时，count 累加 i - 1，因为该行上面的所有行，在这第j列的值都小于mid，然后令j右移，扩大搜索范围\n当前元素 matrix[i][j] &gt; mid 时，说明当前元素在mid的右下角矩阵中，令i上移，缩小所搜范围\n\n\n当 count &lt; k 时，说明有 不足k个 不大于mid的元素，即第k小的元素位于 mid 右下方的矩阵中，令left = mid + 1\n当 count &gt;= k 时，说明有 超过（或刚好）k个 不大于mid的元素，即第k小的元素位于 mid 左上方的矩阵中，令right = mid\n当 left = right 时，代表 mid 就是要找的第k小的元素target（同⭐）\n\n\n\n代码（Java）思路1代码\npublic class Solution1 &#123;\n    public int kthSmallest(int[][] matrix, int k) &#123;\n        int n = matrix.length;\n        int[] array = new int[n * n];\n        int t = 0;\n        for (int i = 0; i &lt; n; i++) &#123;\n            for (int j = 0; j &lt; n; j++) &#123;\n                array[t++] = matrix[i][j];\n            &#125;\n        &#125;\n        Arrays.sort(array);\n        return array[k - 1];\n    &#125;\n&#125;\n思路2代码\npublic class Solution2 &#123;\n    public int kthSmallest(int[][] matrix, int k) &#123;\n        int n = matrix.length;\n        int left = matrix[0][0];\n        int right = matrix[n - 1][n - 1];\n        while (left &lt; right) &#123;\n            int mid = left + ((right - left) >> 1);\n            int count = findSmaller(matrix, mid, n);\n            if (count &lt; k) &#123;\n                left = mid + 1;\n            &#125; else &#123;\n                right = mid;\n            &#125;\n        &#125;\n        return right;\n    &#125;\n\n    private int findSmaller(int[][] matrix, int mid, int n) &#123;\n        int count = 0;\n        int i = n - 1;\n        int j = 0;\n        while (i >= 0 &amp;&amp; j &lt; n) &#123;\n            if (matrix[i][j] &lt;= mid) &#123;\n                count += i + 1;\n                j++;\n            &#125; else &#123;\n                i--;\n            &#125;\n        &#125;\n        return count;\n    &#125;\n&#125;","categories":["LeetCode"],"tags":["Java","LeetCode","数组","排序","二分查找","矩阵"]},{"title":"LeetCode精选TOP面试题328.奇偶链表","url":"/archives/298e7cdd.html","content":"题目描述\n给定一个单链表，把所有的奇数节点和偶数节点分别排在一起。\n这里的奇数节点和偶数节点指的是节点编号的奇偶性，而不是节点的值的奇偶性。\n使用原地算法完成。空间复杂度应为 O(1)，时间复杂度应为 O(nodes)，nodes 为节点总数。\n\nexample\ninput  : 1->2->3->4->5->NULL\noutput : 1->3->5->2->4->NULL\ninput  : 2->1->3->5->6->4->7->NULL \noutput : 2->3->6->7->1->5->4->NULL\n\n\n\n解题思路\n空链表直接返回\n用odd代表奇位链表，even代表偶位链表\np起始指向链表头节点head，q起始指向链表头节点的第一个后继结点hexd.next\n用p遍历奇位节点，q遍历偶位节点\n最后当 q为空（防止节点总数为偶数时报错空指针）或者 q.next为空（防止节点总数为奇数时报错空指针）时，结束遍历\n令p指向even，则可得到重新排序后的奇偶链表（头节点为odd）\n\n代码（Java）public class Solution &#123;\n    public ListNode oddEvenList(ListNode head) &#123;\n        if (head == null) &#123;\n            return head;\n        &#125;\n        ListNode odd = head;\n        ListNode even = head.next;\n        ListNode p = head;\n        ListNode q = head.next;\n        while (q != null &amp;&amp; q.next != null) &#123;\n            p.next = q.next;\n            p = p.next;\n            q.next = p.next;\n            q = q.next;\n\n        &#125;\n        /*while (list1 != null)&#123;\n            System.out.print(list1.val + \" \");\n            list1 = list1.next;\n        &#125;\n        System.out.println();\n        while (list2 != null)&#123;\n            System.out.print(list2.val + \" \");\n            list2 = list2.next;\n        &#125;*/\n        p.next = even;\n\n        return odd;\n    &#125;\n&#125;","categories":["LeetCode"],"tags":["Java","LeetCode","链表"]},{"title":"LeetCode精选TOP面试题172.阶乘后的零","url":"/archives/9149f718.html","content":"题目描述\n给定一个整数 n ，返回 n! 结果中尾随零的数量。\n提示 n! = n * (n - 1) * (n - 2) * … * 3 * 2 * 1\n\nexample\ninput  : n = 3\noutput : 0\nnote   : 3! = 6 ，不含尾随 0\ninput  : n = 5\noutput : 1\nnote   : 5! = 120 ，有一个尾随 0\ninput  : n = 0\noutput : 0\n\n\n\n解题思路\n基本思路：n中包含多少个5，其阶乘值就有多少个尾随的0\nn的阶乘尾随0，可以理解为不断乘10得到的，所以找到n中包含多少因数10，就可以知道阶乘值有多少尾随0\n将因数10拆分，是由因数5和因素2得到的，而因数2每隔两个数出现一次，因数5每隔5个数出现一次，故因数2的个数远多于因数5\n所以，有多少个因数5，就有多少个尾随0\n除了每隔5个数出现一次因数5之外，每隔25个数也会多出现一次因数5，因为25 = 5 × 5，即n中有多少个25，就多包含了几个因数5；以此类推，每隔125个数……\n因此，n中包含的因数5的个数应当为： \n\nn / 5 + n / 25 + n / 125 + ……\n\n\n\n\n时间复杂度： O(log n)\n空间复杂度：O(1)\n\n作者：LeetCode链接：https://leetcode-cn.com/problems/factorial-trailing-zeroes/solution/jie-cheng-hou-de-ling-by-leetcode/来源：力扣（LeetCode）著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n思路1 循环\n\n循环，用n累除5，并把每次除以5的数量累加到结果上\n\n思路2 递归\n\n每次把 n / 5 作为新的参数投入到新一轮递归计算中\n递归边界为 n = 0\n\n思路3 BigInteger\n\n借助Java的大数，先计算阶乘，再不断取余判断是否余数为0，若为0则结果加1，阶乘值除10\n会超出时间限制\n\n代码（Java）思路1代码\npublic class Solution1 &#123;\n    public int trailingZeroes(int n) &#123;\n        int count = 0;\n        while (n > 0) &#123;\n            n = n / 5;\n            count += n;\n        &#125;\n        return count;\n\n    &#125;\n&#125;\n思路2代码\npublic class Solution2 &#123;\n    public int trailingZeroes(int n) &#123;\n        if (n == 0) &#123;\n            return 0;\n        &#125;\n        return (n / 5) + trailingZeroes(n / 5);\n    &#125;\n&#125;\n思路2代码\npublic class Solution3 &#123;\n    public int trailingZeroes(int n) &#123;\n        int count = 0;\n        BigInteger x = new BigInteger(String.valueOf(n));\n        for (int i = n - 1; i > 1; i --) &#123;\n            x = x.multiply(new BigInteger(String.valueOf(i)));\n        &#125;\n        System.out.println(x);\n        while (x.mod(BigInteger.TEN).equals(BigInteger.ZERO)) &#123;\n            count ++;\n            x = x.divide(BigInteger.TEN);\n        &#125;\n\n        return count;\n    &#125;\n&#125;\n\n","categories":["LeetCode"],"tags":["Java","LeetCode","数学","递归"]},{"title":"LeetCode精选TOP面试题454.四数相加II","url":"/archives/2565682e.html","content":"题目描述\n给定四个整数数组 nums1、nums2、nums3 和 nums4 ，数组长度都是 n ，请计算有多少个元组 (i, j, k, l) 能满足：\n0 &lt;= i, j, k, l &lt; n\nnums1[i] + nums2[j] + nums3[k] + nums4[l] == 0\n\nexample\ninput  : nums1 = [1,2], nums2 = [-2,-1], nums3 = [-1,2], nums4 = [0,2]\noutput : 2\nnote   : 两个元组如下：\n         1. (0, 0, 0, 1) -> nums1[0] + nums2[0] + nums3[0] + nums4[1] = 1 + (-2) + (-1) + 2 = 0\n         2. (1, 1, 0, 0) -> nums1[1] + nums2[1] + nums3[0] + nums4[0] = 2 + (-1) + (-1) + 0 = 0\ninput  : nums1 = [0], nums2 = [0], nums3 = [0], nums4 = [0]\noutput : 1\n\n\n\n解题思路思路\n\n将四个数组分成两部分 A 和 B 为一组，C 和 D 为另外一组。\n对于 A 和 B，使用二重循环对它们进行遍历，得到所有 A[i]+B[j] 的值并存入哈希映射中，每个键表示一种 A[i]+B[j]，对应的值为 A[i]+B[j] 出现的次数。\n对于 C 和 D，使用二重循环对它们进行遍历，当遍历到 C[k]+D[l] 时，如果 -(C[k]+D[l]) 出现在哈希映射中，那么将 -(C[k]+D[l]) 对应的值累加进答案中。\n最终即可得到满足 A[i]+B[j]+C[k]+D[l]=0 的四元组数目\n时间复杂度O(n^2)，二重循环\n空间复杂度O(n^2)，最坏的情况下，A[i]+B[j] 的值均不相同，因此值的个数为 n^2\n\n代码（Java）public class Solution &#123;\n    public int fourSumCount(int[] nums1, int[] nums2, int[] nums3, int[] nums4) &#123;\n        int result = 0;\n        Map&lt;Integer, Integer> hashmap = new HashMap&lt;Integer, Integer>();\n        for (int num1 : nums1) &#123;\n            for (int num2 : nums2) &#123;\n                hashmap.put(num1 + num2, hashmap.getOrDefault(num1 + num2, 0) + 1);\n            &#125;\n        &#125;\n        for (int num3 : nums3) &#123;\n            for (int num4 : nums4) &#123;\n                if (hashmap.containsKey(- num3 - num4)) &#123;\n                    result += hashmap.get(- num3 - num4);\n                &#125;\n            &#125;\n        &#125;\n        return result;\n    &#125;\n&#125;\n\n","categories":["LeetCode"],"tags":["Java","LeetCode","数组","哈希表"]},{"title":"LeetCode精选TOP面试题073.矩阵置零","url":"/archives/4fc659f0.html","content":"题目描述\n给定一个 m x n 的矩阵，如果一个元素为 0 ，则将其所在行和列的所有元素原地都设为 0 。\n\nexample\ninput  : matrix = [[1,1,1],[1,0,1],[1,1,1]]\noutput : [[1,0,1],[0,0,0],[1,0,1]]\ninput  : matrix = [[0,1,2,0],[3,4,5,2],[1,3,1,5]]\noutput : [[0,0,0,0],[0,4,5,0],[0,3,1,0]]\n\n\n\n解题思路思路1 辅助标记\n\n定义两个标记变量，记录第一行、第一列是否初始时就存在0\n以第一行和第一列作为该行/列是否存在0的标记空间\n首先遍历第一行，若第一行初始就存在0，则置标记flagRow = true\n然后遍历第一列，若第一列初始就存在0，则置标记flagCol = true\n然后遍历数组中除了第一行和第一列之外的部分，若matrix[i][j] = 0，则置为该元素对应行、列的首元素为0，即令 matrix[i][0] = matrix[0][j] = 0\n遍历数组中除了第一行和第一列之外的部分，若某元素matrix[i][j]对应行的首元素和该元素对应列的首元素均为0，即matrix[i][0] = matrix[0][j] = 0，则置matrix[i][j]=0\n检查标记flagRow，若flagRow = true，则将首行元素全部置为0\n检查标记flagCol，若flagCol = true，则将首列元素全部置为0\n单独标记和遍历首行和首列元素，可能会导致不必要的置0操作，将不应该置为0的元素也置0了\n空间复杂度 O(1)\n\n思路2 辅助数组\n\n定义两个标记数组flagRow[matrix.length]、flagCol[matrix[0].length]，分别记录发现0的行列位置\n当某元素 matrix[i][j] = 0 时，置对应的行列标记数组中的元素为0，即flagRow[i] = flagCol[j] = true\n遍历整个二维数组，以遍历到元素 matrix[i][j] 为例，当行 / 列标记数组对应位置元素值为 true 时，证明当前元素位于需要被全部置为0的 行 / 列，将该元素置为0，即matrix[i][j] = 0\n空间复杂度O(m + n)\n\n代码（Java）思路1代码\npublic class Solution1 &#123;\n    public void setZeroes(int[][] matrix) &#123;\n        boolean flagRow = false;\n        boolean flagCol = false;\n        for (int i = 0; i &lt; matrix[0].length; i++) &#123;\n            if (matrix[0][i] == 0) &#123;\n                flagRow = true;\n            &#125;\n        &#125;\n        for (int j = 0; j &lt; matrix.length; j++) &#123;\n            if (matrix[j][0] == 0) &#123;\n                flagCol = true;\n            &#125;\n        &#125;\n        System.out.println(\"flagRow : \" + flagRow);\n        System.out.println(\"flagCol : \" + flagCol);\n\n        System.out.println(\"set flag---------\");\n        for (int i = 0; i &lt; matrix.length; i++) &#123;\n            for (int j = 0; j &lt; matrix[0].length; j++) &#123;\n                if (matrix[i][j] == 0) &#123;\n                    matrix[i][0] = 0;\n                    matrix[0][j] = 0;\n                &#125;\n            &#125;\n        &#125;\n        for (int i = 0; i &lt; matrix.length; i++) &#123;\n            for (int j = 0; j &lt; matrix[0].length; j++) &#123;\n                System.out.print(matrix[i][j] + \"\\t          \");\n            &#125;\n            System.out.println();\n        &#125;\n\n        System.out.println(\"set zero---------\");\n        for (int i = 1; i &lt; matrix.length; i++) &#123;\n            for (int j = 1; j &lt; matrix[i].length; j++) &#123;\n                if (matrix[i][0] == 0 || matrix[0][j] == 0) &#123;\n                    matrix[i][j] = 0;\n                &#125;\n            &#125;\n        &#125;\n        for (int i = 0; i &lt; matrix.length; i++) &#123;\n            for (int j = 0; j &lt; matrix[0].length; j++) &#123;\n                System.out.print(matrix[i][j] + \"\\t          \");\n            &#125;\n            System.out.println();\n        &#125;\n\n        System.out.println(\"judge first ---------\");\n        if (flagRow) &#123;\n            for (int i = 0; i &lt; matrix[0].length; i++) &#123;\n                matrix[0][i] = 0;\n            &#125;\n        &#125;\n        if (flagCol) &#123;\n            for (int j = 0; j &lt; matrix.length; j++) &#123;\n                matrix[j][0] = 0;\n            &#125;\n        &#125;\n\n    &#125;\n&#125;\n思路2代码\npublic class Solution2 &#123;\n    // 辅助数组\n    public void setZeroes(int[][] matrix) &#123;\n        boolean[] flagRow = new boolean[matrix.length];\n        boolean[] flagCol = new boolean[matrix[0].length];\n        for (int i = 0; i &lt; matrix.length; i++) &#123;\n            for (int j = 0; j &lt; matrix[0].length; j++) &#123;\n                if (matrix[i][j] == 0) &#123;\n                    flagRow[i] = true;\n                    flagCol[j] = true;\n                &#125;\n            &#125;\n        &#125;\n\n        System.out.println(\"set zero---------\");\n        for (int i = 0; i &lt; matrix.length; i++) &#123;\n            for (int j = 0; j &lt; matrix[i].length; j++) &#123;\n                if (flagRow[i] || flagCol[j]) &#123;\n                    matrix[i][j] = 0;\n                &#125;\n            &#125;\n        &#125;\n    &#125;\n&#125;\n","categories":["LeetCode"],"tags":["Java","LeetCode","数组"]},{"title":"d2lzh_pytorch包报错问题解决","url":"/archives/78978eb1.html","content":"报错：\nModuleNotFoundError: No module named ‘d2lzh_pytorch’\nd2lzh_pytorch包中找不到名为’xxx’的属性/函数，如  module 'd2lzh_pytorch' has no attribute 'use_svg_display()'\nmodule 'd2lzh_pytorch' has no attribute 'load_data_fashion_mnist\n\n\n\n\n\n\n解决方法：\n方法1、放到Jupyter工作目录\n下载d2lzh_pytorch文件夹，将其放置到当前Jupyter的工作目录的根目录中即可\n\n\n方法2、放到虚拟环境的包安装目录\n下载d2lzh_pytorch文件夹，将其放置到anaconda虚拟环境的包路径下，如：Anaconda/envs/pytorch(虚拟环境名)/Lib/site-packages/\n注释代码中的sys.path.append(“..”)，使其从site-packages中找到d2lzh_pytorch包并引入\n\n\n\n","categories":["D2L"],"tags":["深度学习","PyTorch","Jupyter","Python"]},{"title":"Typora本地图片上传到图床","url":"/archives/e43ae7cd.html","content":"问题：使用Typora写文档时上传图片的路径默认是本地磁盘的路径。导致文档上传到csdn等博客网站时，出现图片失效无法识别的问题。设置Typora使用PicGo-Core将本地图片上传到图床，可以解决此问题（PicGo-Core，Typora Upload Images）。\n\n\n步骤如下：\n1.修改插入图片设置\n进入“文件 –&gt; 偏好设置 –&gt; 图像 –&gt;”\n将 插入图片时的操作 修改为“==上传图片==”\n\n2.下载PicGo-Core2.1 选择上传服务\n在偏好设置——图像中，选择上传服务为“==PicGo-Core(command line)==”2.2 点击下载或更新\n系统检测后会提示是否同意下载，同意下载即可3.配置SM.MS3.1 在smms官网注册免费账号\nsmms官网链接\n注册免费账号，会有5G免费内存\n\n3.2 获取token\n从dashboard的api token中复制token4.修改PicGo-Core配置文件\n\n4.1 打开配置文件\n图像设置界面“==打开配置文件==”\n4.2 填写token\n将以下代码和刚才复制的token填写到配置文件中\n&#123;\n  \"picBed\": &#123;\n    \"current\": \"smms\",\n    \"smms\": &#123;\n      \"token\": \"刚才复制的token\"\n    &#125;\n  &#125;,\n  \"picgoPlugins\": &#123;&#125;\n&#125;\n\n\n\n5.图片上传测试\n在Typora的操作界面新建.md文件并粘贴图片测试是否能够上传\n本文所有图片均为使用PicGo-Core上传的\n\n","categories":["其他"],"tags":["其他"]},{"title":"win10使用Anaconda创建可使用PyTorch虚拟环境","url":"/archives/2abdf615.html","content":"1、安装Anaconda\n可参考安装Anaconda+常用的conda命令+Anaconda换源+安装Jupyter\n\n2、创建虚拟环境\nwin10系统，进入cmd\n\n# 创建名为pytorch的虚拟环境\nconda create --name pytorch python=3.6\n# 激活名为pytorch的虚拟环境\nconda activate pytorch\n安装PyTorch包\n\n\n进入PyTorch官网，根据提示选择适合自己电脑配置的安装命令，如图，蓝色不跟需要注意选择\n# 在pytorch虚拟环境中使用官网提示的命令安装PyTorch，以仅使用cpu为例：\nconda install pytorch torchvision torchaudio cpuonly -c pytorch\n\n命令行输入python进入python，并输入下面代码可查看pytorch是否安装成功：\n\n\nimport torch\nimport torchvision\nprint(torch.__version)\n\n\n安装成功提示如图 \n\n","categories":["D2L"],"tags":["深度学习","PyTorch","Python"]},{"title":"安装Anaconda+常用的conda命令+Anaconda换源+安装Jupyter","url":"/archives/39dee8e5.html","content":"安装Anaconda\n下载并安装Anaconda\n\n常用的conda命令  # 创建虚拟环境\nconda create -n pytorch python=3.6\n# 删除虚拟环境\nconda env remove -n pytorch\n# 激活指定虚拟环境\nconda activate pytorch\n# 退出当前虚拟环境\nconda deactivate\n# 安装包，如numpy（提前进入目标环境）\nconda install numpy\n或\npip install numpy\n# 安装指定版本的包，如numpy\npip install numpy==1.6.0\n# 升级包\npip install --upgrade numpy\n# 卸载包\npip uninstall numpy\n# 查看conda中所有环境\nconda info -e\n# 查看某个环境中安装的所有包（提前进入目标环境）\nconda list\n\n\n\nAnaconda换源\n修改镜像为国内源，如清华源\n\n安装Jupyter\n安装Anaconda软件之后，在首页找到Jupyter点击Install。\n\n不同虚拟环境下各自的Jupyter，只需提前在Anaconda软件界面切换虚拟环境。\n\n为不同的jupyter指定不同的工作路径，首先为这个jupyter新增一个本地工作路径path，找到“开始”处新增的快捷方式：Jupyter Notebook (pytorch)，右键打开文件路径，再右键属性，修改目标(T)，把&quot;%USERPROFILE&quot;修改为指定路径path，如图。\n\n\n\n修改后单击该快捷方式即可进入网页使用JupyterNoteBook\n\n","categories":["D2L"],"tags":["深度学习","Jupyter","Anaconda","conda"]},{"title":"SpringBoot+Vue项目部署到Linux服务器","url":"/archives/b51853f8.html","content":"\nNote:1、Linux服务器选用的是CentOS7.7，其他类型也可以2、需要在服务器配置jdk和Nginx3、后端打包类型为jar包，war包需要自行修改后端配置4、暂未部署Docker，后续更新\n\n\n\n1、服务器配置1.1 安装宝塔\n参考宝塔官方教程即可，首先登录服务器，设置安全组放行端口，把8888放开，然后使用终端执行命令（以CentOS为例）\nyum install -y wget &amp;&amp; wget -O install.sh http://download.bt.cn/install/install_6.0.sh &amp;&amp; sh install.sh 2c87998c\n\n安装完成后记录终端处的登录入口、账号、密码，然后登录\n\n登录后需要注册个账号，注册绑定后即可正常使用宝塔\n\n\n1.2 安装并配置MySQL、Redis、Nginx\n使用宝塔安装Mysql、Redis、Nginx，便于管理\n在宝塔的软件商店中搜索Mysql、Redis、Nginx并快捷安装\n\n1.3 创建数据库并导入数据\n进入宝塔的数据库界面，添加数据库，填写数据库名、选择字符集、设置访问权限为所有人（这样才能使用其他终端访问），完成后提交，提示添加成功即为创建成功\n创建成功后，点击导入，把本地数据库的测试数据导入到服务器中的数据库。提示导入数据库成功即可。)\n\n1.4 安装并配置jdk1.4.1 官网下载JDK并上传到服务器\n从官网下载可用于Linux的jdk包，通过宝塔上传到服务器\n\n建议上传到/www/server下\n\nPS：/www/server是宝塔软件的默认安装目录，把软件都放到一起，方便查找\n\n\n然后使用终端，进入jdk的上传目录，使用解压命令，把上传的jdk文件解压到当前目录，然后把解压后的文件夹重命名为jdk8\ntar -zxvf jdk-8u311-linux-x64.tar.gz\nmv jdk1.8.0_311 jdk8\n\n\n\n1.4.2 配置环境变量\n1.打开 /etc/profile 文件\nvim profile\n\n2.在 profile 文件末尾，配置jdk环境\nexport JAVA_HOME=/www/server/jdk8\nexport CLASSPATH=$:CLASSPATH:$JAVA_HOME/lib/\nexport PATH=$JAVA_HOME/bin:$PATH\nexport JRE_HOME=$JAVA_HOME/jre\n\n3.使 profile 生效\nsource profile\n\n4.查看jdk是否配置成功\njava -version \n\n显示版本号即为配置成功\n1.5  安全组配置、放行端口配置\n\n1.5.1 安全组配置\n登录云服务器，在控制台处找到服务器，然后对安全组规则进行更改\n\n以华为云为例，在入方向规则处添加前后端使用的端口（如8080和8081）\n1.5.2 放行端口配置\n在宝塔的安全功能中放行前后端项目需要使用的端口，如8080和8081\n2、SpringBoot项目配置\n\n2.1 配置修改\n后端拆分application.yml配置文件，可拆分出本地dev和生产pro两个（也可以多拆出test）\n\napplication.yml文件中保留通用配置\n\napplication-dev.yml文件中配置本地运行项目所用的配置\n\napplication-pro.yml文件中配置服务器中运行项目所用的配置，其中服务器数据库名称，即为1.3节中添加的数据库名，密码从宝塔界面点击复制即可，注意不是使用root密码，而是使用刚创建的数据库的密码（下图有误，redis的host保持127.0.0.1即可）)\n\ndev和pro的不同之处主要是MySQL的配置。\n\npro中需要按照服务器的IP和数据库配置来填写，可在application.yml文件中修改active指向pro，来测试是否能够成功连接服务器中的数据库\n\n\n\n2.2 打包\n修改application.yml文件中的active:pro，然后执行maven clean，清除本地测试时生成的jar包\n\n执行maven package，后端项目打包完成\n2.3 上传到服务器\n找到项目路径下打包出的文件 target，找到target下的打包文件，后缀名是 .jar，即可运行的jar包，然后使用宝塔将其从本地路径中上传到服务器，路径可以为 /www/wwwroot/project_name，末尾的project_name文件夹可按照自己需求新建\n\n PS：/www/wwwroot路径是宝塔默认建站目录，放到此处便于查找\n\n\n\n\n2.4 后端项目服务器配置\n只需确保jdk安装成功，且jar包上传成功即可\n\n2.5 运行测试2.5.1 运行后端jar包在Linux系统下有多种运行jar包的方式。建议使用方法d，保留项目运行日志。日志文件会生成到项目同级路径下。\n\na.当前终端被锁定，可按CTRL + C打断程序运行，或关闭窗口退出程序\njava -jar xxx.jar  \n\nb.当前终端不被锁定，但是当窗口关闭时，程序中止运行\njava -jar xxx.jar &amp;\n\nc.不挂断运行命令,当账户退出或终端关闭时,程序仍然运行\nnohup java -jar xxxx.jar &amp;\n\nd.指定输出日志文件，不挂断运行命令，退出或终端关闭时程序仍然运行\nnohup java -jar xxx.jar > project.log\n\n\n\n2.5.2 查看日志文件\n建议使用动态查看命令，查看实时更新的日志，打开一个新的终端，输入如下命令：\ntail -f project.log\n\n\n\n2.5.2 停止运行后端jar包\n若使用2.5.1种的方法a、b，直接关闭终端即可\n\n若使用2.5.1种的方法c、d，需要查找后端使用端口（这个端口号是填写在SpringBoot项目的application.yml文件中server项中的）占用的进程号，然后关闭进程，即可停掉jar包的运行。命令如下：\nnetstat -tunlp | grep 端口号\n\n// 得到进程号\n\nkill -9 进程号\n\n操作如图，8081是我的后端项目占用的端口号，13061是进程ID\n\n\n3、Vue项目配置3.1 配置修改\naxios.js文件的URL配置为  ==服务器公网IP:端口号==\n\naxios.defaults.baseURL = &quot;http://服务器公网IP:端口号&quot;\n// axios.defaults.baseURL = &quot;http://localhost:端口号&quot; 本地使用localhost\n\n### 3.2 打包\n\n+ 打包命令\n\n  &#96;&#96;&#96;plain\n  npm run build\n\n打包后的文件名为dist，可在项目路径下查看\n\n\n3.3 上传到服务器\n通过宝塔可直接上传dist文件夹，如果没有宝塔，可以将dist文件夹压缩后上传到服务器\n建议上传到与2.3节中提到的后端项目上传路径中，相同一个需求的前后端项目放到同一个文件夹中便于查找：/www/wwwroot/project_name\n\n3.4 前端项目服务器配置\n需要对服务器的Nginx进行配置，以满足前端项目的运行\n\n通过宝塔安装Nginx，其默认的配置文件会被备份为 nginx.conf.default，且生成一份新的配置文件 nginx.conf。\n\n如果是使用宝塔安装的Nginx，则文件存放路径为/www/server/nginx/conf\n\n首先从 nginx.conf.default 中复制一份以 server 为标签的代码，如下图：\n\n真正需要修改文件的是 nginx.conf，此文件可以通过宝塔界面的“软件商店”—“Nginx”—“设置”—“配置修改”来修改，在此处修改时如果修改的格式有误等错误会被提示无法保存\n\n将上一步复制的server代码段复制到文件中的 include 标签上方（配置文件中会有一个已经存在的server 标签，不需要覆盖，顺着它粘贴代码段A即可，不会冲突）\n\n删除代码段中所有注释，保留四个未被注释的标签（listen、server_name、location / 、error_page）即可\n\n修改上述四个标签\n\n(1)listen标签后填写前端项目要使用的端口号\n\n(2)server_name标签填写服务器公网IP\n\n(3)location标签的root标签填写vue项目的打包文件dist的路径\n\n(4)location标签的添加一行代码标签防止刷新出现404\ntry_files $uri $uri/ /index.html; \n\n(5)error_page标签不需要变动\n\n\n\n\n\n重载Nginx配置并重新启动即可，在宝塔的界面操作很方便\n\n3.5 运行测试\n确保已经重载Nginx配置并重新启动\n在浏览器输入服务器公网IP:端口，查看是否能够进入vue项目首页\n\n4、部署到服务器的前后端联调测试4.1 运行后端项目\nnohup java -jar xxx.jar &gt; project.log\n\n4.2 运行前端项目\n启动Nginx\n\n4.3 访问与功能测试\n浏览器输入服务器公网IP:端口，测试能否进入项目\n测试项目功能是否完整可用\n测试是否有功能与本地测试效果不符\n\n5、后续部署Docker（待完成）6、可能存在的问题：1、打包失败\n保错：\nFailed to execute goal org.apache.maven.plugins:maven-surefire-plugin:2.22.2:test (default-test) on project XXX: There are test failures.\nPlease refer to D:\\IDEAWorkSpace\\blog\\target\\surefire-reports for the individual test results.Please refer to dump files (if any exist) [date].dump, [date]-jvmRun[N].dump and [date].dumpstream.\n\n解决\n使用命令，跳过测试打包\nmvn clean package -Dmaven.test.skip=true\n\n\n","categories":["SpringBoot+Vue"],"tags":["SpringBoot","Vue","Linux","云服务器","部署","Nginx"]},{"title":"LeetCode精选TOP面试题105.从前序与中序遍历序列构造二叉树","url":"/archives/5cd56a60.html","content":"题目描述\n给定一棵树的前序遍历 preorder 与中序遍历  inorder 。请构造二叉树并返回其根节点。\npreorder 和 inorder 均无重复元素\n\nexample\ninput  : preorder = [3,9,20,15,7], inorder = [9,3,15,20,7]\noutput : [3,9,20,null,null,15,7]\ninput  : preorder = [-1], inorder = [-1]\noutput : [-1]\n\n\n\n解题思路思路 递归\n\n根据前序遍历和中序遍历序列的性质，以及数组不含重复元素的性质\n前序遍历的首个元素，是树的根节点，其后依次为根节点左子树的前序遍历序列（可为空）、根节点右子树的前序遍历序列（可为空）\n中序遍历的根节点元素两侧，分别是根节点的左子树的中序遍历序列（可为空）、右子树的中序遍历序列（可为空）\n每个子树的前序遍历和中序遍历序列依然符合上述性质\n故使用 迭代 不断构建子树，退出标志是数组为空\n先取每次迭代中 前序遍历序列的首个元素 tree ，找到中序遍历序列中的值相等的元素位置\n获取 tree 的 左子树 在前序遍历和中序遍历序列中的 子序列，复制到新的可用于新一轮迭代的数组leftPre、leftIn中\n使用 tree 节点的前序遍历和中序遍历序列进行新一轮迭代，构建 tree节点的左子树    \n获取 tree 的 右子树 在前序遍历和中序遍历序列中的 子序列，复制到新的可用于新一轮迭代的数组rightPre、rightIn中\n使用 tree 节点的前序遍历和中序遍历序列进行新一轮迭代，构建 tree节点的右子树\n\n\n\n代码（Java）public class Solution &#123;\n    public TreeNode buildTree(int[] preorder, int[] inorder) &#123;\n        if (null == preorder || preorder.length == 0) &#123;\n            return null;\n        &#125;\n        int length = preorder.length;\n        // 从前序遍历数组中获取每一轮的根节点\n        TreeNode tree = new TreeNode(preorder[0]);\n\n        // 从中序遍历数组中找到根的位置，以便接下来获取其左右子树\n        int index = 0;\n        while (index &lt; length) &#123;\n            if (inorder[index] == tree.val) &#123;\n                break;\n            &#125;\n            index++;\n        &#125;\n\n        // 以下开始分别构建当前节点的左右子树\n\n        // 构建左子树\n        if (index > 0) &#123;\n            // 左子树不为空，获取tree的左子树在前序遍历和中序遍历序列中的子序列，复制到新的可用于新一轮迭代的数组中\n            int[] leftPre = Arrays.copyOfRange(preorder, 1, index + 1);\n            int[] leftIn = Arrays.copyOfRange(inorder, 0, index);\n            // 递归构建左子树\n            tree.left = buildTree(leftPre, leftIn);\n        &#125; else &#123;\n            // 左子树为空\n            tree.left = null;\n        &#125;\n\n        // 构建右子树\n        int rlen = length - index - 1;\n        if (rlen > 0) &#123;\n            // 右子树不为空，获取tree的右子树在前序遍历和中序遍历序列中的子序列，复制到新的可用于新一轮迭代的数组中\n            int[] rightPre = Arrays.copyOfRange(preorder, index + 1, index + 1 + rlen);\n            int[] righIn = Arrays.copyOfRange(inorder, index + 1, index + 1 + rlen);\n            // 递归构建左子树\n            tree.right = buildTree(rightPre, righIn);\n        &#125; else &#123;\n            // 右子树为空\n            tree.right = null;\n        &#125;\n\n        return tree;\n    &#125;\n&#125;","categories":["LeetCode"],"tags":["Java","LeetCode","分治","数组","二叉树","树"]},{"title":"LeetCode精选TOP面试题230.二叉搜索树中第K小的元素","url":"/archives/db6ffafa.html","content":"题目描述\n给定一个二叉搜索树的根节点 root ，和一个整数 k\n设计一个算法查找其中第 k 个最小元素（从 1 开始计数）。example\ninput  : root = [3,1,4,null,2], k = 1\noutput : 1\nnote   :    3\n           / \\\n          1   4\n           \\\n            2\ninput  : root = [5,3,6,2,4,null,null,1], k = 3\noutput : 3\nnote   :         5\n                / \\\n               3   6\n              /  \\\n             2    4\n            /\n           1\n\n\n\n\n\n解题思路思路1 直接中序遍历全部节点\n\n直接递归，中序遍历整个树\n递归过程中把节点值依次存放到列表中\n因为二叉搜索树的中序遍历结果是升序的，所以直接返回列表的第k个元素值即可\n时间复杂度：O(H+k)，H 是树的高度。在开始遍历之前，需要 O(H)到达叶结点。当树是平衡树时，时间复杂度取得最小值 O(logN+k)；当树是线性树（树中每个结点都只有一个子结点或没有子结点）时，时间复杂度取得最大值 O(N+k)。\n空间复杂度：O(H)，栈中最多需要存储 H 个元素。当树是平衡树时，空间复杂度取得最小值 O(logN)；当树是线性树时，空间复杂度取得最大值 O(N)。\n\n思路2 栈模拟中序遍历前k个节点\n\n为减少遍历次数，优化思路是不要遍历整个的树，利用二叉搜索树的性质，遍历到目标元素时就停止\n用栈模拟递归过程，中序遍历前k个节点\n每次（假设当前是第 i 次）栈顶节点出栈，说明栈顶节点是整个树中的第 i 个小的值（二叉搜索时的中序遍历性质决定） \n直接跳出遍历，返回最后一次弹出栈的节点值即可\n时间复杂度：O(H+k)，H 是树的高度。在开始遍历之前，需要 O(H)到达叶结点。当树是平衡树时，时间复杂度取得最小值 O(logN+k)；当树是线性树（树中每个结点都只有一个子结点或没有子结点）时，时间复杂度取得最大值 O(N+k)。\n空间复杂度：O(H)，栈中最多需要存储 H 个元素。当树是平衡树时，空间复杂度取得最小值 O(logN)；当树是线性树时，空间复杂度取得最大值 O(N)。\n\n思路3 记录子树的结点数\n\n如果需要频繁地查找第 k 小的值，优化思路是记录下以每个结点为根结点的子树的结点数，在查找第 k 小的值时，不断缩小查找范围 \n令 node 等于根结点，开始搜索\n记 node 的左子树的结点数为 left \n若 left 小于 k-1，则第 k 小的元素一定在 node 的右子树中，令 node 等于其的右子结点，k 更新为 k−left−1，继续搜索；\n若 left 等于 k-1，则第 k 小的元素即为 node ，结束搜索并返回 node 即可；\n若 left 大于 k-1，则第 k 小的元素一定在 node 的左子树中，令 node 等于其左子结点，继续搜索。\n时间复杂度：预处理的时间复杂度为 O(N)，其中 N 是树中结点的总数；需要遍历树中所有结点来统计以每个结点为根结点的子树的结点数。搜索的时间复杂度为 O(H)，其中 HH 是树的高度；当树是平衡树时，时间复杂度取得最小值 O(logN)；当树是线性树时，时间复杂度取得最大值 O(N)。\n空间复杂度：O(N)，用于存储以每个结点为根结点的子树的结点数。\n\n思路3参考了LeetCode官方题解\n代码（Java）思路1代码\npublic class Solution1 &#123;\n    List&lt;Integer> list = new ArrayList&lt;>();\n    public int kthSmallest(TreeNode root, int k) &#123;\n        // 中序遍历，DFS\n        DFS(root);\n        for (int i : list) &#123;\n            System.out.print(i + \" \");\n        &#125;\n        return list.get(k - 1);\n    &#125;\n\n    private void DFS(TreeNode root) &#123;\n        if (root == null) &#123;\n            return;\n        &#125;\n        DFS(root.left);\n        list.add(root.val);\n        DFS(root.right);\n    &#125;\n&#125;\n思路2代码\npublic class Solution2 &#123;\n    public int kthSmallest(TreeNode root, int k) &#123;\n        // 用栈模拟实现中序遍历\n        Stack&lt;TreeNode> stack = new Stack&lt;>();\n        // 需要保证从最小的元素作为第一个入栈元素，所以不能在循环外把根节点压入栈，故循环的边界条件添加了||root!=null条件\n        while (!stack.isEmpty() || root != null) &#123;\n            while (root != null) &#123;\n                stack.add(root);\n                root = root.left;\n            &#125;\n            root = stack.pop();\n            System.out.print(root.val + \" \");\n            k--;\n            // 第k个弹出栈的节点，其值一定为第k小的\n            if (k == 0) &#123;\n                break;\n            &#125;\n            root = root.right;\n        &#125;\n        return root.val;\n    &#125;\n&#125;\n思路3代码\npublic class Solution3 &#123;\n    public int kthSmallest(TreeNode root, int k) &#123;\n        MyBst myBst = new MyBst(root);\n        return myBst.kthSmallest(k);\n    &#125;\n&#125;\n\nclass MyBst &#123;\n    TreeNode root;\n    Map&lt;TreeNode, Integer> nodeNumber;\n\n    public MyBst(TreeNode root) &#123;\n        this.root = root;\n        this.nodeNumber = new HashMap&lt;TreeNode, Integer>();\n        countNumber(root);\n    &#125;\n\n    // 统计以node为根结点的子树的结点数\n    private int countNumber(TreeNode node) &#123;\n        if (node == null) &#123;\n            return 0;\n        &#125;\n        nodeNumber.put(node, countNumber(node.left) + countNumber(node.right) + 1);\n        return nodeNumber.get(node);\n    &#125;\n\n    // 返回二叉搜索树中第k小的元素\n    public int kthSmallest(int k) &#123;\n        TreeNode node = root;\n        while (node != null) &#123;\n            int left = getNumber(node.left);\n            if (left == k - 1) &#123;\n                break;\n            &#125; else if (left > k - 1) &#123;\n                node = node.left;\n            &#125; else &#123;\n                node = node.right;\n                k = k - left - 1;\n            &#125;\n        &#125;\n        return node.val;\n    &#125;\n\n    private int getNumber(TreeNode node) &#123;\n        return nodeNumber.getOrDefault(node, 0);\n    &#125;\n&#125;","categories":["LeetCode"],"tags":["Java","LeetCode","中序遍历","二叉树","二叉搜索树","DFS","树"]},{"title":"LeetCode精选TOP面试题102.二叉树的层次遍历","url":"/archives/d5005260.html","content":"题目描述\n给定一个二叉树，返回按 层序遍历 得到的节点值。\n即逐层地，从左到右访问所有节点。\n相同层的节点值放在一个列表中\n\nexample\ninput  : [3, 9, 20, null, null, 15, 7]\noutput : [[3], [9,20], [15,7]]\nnote   :     3\n            / \\\n           9  20\n             /  \\\n            15   7\n\n\n\n解题思路思路\n\n借助队列 queue 实现二叉树的层次遍历（广度优先遍历）\n\n根节点入队\n\n使用循环判断队列是否为空\n\n每次循环时，队列的长度 queue.size()，即为当前层的节点数量\n使用for循环，把队列中当前层的节点 treeNode 逐个移除队列并访问\n把每个 treeNode 的值逐个添加到每一层的列表中\n当前被访问的节点 treeNode 若有左子树（treeNode.left != null），则左子树入队\n当前被访问的节点 treeNode 若有右子树（treeNode.right != null），则右子树入队\n\n\n把每层的节点值列表，添加到结果列表 lists 中\n\n\n队列为空时，说明遍历结束，返回lists\n\n时间复杂度：O(n)，每个节点进队出队各一次。\n\n空间复杂度：O(n)，队列中元素的个数不超过 n 个。\n\n\n代码（Java）public class Solution &#123;\n    public List&lt;List&lt;Integer>> levelOrder(TreeNode root) &#123;\n        // 空树直接返回空列表\n        List&lt;List&lt;Integer>> lists = new LinkedList&lt;>();\n        if (root == null) &#123;\n            return lists;\n        &#125;\n        Queue&lt;TreeNode> queue = new LinkedList&lt;>();\n        // 根节点先入队\n        queue.add(root);\n        while (!queue.isEmpty()) &#123;\n            int currentSize = queue.size();\n            List&lt;Integer> list = new LinkedList&lt;>();\n            for (int i = 0; i &lt; currentSize; i++) &#123;\n                TreeNode treeNode = queue.poll();\n\n                list.add(treeNode.val);\n                if (treeNode.left != null) &#123;\n                    queue.add(treeNode.left);\n                &#125;\n                if (treeNode.right != null) &#123;\n                    queue.add(treeNode.right);\n                &#125;\n                // System.out.print(treeNode.val + \", \");\n            &#125;\n            lists.add(list);\n            // System.out.println();\n        &#125;\n        return lists;\n    &#125;\n&#125;\n","categories":["LeetCode"],"tags":["Java","LeetCode","面试","二叉树","树","BFS","队列"]},{"title":"LeetCode精选TOP面试题287.寻找重复数","url":"/archives/89d14ef4.html","content":"题目描述\n给定一个包含 n + 1 个整数的数组 nums ，其数字都在 1 到 n 之间（包括 1 和 n），可知至少存在一个重复的整数。\n假设 nums 只有一个重复的整数 ，找出 这个重复的数 。\n解决方案必须不修改数组 nums 且只用常量级 O(1) 的额外空间。\n提示：\n1 &lt;= n &lt;= 105\nnums.length == n + 1\n1 &lt;= nums[i] &lt;= n\nnums 中 只有一个整数 出现 两次或多次 ，其余整数均只出现 一次\n进阶：\n如何证明 nums 中至少存在一个重复的数字?\n设计一个线性级时间复杂度 O(n) 的解决方案\n\n\n\nexample\ninput  : nums = &#123;1,3,4,2,2&#125;\noutput : 2\ninput  : nums = &#123;3,1,3,4,2&#125;\noutput : 3\ninput  : nums = &#123;1,1,2&#125;\noutput : 1\n\n\n\n解题思路思路1: HashSet\n\n借助 HashSet 存储数组元素，便于查重\n遍历数组，假设当前遍历的元素为 item\n若 item 不存在于 HashSet 中，则将其添加进 HashSet\n若 item 存在于 HashSet 中，直接返回 item\n\n\n时间复杂度O(n)\n空间复杂度O(n)\n题目不允许空间复杂度O(n)，虽然使用HashSet编写代码很快，但是违反了题目要求\n\n思路2: 双指针（快慢）\n\n由索引找到元素，再将这个元素作为索引，继续找下一个元素，因为数组中有重复元素，故最终会形成一个循环\n定义快慢指针\n快指针 faster 每次遍历前进2次（以当前faster作为索引得到的元素值A（nums[faster]），再做为索引获得新的元素值B（nums[nums[faster]]），把B再赋值给快指针 faster，即 faster = num[nums[faster]]）\n慢指针 slower 每次遍历前进1次（以当前faster作为索引得到的元素值C（nums[slower]），把C再赋值给快指针 slower，即 slower = nums[slower]）\n\n\n当快慢指针相遇时，说明两者到了循环的入口，循环的入口不是重复的数字\n所以找到循环入口之后，还要再找重复的数字\n设置一个从数组起始位置出发的新指针 p ，前进形式与slower相同\n在不断循环之后， p 与 slower 两指针指向的值相等时，就得到了重复的数字\n\n\n\n思路3: 二分查找\n\nn+1个数，都属于[1, n]，只有一个重复的整数\n想象把 n+1 个无色球，放进n个颜色不同的染缸，必然有一个染缸中存在两个球\n即必然有一个数是出现了两次的（必然有两个球的颜色是相同的）\n考虑这个有序区间 [1, n]\n假设现在存在数组 array 包含了 n 个不重复 的整数，属于区间[1, n]\n遍历这个数组 array，不必考虑其排列顺序，统计小于或等于 mid 的数，累加到 count1 上\n则必然会有：count1 = mid ！！！\n============分割线===============\n现在思考题目中给的数组，nums包含了n+1个属于区间[1, n]的数，有一个重复的整数\n遍历这个数组，不必考虑其排列顺序，统计 小于或等于 mid  的数，累加到 count2 上\n因为有一个数重复，故必然会有：count2 &gt; mid 或者 count2 = mid\n若 count2 &gt; mid，说明数组nums中，小于或等于mid的数里，出现了重复的整数\n若 count2 = mid，说明数组nums中，小于或等于mid的数里，没有重复的整数\n\n\n\n\n⭐设定 left = 1，right = n，mid = （left + right）/ 2，此处的 left 、right 、mid 用于描述区间！只与区间有关！        \n根据上述思路，借助 与数组[1, n]有关的变量left、right、mid，对区间 [1, n] 进行二分查找！！！是对区间进行查找，不是对数组\n查找过程中，统计小于或等于 mid  的数，累加到 count2 上\ncount2 &gt; mid时，更新 right = mid\ncount2 = mid时，更新 left = mid + 1\n\n\n\n\n最后 left 和 right 相等时，查找结束，其值即为那个重复的整数。\n时间复杂度O(n logn)，在二分内部有for循环，时间复杂度为O(N)。\n空间复杂度O(1)\n\n代码（Java）思路1代码\npublic class Solution1 &#123;\n    public int findDuplicate(int[] nums) &#123;\n\n        HashSet hashSet = new HashSet();\n        for (int item : nums) &#123;\n            if (hashSet.contains(item)) &#123;\n                return item;\n            &#125;\n            hashSet.add(item);\n        &#125;\n        return 0;\n    &#125;\n&#125;\n思路2代码\npublic class Solution2 &#123;\n    public int findDuplicate(int[] nums) &#123;\n        int slower = nums[0];\n        int faster = nums[nums[0]];\n        while (faster != slower) &#123;\n            faster = nums[nums[faster]];\n            slower = nums[slower];\n        &#125;\n        //System.out.println(\"slower : \" + slower + \" , \" + nums[slower]);\n        //System.out.println(\"faster : \" + faster + \" , \" + nums[faster]);\n\n        int step1 = 0, step2 = slower;\n        while (step1 != step2) &#123;\n            System.out.println(\"step1 : \" + step1 + \" , \" + nums[step1]);\n            System.out.println(\"step2 : \" + step2 + \" , \" + nums[step2]);\n            step1 = nums[step1];\n            step2 = nums[step2];\n        &#125;\n        return step1;\n    &#125;\n&#125;\n\n思路3代码\npublic class Solution3 &#123;\n    public int findDuplicate(int[] nums) &#123;\n        int left = 1, right = nums.length - 1;\n        while (left &lt; right) &#123;\n            int mid = (right - left) / 2 + left;\n            int count = 0;\n            for (int num : nums) &#123;\n                if (num &lt;= mid) &#123;\n                    count++;\n                &#125;\n            &#125;\n            if (count > mid) &#123;\n                right = mid;\n            &#125; else &#123;\n                left = mid + 1;\n            &#125;\n        &#125;\n        return left;\n    &#125;\n&#125;","categories":["LeetCode"],"tags":["Java","LeetCode","数组","双指针","二分查找","哈希"]},{"title":"LeetCode精选TOP面试题029.两数相除","url":"/archives/55b28d8d.html","content":"题目描述\n给定两个整数，被除数 dividend 和除数 divisor。将两数相除，要求不使用乘法、除法和 mod 运算符。\n返回被除数 dividend 除以除数 divisor 得到的商。除数不为 0。\n整数除法的结果应当截去（truncate）其小数部分。\n被除数和除数均为 32 位有符号整数，其数值范围是 [−2^31,  2^31 − 1]。如果除法结果溢出，则返回 2^31 − 1。example\ninput  : dividend = 10, divisor = 3\noutput : 3\ninput  : dividend = 7, divisor = -3\noutput : -2\ninput  : dividend = -2147483648, divisor = -1\noutput : 2147483646\nnote   : 若无限制，除法后结果为2147483648，越界，需要返回 Integer.MAX_VALUE\n\n\n\n\n\n解题思路思路： 位运算\n\n先做越界判断，若把 dividend 为左右边界值，divisor 为1 or -1的情况都列举出来，会发现只需要判断 dividend = Integer.MIN_VALUE &amp;&amp; divisor = -1 这一种越界需要处理\n提前把结果的符号 sign 摘出来，然后把后续的求商操作当作对两个正数的操作，避免处理负数出现错误\n使用long类型（不使用int，是因为dividend=Integer.MIN_VALUE时摘掉负号会越界）的m和n分别接收去除了符号的 dividend 和 divisor\n使用两层循环，外层循环 比较不断缩小的被除数m和除数n\n定义d初始化为被除数n，定义c初始化为1，d与c会同步翻2倍，以保证d与c的商为n，同时c是每次内层循环的近似解\n内层循环，比较不断缩小的被除数m和n×2^i，其中i是内存循环的次数\n内层的被除数m，是每次减去近似解后的剩余值，可以理解为每次减去一个最大近似解后的残差 error（与内层的m值相等）\n为防止残差 error 还可以包含2倍或更多倍的n（即能够使真实解res继续增大），需要使用循环对 error 继续缩小，直至其值不能 &gt;= 2*n\n若残差 error 还可以包含2倍或更多倍的n，让d和c同时乘2，即翻倍\n当d足够接近每次的 error 时，d / n -&gt; c，此时c就可以看作一个近似解，但不能保证完全相等，会有新的残差 error’\n\n\n把每次得到的近似解c累加求和，最终的和 result 就是真实解\nm（旧残差 error） 减去d，得到新残差 error’，继续用于循环，可以将残差不断缩小，使得c的累加和result逐渐趋近于真实解\n\n\n\n代码（Java）public class Solution &#123;\n    public int divide(int dividend, int divisor) &#123;\n        if (dividend == Integer.MIN_VALUE &amp;&amp; divisor == -1) &#123;\n            return Integer.MAX_VALUE;\n        &#125;\n\n        int sign = 1;\n        if (dividend / divisor &lt; 0) &#123;\n            sign = -1;\n        &#125;\n\n        long m = Math.abs((long) dividend);\n        long n = Math.abs((long) divisor);\n        int res = 0;\n\n        while (m >= n) &#123;\n            // d与c会同步翻2倍，以保证d与c的商为n\n            long d = n, c = 1;\n            // 内层while的m，是每次减去近似解后的剩余值，可以理解为每次减去一个最大近似解后的残差 m'\n            // 为防止残差 m' 还可以包含2倍或更多倍的n（即能够使真实解res继续增大），需要使用循环对 m' 继续缩小，直至其大小不能>=2*n\n            while (m >= (d &lt;&lt; 1)) &#123;\n                d &lt;&lt;= 1;  // d扩大2倍\n                c &lt;&lt;= 1;  // c扩大2倍，与d同步\n                // 当d足够接近每次的剩余m时，d / n -> c，此时c就可以看作一个近似解，但不能保证完全相等，会有误差\n            &#125;\n            // 把每次得到的近似解c累加求和，就是真实解\n            res += c;\n            // m减去d，然后把剩余的m用于循环，可以将误差不断缩小，使得c的累加和res逐渐趋近于真实解\n            m -= d;\n        &#125;\n\n        return sign * res;\n    &#125;\n&#125;\n","categories":["LeetCode"],"tags":["Java","LeetCode","面试","数学","位运算"]},{"title":"LeetCode精选TOP面试题036.有效的数独","url":"/archives/840877d1.html","content":"题目描述\n判断一个 9 x 9 的数独是否有效。一个有效的数独（部分已被填充，空白格用 ‘.’ 表示）不一定是可解的，只需要根据以下规则，验证已经填入的数字是否有效即可。\n(1)数字 1-9 在每一行只能出现一次。\n(2)数字 1-9 在每一列只能出现一次。\n(3)数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。\nboard.length == 9; board[i].length == 9; board[i][j]是数字（1-9）或 ‘.’\n\nexample\ninput  : board =     &#123;&#123;'8', '3', '.', '.', '7', '.', '.', '.', '.'&#125;\n                     ,&#123;'6', '.', '.', '1', '9', '5', '.', '.', '.'&#125;\n                     ,&#123;'.', '9', '8', '.', '.', '.', '.', '6', '.'&#125;\n                     ,&#123;'8', '.', '.', '.', '6', '.', '.', '.', '3'&#125;\n                     ,&#123;'4', '.', '.', '8', '.', '3', '.', '.', '1'&#125;\n                     ,&#123;'7', '.', '.', '.', '2', '.', '.', '.', '6'&#125;\n                     ,&#123;'.', '6', '.', '.', '.', '.', '2', '8', '.'&#125;\n                     ,&#123;'.', '.', '.', '4', '1', '9', '.', '.', '5'&#125;\n                     ,&#123;'.', '.', '.', '.', '8', '.', '.', '7', '9'&#125;&#125;;                                                                                                                               \noutput : true\ninput  : board =     &#123;&#123;'8', '3', '.', '.', '7', '.', '.', '.', '.'&#125;\n                     ,&#123;'6', '.', '.', '1', '9', '5', '.', '.', '.'&#125;\n                     ,&#123;'.', '9', '8', '.', '.', '.', '.', '6', '.'&#125;\n                     ,&#123;'8', '.', '.', '.', '6', '.', '.', '.', '3'&#125;\n                     ,&#123;'4', '.', '.', '8', '.', '3', '.', '.', '1'&#125;\n                     ,&#123;'7', '.', '.', '.', '2', '.', '.', '.', '6'&#125;\n                     ,&#123;'.', '6', '.', '.', '.', '.', '2', '8', '.'&#125;\n                     ,&#123;'.', '.', '.', '4', '1', '9', '.', '.', '5'&#125;\n                     ,&#123;'.', '.', '.', '.', '8', '.', '.', '7', '9'&#125;&#125;;   \noutput : false\n\n\n\n解题思路思路1 暴力\n\n直接按照题目的三个要求，进行不同的有效性判定\n摘出三个函数，分别来满足这三个要求\ncheckRow() 数字 1-9 在每一行只能出现一次。\n按行遍历，哈希表contains()方法判定\n\n\ncheckCol() 数字 1-9 在每一列只能出现一次。\n按列遍历，哈希表contains()方法判定\n\n\ncheckBlock() 数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。\n按下标规律，四重循环，挨个遍历9个面积为3 × 3的中型方格，哈希表contains()方法判定\n\n\n\n思路2 数组模拟HashSet\n\n定义三个数组，分别用于模拟可判断“行”、“列”、“3×3方格”是否存在重复元素的哈希Set：row[][]、col[][]、area[][]\n还是要考虑下标规律，双重循环即可，比思路1写起来简洁\n以 i，j，u，idx 分别表示当前访问元素的 行下标、列下标、元素值、3×3方格标号（从左到右，从上到下，依次编号为 0 ~ 8）\n行模拟，是指判断 row[i][u] 是否为true，若为true，说明第 i 行已经有值为 u 的元素出现过了，所以重复指向了 row[i][u]\n列模拟，是指判断 col[j][u] 是否为true，若为true，说明第 j 列已经有值为 u 的元素出现过了，所以重复指向了 col[j][u]\n3×3方格模拟，是指判断 area[idx][u] 是否为true，若为true，说明第 idx 个方格已经有值为 u 的元素出现过了，所以重复指向了 area[idx][u]\n在上述三个模拟过程中\n若遇到三者存在一个是true，即可判断为无效的数独；\n三者都为false时，把三者都置为true，表明在 第i行、第j列、第idx个3×3方格，已经有值为 u 的元素出现过了\n\n\n\n代码（Java）思路1代码\npublic class Solution1 &#123;\n    public boolean isValidSudoku(char[][] board) &#123;\n        HashSet&lt;Character> hashSet = new HashSet&lt;>();\n        // 数字 1-9 在每一行只能出现一次\n        if (!checkRow(board, hashSet)) &#123;\n            return false;\n        &#125;\n        // 数字 1-9 在每一列只能出现一次\n        if (!checkCol(board, hashSet)) &#123;\n            return false;\n        &#125;\n        System.out.println();\n        // 数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次\n        if (!checkBlock(board, hashSet)) &#123;\n            return false;\n        &#125;\n        return true;\n    &#125;\n\n    private boolean checkRow(char[][] board, HashSet hashSet) &#123;\n        // 数字 1-9 在每一行只能出现一次\n        System.out.println(\"check row.\");\n        for (int i = 0; i &lt; board.length; i++) &#123;\n            for (char item : board[i]) &#123;\n                if (item != '.' &amp;&amp; hashSet.contains(item)) &#123;\n                    return false;\n                &#125;\n                hashSet.add(item);\n            &#125;\n            hashSet.clear();\n        &#125;\n        return true;\n    &#125;\n\n    private boolean checkCol(char[][] board, HashSet hashSet) &#123;\n        // 数字 1-9 在每一列只能出现一次\n        System.out.println(\"check col.\");\n        for (int j = 0; j &lt; board[0].length; j++) &#123;\n            for (int i = 0; i &lt; board.length; i++) &#123;\n                if (board[i][j] != '.' &amp;&amp; hashSet.contains(board[i][j])) &#123;\n                    return false;\n                &#125;\n                hashSet.add(board[i][j]);\n            &#125;\n            hashSet.clear();\n        &#125;\n        return true;\n    &#125;\n\n    private boolean checkBlock(char[][] board, HashSet hashSet) &#123;\n        // 数字 1-9 在每一列只能出现一次\n        System.out.println(\"check block.\");\n        for (int i = 0; i &lt; 9; i += 3) &#123;\n            for (int j = 0; j &lt; 9; j += 3) &#123;\n                for (int k = i; k &lt; i + 3; ++k) &#123;\n                    for (int p = j; p &lt; j + 3; ++p) &#123;\n                        if (board[k][p] != '.' &amp;&amp; hashSet.contains(board[k][p])) &#123;\n                            return false;\n                        &#125;\n                        hashSet.add(board[k][p]);\n                    &#125;\n                &#125;\n                // 遍历完一个区域后清空哈希表\n                hashSet.clear();\n            &#125;\n        &#125;\n        return true;\n    &#125;\n&#125;\n思路2代码\npublic class Solution2 &#123;\n    public boolean isValidSudoku(char[][] board) &#123;\n        // 用数组模拟哈希set\n        boolean[][] row = new boolean[10][10];\n        boolean[][] col = new boolean[10][10];\n        boolean[][] area = new boolean[10][10];\n        for (int i = 0; i &lt; 9; i++) &#123;\n            for (int j = 0; j &lt; 9; j++) &#123;\n                char ch = board[i][j];\n                if (ch == '.') &#123;\n                    continue;\n                &#125;\n                int u = ch - '0';\n                int idx = i / 3 * 3 + j / 3;\n                if (row[i][u] || col[j][u] || area[idx][u])&#123;\n                    return false;\n                &#125;\n                row[i][u] = col[j][u] = area[idx][u] = true;\n            &#125;\n        &#125;\n        return true;\n    &#125;\n&#125;","categories":["LeetCode"],"tags":["Java","LeetCode","数组","哈希表","矩阵"]},{"title":"LeetCode精选TOP面试题227.基本计算器II","url":"/archives/95734ee4.html","content":"题目描述\n给定一个字符串表达式 s ，请你实现一个基本计算器来计算并返回它的值。\n整数除法仅保留整数部分。\n\nexample\ninput  : s = \"3+2*2\"\noutput : 7\ninput  : s = \"3+2*2\"\noutput : 1\ninput  : s = \" 3+5 / 2 \"\noutput : 5\n\n\n\n解题思路思路1：栈\n\n基本规则 ： 乘除优先于加减计算\n\n用变量 sign 记录每个数字之前的运算符，设置默认初值0，给第一个数字设置前缀+号\n\n遍历字符串，每次从当前位置开始往后取出一个连续整数时，根据 符号（sign） 来决定计算方式，借助 栈 保存整数：\n\n加、减号后的数字，直接压入栈中\n乘、除号后的数字，与栈顶元素计算，并将栈顶元素替换为计算后的结果\n\n\n遍历完字符串 s 后，将栈中元素累加，即为该字符串表达式的值\n\n时间复杂度：O(n) \n\n空间复杂度：O(n) \n\n\n思路2：逆波兰式\n\n遇到不同字符的处理逻辑与思路1相同，但是不进行计算\n只不过在遍历过程中增加了将原表达式转为逆波兰式的步骤\n然后使用逆波兰表达式求解的思路，同leetCode 150 \n\n代码（Java）思路1代码\npublic class Solution1 &#123;\n    public int calculate(String s) &#123;\n        Stack&lt;Integer> stack = new Stack();\n        // 个人认为以下两步（Step1、Step2）对s的操作为投机取巧，仅方便处理，会改变原字符串。\n        // 若不改变字符串s，注释 // ⭐ 处 应为 if((!isDigit &amp;&amp; s[i] != ' ' ) || i == length - 1)\n\n        // Step1：去除所有空格\n        // 若不去除所有空格，也可在代码注释 // ⭐ 处将 else 改为 if(!isDigit &amp;&amp; s[i] != ' ' )\n        s = s.replaceAll(\" \", \"\");\n        // Step2：在数组末尾添加一个“+”号方便结束，任意负号都可以\n        // 若不添加末尾符合，也可在代码注释 // ⭐ 处将 else 改为 if(!isDigit || i == length - 1)\n        s = s + \"+\";\n\n        // 用变量 sign 记录每个数字 前面的 运算符，给第一个数字默认设置前缀+号\n        // 以 3 + 2 * 2 为例，实际处理将其当作 + 3 + 2 * 2 ，便于完成循环过程中的数值处理逻辑\n        char sign = '+';\n        // 提前设置preNumber的初始值为0，可以防止字符串第一个字符为 负号（-）时的处理逻辑混乱\n        // 开头遇到负号也可以把-preNumber = 0先压入栈中\n        int preNumber = 0;\n        int length = s.length();\n        for (int i = 0; i &lt; length; ++i) &#123;\n            boolean isDigit = Character.isDigit(s.charAt(i));\n            if (isDigit) &#123;\n                preNumber = preNumber * 10 + s.charAt(i) - '0';\n            &#125; else &#123; // ⭐\n                // 若读到一个运算符A，按照前一个运算符B的格式对A和B之间的数字进行处理，然后压入栈中\n                // 处理完该数字后，更新 sign 为当前遍历的字符。\n                switch (sign) &#123;\n                    // 加号：将数字压入栈；\n                    case '+':\n                        stack.push(preNumber);\n                        break;\n                    // 减号：将数字的相反数压入栈；\n                    case '-':\n                        stack.push(-preNumber);\n                        break;\n                    // 乘号：计算栈顶元素与数字的乘积，并将栈顶元素替换为计算结果。\n                    case '*':\n                        stack.push(stack.pop() * preNumber);\n                        break;\n                    // 除号：计算栈顶元素与数字的商，并将栈顶元素替换为计算结果。\n                    case '/':\n                        stack.push(stack.pop() / preNumber);\n                        break;\n                    default:\n                        break;\n                &#125;\n                sign = s.charAt(i);\n                preNumber = 0;\n            &#125;\n        &#125;\n        int ans = 0;\n        // 栈中元素累加即为该字符串表达式的值\n        while (!stack.isEmpty()) &#123;\n            ans += stack.pop();\n        &#125;\n        return ans;\n    &#125;\n&#125;\n思路2代码\npublic class Solution2 &#123;\n    private int getRank(char c) &#123;\n        if (c == '*' || c == '/') &#123;\n            return 2;\n        &#125;\n        if (c == '+' || c == '-') &#123;\n            return 1;\n        &#125;\n        return 0;\n    &#125;\n\n    public int calculate(String s) &#123;\n        Stack&lt;Character> ops = new Stack&lt;>();\n        // 存储后缀表达式（逆波兰式）\n        List&lt;String> tokenList = new ArrayList&lt;>();\n        s = s.replaceAll(\" \", \"\");\n        int number = 0;\n        for (char ch : s.toCharArray()) &#123;\n            if (ch >= '0' &amp;&amp; ch &lt;= '9') &#123;\n                // 获取操作符之间的完整整数\n                number = number * 10 + (ch - '0');\n            &#125; else &#123;\n                // 遇到操作符时，就可以把该操作符之前的数字作为新元素添加到逆波兰表达式的字符串中\n                tokenList.add(number + \"\");\n                // 数值清空\n                number = 0;\n                // 获取当前操作符op1的优先级\n                int curRank = getRank(ch);\n                // 持续对比op1和操作符栈的栈顶元素op2的优先级\n                while (!ops.isEmpty() &amp;&amp; getRank(ops.peek()) >= curRank) &#123;\n                    // 如果优先级顺序op2>op1，将操作符栈的栈顶元素弹出，做为新元素添加到逆波兰表达式数组中\n                    tokenList.add(String.valueOf(ops.pop()));\n                &#125;\n                // 把当前操作符压入操作符栈中\n                ops.push(ch);\n            &#125;\n        &#125;\n        // 最后一个数字加入到逆波兰序表达式数组中\n        tokenList.add(String.valueOf(number));\n        // 依次弹出操作符栈中的元素，加入到逆波兰序表达式数组中\n        while (!ops.isEmpty()) &#123;\n            tokenList.add(String.valueOf(ops.pop()));\n        &#125;\n\n        // 逆波兰式求解\n        for (String string : tokenList) &#123;\n            System.out.print(string + \" , \");\n        &#125;\n        System.out.println();\n        String[] tokens = new String[tokenList.size()];\n        tokenList.toArray(tokens);\n        return evalRPN(tokens);\n    &#125;\n\n    /**\n     * 对应 leetCode 150. 逆波兰表达式求值\n     */\n    public int evalRPN(String[] tokens) &#123;\n        Stack&lt;Integer> stack = new Stack&lt;>();\n        for (String s : tokens) &#123;\n            if (s.equals(\"+\")) &#123;\n                stack.push(stack.pop() + stack.pop());\n            &#125; else if (s.equals(\"-\")) &#123;\n                int after = stack.pop();\n                int before = stack.pop();\n                stack.push(before - after);\n            &#125; else if (s.equals(\"*\")) &#123;\n                stack.push(stack.pop() * stack.pop());\n            &#125; else if (s.equals(\"/\")) &#123;\n                int after = stack.pop();\n                int before = stack.pop();\n                stack.push(before / after);\n            &#125; else &#123;\n                stack.push(Integer.valueOf(s));\n            &#125;\n        &#125;\n        return stack.pop();\n    &#125;\n&#125;","categories":["LeetCode"],"tags":["Java","LeetCode","字符串","栈"]},{"title":"LeetCode精选TOP面试题150.逆波兰表达式求值","url":"/archives/b7aa63f2.html","content":"题目描述\n根据 逆波兰表示法，求表达式的值。\n有效的算符包括 +、-、*、/ 。每个运算对象可以是整数，也可以是另一个逆波兰表达式。\n整数除法只保留整数部分。\n给定逆波兰表达式总是有效的。即表达式总会得出有效数值且不存在除数为 0 的情况。\n\nexample\ninput  : tokens = &#123;\"2\",\"1\",\"+\",\"3\",\"*\"&#125;\noutput : 9\nnote   : 该算式转化为常见的中缀算术表达式为：((2 + 1) * 3) = 9\ninput  : tokens = &#123;\"4\",\"13\",\"5\",\"/\",\"+\"&#125;\noutput : 6\nnote   : 该算式转化为常见的中缀算术表达式为：(4 + (13 / 5)) = 6\ninput  : tokens = &#123;\"10\",\"6\",\"9\",\"3\",\"+\",\"-11\",\"*\",\"/\",\"*\",\"17\",\"+\",\"5\",\"+\"&#125;\noutput : 22\nnote   : 该算式转化为常见的中缀算术表达式为：((10 * (6 / ((9 + 3) * -11))) + 17) + 5\n\n\n\n解题思路思路：栈\n\n遇到数字之间压入栈中\n遇到运算符 OP，依次取栈顶两个元素Before、After\n然后根据 OP 完成运算，得到结果 R 重新压入栈顶\n需要注意的是减法操作时为 B - A，除法操作时为B / A，顺序不能颠倒\n\n\n结果返回栈顶元素\n好处：不会破坏原字符串数组\n时间复杂度O(n)\n空间复杂度O(n)\n\n代码（Java）代码\npublic class Solution &#123;\n    public int evalRPN(String[] tokens) &#123;\n        Stack&lt;Integer> stack = new Stack&lt;>();\n        for (String s : tokens) &#123;\n            if (s.equals(\"+\")) &#123;\n                stack.push(stack.pop() + stack.pop());\n            &#125; else if (s.equals(\"-\")) &#123;\n                int after = stack.pop();\n                int before = stack.pop();\n                stack.push(before - after);\n            &#125; else if (s.equals(\"*\")) &#123;\n                stack.push(stack.pop() * stack.pop());\n            &#125; else if (s.equals(\"/\")) &#123;\n                int after = stack.pop();\n                int before = stack.pop();\n                stack.push(before / after);\n            &#125; else &#123;\n                stack.push(Integer.valueOf(s));\n            &#125;\n        &#125;\n        return stack.pop();\n    &#125;\n&#125;\n\n/**\n * 美化一下\n */\npublic class Solution &#123;\n    public int evalRPN(String[] tokens) &#123;\n        Stack&lt;Integer> stack = new Stack&lt;>();\n        List&lt;String> ops = Arrays.asList(\"+\", \"-\", \"*\", \"/\");\n        for (String s : tokens) &#123;\n            if (ops.contains(s)) &#123;\n                stack.push(calculate(s, stack.pop(), stack.pop()));\n            &#125; else &#123;\n                stack.push(Integer.valueOf(s));\n            &#125;\n        &#125;\n        return stack.pop();\n    &#125;\n\n    private int calculate(String op, int x, int y) &#123;\n        switch (op)&#123;\n            case \"+\" :\n                return y + x;\n            case \"-\":\n                return y - x;\n            case \"*\" :\n                return y * x;\n            case \"/\":\n                return y / x;\n        &#125;\n        return 0;\n    &#125;\n&#125;\n\n","categories":["LeetCode"],"tags":["Java","LeetCode","字符串","数组","栈"]},{"title":"LeetCode精选TOP面试题015.三数之和","url":"/archives/d4c92f69.html","content":"题目描述\n给定一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？\n找出所有和为 0 且不重复的三元组。\n0 &lt;= nums.length &lt;= 3000\n-105 &lt;= nums[i] &lt;= 105example\ninput  : nums = [-1,0,1,2,-1,-4]\noutput : [[-1,-1,2],[-1,0,1]]\ninput  : nums = []\noutput : []\ninput  : nums = [0]\noutput : []\n\n\n\n\n\n解题思路思路： 排序+双指针\n\n若数组为空，返回空列表\n将数组进行排序\n若数组长度小于3，不满足题意，返回空列表\n遍历数组查找是否存在三数之和为 0 ，外层循环\n若当前元素nums[i] &gt; 0，说明该元素和其后任意两个元素之和肯定不可能为0，则直接返回当前结果列表即可；之所以不使用nums[i] &gt;= 0作为返回条件，是因为存在数组为{0,0,0}的情况也满足题意，若添加了等号为返回条件，则会返回空，不满足题意\n若当前访问元素和其前一个元素值相同，不进行求和判断，防止出现重复的结果\n固定i，令指针left和指针right移动，求和并判断；其中left初始化为i + 1，right初始化为length - 1；开始内层循环\n内层循环以 left &lt; right 为结束条件，若相等，则说明访问到了同一个元素，不满足三数的要求，可作为循环结束的条件\n三数之和为0，将这三个数组成的列表添加进结果列表，且移动左右指针；然后判断左右指针移动后访问的元素值，是否和其移动前的元素值相等，相等则继续移动，防止重复结果\n三数之和 &gt; 0，右指针左移，使下一次求和结果变小，向0趋近\n三数之和 &lt; 0，左指针右移，使下一次求和结果变大，向0趋近\n\n\n\n\n时间复杂度：O(n^2)  排序 O(N logN)，  遍历数组 O(n)，  双指针遍历 O(n)，  总体 O(N logN)+O(n)∗O(n)，O(n^2)\n空间复杂度：O(1)\n\n代码（Java）代码\npublic class Solution &#123;\n    public List&lt;List&lt;Integer>> threeSum(int[] nums) &#123;\n        List&lt;List&lt;Integer>> lists = new ArrayList&lt;>();\n        // 数组为空，返回空列表\n        if (nums == null) &#123;\n            return lists;\n        &#125;\n        // 数组排序\n        Arrays.sort(nums);\n        // 数组长度小于3，不满足题意，返回空列表\n        int length = nums.length;\n        if (nums.length &lt; 3) &#123;\n            return lists;\n        &#125;\n\n        // 遍历数组查找是否存在三数之和为0\n        for (int i = 0; i &lt; length; i++) &#123;\n            // 当前元素大于零，说明该元素和其后任意两个元素之和肯定不可能为0，则直接返回当前结果即可\n            // 之所以不使用nums[i] >= 0作为返回条件，是因为存在数组为&#123;0,0,0&#125;的情况也满足题意，若添加了等号为返回条件，则会返回空，不满足题意\n            if (nums[i] > 0) &#123;\n                return lists;\n            &#125;\n            // 当前访问元素和其前一个元素值相同，不进行求和判断，防止出现重复的结果\n            if (i > 0 &amp;&amp; nums[i] == nums[i - 1]) &#123;\n                continue;\n            &#125;\n            // 固定i，令指针left和指针right移动，求和并判断；其中left初始化为i + 1，right初始化为length - 1\n            int left = i + 1;\n            int right = length - 1;\n            // left 和 right 相等时，访问到了同一个元素，不满足三数的要求，可作为循环结束的条件\n            while (left &lt; right) &#123;\n                int sum = nums[i] + nums[left] + nums[right];\n                if (sum == 0) &#123;\n                    // 三数之和为0\n                    // 将这三个数组成的列表添加进结果列表\n                    List&lt;Integer> tmp = new ArrayList&lt;>();\n                    tmp.add(nums[i]);\n                    tmp.add(nums[left]);\n                    tmp.add(nums[right]);\n                    lists.add(tmp);\n                    // 左右指针移动\n                    left++;\n                    right--;\n                    // 判断左右指针移动后访问的元素值，是否和其移动前的元素值相等，相等则继续移动，防止重复结果\n                    while (left &lt;= right &amp;&amp; nums[left] == nums[left - 1]) &#123;\n                        left++;\n                    &#125;\n                    while (right >= left &amp;&amp; nums[right] == nums[right + 1]) &#123;\n                        right--;\n                    &#125;\n                &#125; else if (sum > 0) &#123;\n                    // 三数之和 > 0，右指针左移，使下一次求和结果变小，向0趋近\n                    right--;\n                &#125; else &#123;\n                    // 三数之和 &lt; 0，左指针右移，使下一次求和结果变大，向0趋近\n                    left++;\n                &#125;\n            &#125;\n        &#125;\n        return lists;\n    &#125;\n&#125;\n","categories":["LeetCode"],"tags":["Java","LeetCode","面试","数组","排序","双指针"]},{"title":"LeetCode精选TOP面试题048.旋转图像.md","url":"/archives/b4688cfb.html","content":"题目描述\n给定一个 n × n 的二维矩阵 matrix 表示一个图像。\n将图像顺时针旋转 90 度。\n必须在 原地 旋转图像，这意味着需要直接修改输入的二维矩阵。\n不能使用另一个矩阵来旋转图像。\n\nexample\ninput  : matrix = &#123;&#123;1,2,3],[4,5,6],[7,8,9&#125;&#125;\noutput : matrix = &#123;&#123;7,4,1],[8,5,2],[9,6,3&#125;&#125;\ninput  : matrix = &#123;&#123;5,1,9,11],[2,4,8,10],[13,3,6,7],[15,14,12,16&#125;&#125;\noutput : matrix = &#123;&#123;15,13,2,5],[14,3,4,1],[12,6,8,9],[16,7,10,11&#125;&#125;\n\n\n\n解题思路思路1 两次翻转\n\n按照n×n数组的翻转规律\n先按照主对角线镜像翻转，再按照水平反转（或者先水平后镜像也可以）\n翻转两次后就是目标数组\n\n思路2 原地旋转\n\n每个数组元素，在该数组中会有另外三个元素与其对应，组成一个圈\n若把所有的四个数字组成的圈，都完成90°旋转，就可以形成整个数组的旋转\n遍历二维数组，按照数组元素排列规律，对同一个圈内的四个元素按照顺时针顺序进行数值覆盖，即完成了一个圈的旋转\n遍历结束后即可完成整个数组的顺时针90°旋转\n\n代码（Java）思路1代码\npublic class Solution1 &#123;\n    public void rotate(int[][] matrix) &#123;\n\n        int length = matrix.length;\n\n        // 查看原数组\n        /*for (int i = 0; i &lt; length; i++) &#123;\n            for (int j = 0; j &lt; length; j++) &#123;\n                System.out.print(matrix[i][j] + \"\\t\");\n            &#125;\n            System.out.println();\n        &#125;\n        System.out.println();*/\n\n        // 主对角线翻转\n        for (int i = 0; i &lt; length; i++) &#123;\n            for (int j = 0; j &lt; i; j++) &#123;\n                int tmp = matrix[i][j];\n                matrix[i][j] = matrix[j][i];\n                matrix[j][i] = tmp;\n            &#125;\n        &#125;\n        \n        // 查看主对角线翻转后的数组\n        /*for (int i = 0; i &lt; length; i++) &#123;\n            for (int j = 0; j &lt; length; j++) &#123;\n                System.out.print(matrix[i][j] + \"\\t\");\n            &#125;\n            System.out.println();\n        &#125;\n        System.out.println();*/\n\n        // 水平翻转\n        for (int i = 0; i &lt; length; i++) &#123;\n            for (int j = 0; j &lt; length / 2; j++) &#123;\n                int tmp = matrix[i][j];\n                matrix[i][j] = matrix[i][length - j - 1];\n                matrix[i][length - j - 1] = tmp;\n            &#125;\n        &#125;\n\n        // 查看结果数组\n        /*for (int i = 0; i &lt; length; i++) &#123;\n            for (int j = 0; j &lt; length; j++) &#123;\n                System.out.print(matrix[i][j] + \"\\t\");\n            &#125;\n            System.out.println();\n        &#125;*/\n    &#125;\n&#125;\n\n思路2代码\npublic class Solution2 &#123;\n    public void rotate(int[][] matrix) &#123;\n        int length = matrix.length;\n        // 查看原数组\n        /*for (int i = 0; i &lt; length; i++) &#123;\n            for (int j = 0; j &lt; length; j++) &#123;\n                System.out.print(matrix[i][j] + \"\\t\");\n            &#125;\n            System.out.println();\n        &#125;\n        System.out.println();*/\n\n        // 转圈赋值\n        for (int i = 0; i &lt; length / 2; i++) &#123;\n            for (int j = 0; j &lt; (length + 1) / 2; j++) &#123;\n                int tmp = matrix[i][j];\n                matrix[i][j] = matrix[length - j - 1][i];\n                matrix[length - j - 1][i] = matrix[length - i - 1][length - j - 1];\n                matrix[length - i - 1][length - j - 1] = matrix[j][length - i - 1];\n                matrix[j][length - i - 1] = tmp;\n            &#125;\n        &#125;\n\n        // 查看结果数组\n        /*for (int i = 0; i &lt; length; i++) &#123;\n            for (int j = 0; j &lt; length; j++) &#123;\n                System.out.print(matrix[i][j] + \"\\t\");\n            &#125;\n            System.out.println();\n        &#125;\n        System.out.println();*/\n    &#125;\n&#125;","categories":["LeetCode"],"tags":["Java","LeetCode","面试","数组"]},{"title":"LeetCode精选TOP面试题075.颜色分类","url":"/archives/31ec5e07.html","content":"题目描述\n给定一个包含红色、白色和蓝色，一共 n 个元素的数组。\n\n原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。\n\n此题中使用整数 0、 1 和 2 分别表示红色、白色和蓝色。\n\n进阶：\n\n可以不使用代码库中的排序函数来解题吗？\n有仅使用常数空间的一趟扫描算法吗？\n\n\n\nexample\ninput  : nums = &#123;2, 0, 2, 1, 1, 0&#125;\noutput : nums = &#123;0, 0, 1, 1, 2, 2&#125;\ninput  : nums = &#123;2, 0, 1&#125;\noutput : nums = &#123;0, 1, 2&#125;\ninput  : nums = &#123;0&#125;\noutput : nums = &#123;0&#125;\n\n\n\n解题思路思路1\n参考自大佬的题解。\n\n“进阶”要求考察的是“快速排序”的子过程 partition，即：通过一次遍历，把数组分成三个部分。\n初始化index = 0，zero = 0，two = nums.length\nindex作为遍历的访问下标，zero作为0元素子集右侧边界，two作为2元素子集左侧边界，\n当访问元素为2时，向后与 two先向左移动一次之后 的位置的元素交换（因为two初始化为nums.length为越界状态，故先使其不越界），i不前进，因为交换来的元素很可能也是2，此时若前进会把交换到i下标位置的2忽略，导致排序失败，故原地等待，继续循环；\n当访问元素为1时，不交换，因为1本来就需要在中间，i不前进，zero和two也移动\n当访问元素为0时，向前与zero位置的元素交换 ，i前进，zero向右移动。\n\n\n时间复杂度：O(N) \n空间复杂度：O(1) \n\n思路2\n\n调用Java中Arrays.sort()方法\n时间复杂度：O(N logN) \n空间复杂度：O(1) \n\n代码（Java）思路1代码\npublic class Solution1 &#123;\n    /* public void sortColors(int[] nums) &#123;\n        int length = nums.length;\n        int zero = 0, two = length - 1;\n        int i = 0;\n        while (i &lt;= two) &#123;\n            if (nums[i] == 0) &#123;\n                nums[i] = nums[zero];\n                nums[zero++] = 0;\n                i++;\n            &#125; else if (nums[i] == 2) &#123;\n                nums[i] = nums[two];\n                nums[two--] = 2;\n            &#125; else &#123;\n                i++;\n            &#125;\n        &#125;\n    &#125; */\n    // 基于上方注释内容，抽出交换数据的方法\n    public void sortColors(int[] nums) &#123;\n        int length = nums.length;\n        // i作为遍历的访问下标，zero作为0元素子集右侧边界，two作为2元素子集左侧边界；\n        int zero = 0, two = length;\n        int i = 0;\n        // 循环终止条件是 i == two，那么循环可以继续的条件是 i &lt; two\n        while (i &lt; two) &#123;\n            if (nums[i] == 0) &#123;\n                // 当访问元素为0时，向前与zero位置的元素交换 ，i前进，zero向右移动。\n                swap(nums, i, zero++);\n                i++;\n            &#125; else if (nums[i] == 2) &#123;\n                // 向后与 two先向左移动一次之后 的位置的元素交换（因为two初始化为nums.length为越界状态，故先使其不越界），i不前进，因为交换来的元素很可能也是2，此时若前进会把交换到i下标位置的2忽略，导致排序失败，故原地等待，继续循环；\n                swap(nums, i, --two);\n            &#125; else &#123;\n                // 当访问元素为1时，不交换，因为1本来就需要在中间，i不前进，zero和two也移动；\n                i++;\n            &#125;\n        &#125;\n    &#125;\n\n    private void swap(int[] nums, int index1, int index2) &#123;\n        int tmp = nums[index1];\n        nums[index1] = nums[index2];\n        nums[index2] = tmp;\n    &#125;\n&#125;\n思路2代码\npublic class Solution2 &#123;\n    public void sortColors(int[] nums) &#123;\n        Arrays.sort(nums);\n    &#125;\n&#125;","categories":["LeetCode"],"tags":["Java","LeetCode","面试","数组","排序"]},{"title":"LeetCode精选TOP面试题056.合并区间","url":"/archives/280d96dc.html","content":"题目描述\n以数组 intervals 表示若干个区间的集合，其中单个区间为 intervals[i] = [starti, endi] 。\n合并所有重叠的区间，并返回一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间。example\ninput  : intervals = &#123;&#123;1, 3&#125;, &#123;2, 6&#125;, &#123;8, 10&#125;, &#123;15, 18&#125;&#125;\noutput : &#123;1, 6&#125;, &#123;8, 10&#125;, &#123;15, 18&#125;\ninput  : intervals = &#123;&#123;1, 4&#125;, &#123;4, 18&#125;&#125;\noutput : &#123;1, 18&#125;\ninput  : intervals = &#123;1, 4&#125;, &#123;0, 4&#125;\noutput : &#123;0, 4&#125;\ninput  : intervals = &#123;1, 4&#125;, &#123;2, 3&#125;\noutput : &#123;1, 4&#125;\n\n解题思路思路1 排序+两层循环遍历\n\n\n借助Arrays.sort()对原数组进行排序\n遍历数组，外层循环\n内层循环，对前一个数组元素[left1, right1]的右区间值right1和后一个数组元素[left2, right2]的左区间值left2作比较，若right1 &gt;= left2，则令left1 = right1和right2中值较大的，继续内层循环\n每次内层循环结束，将最终的[leftx, rightx]作为新元素赋值到结果数组中\n\n\n\n思路2 排序+一层循环遍历\n\n借助Arrays.sort()对原数组进行排序\n遍历数组，记当前遍历到的数组元素为array\n当result数组为空（下标记录为-1），或者当array的左侧区间值大于result数组最后一个元素的右侧区间值，即两个区间无重合时，将array添加进result\n当array的左侧区间值不大于result数组最后一个元素的右侧区间值，即两个区间有重合时，更新result数组最后一个元素的右侧区间值\n\n\n\n代码（Java）代码1\npublic class Solution &#123;\n    public int[][] merge(int[][] intervals) &#123;\n        // 排序\n        Arrays.sort(intervals, new Comparator&lt;int[]>() &#123;\n            public int compare(int[] interval1, int[] interval2) &#123;\n                return interval1[0] - interval2[0];\n            &#125;\n        &#125;);\n\n        int length = intervals.length;\n        int[][] result = new int[length][2];        \n        int count = 0;\n        for (int i = 0, j = 1; i &lt; length &amp;&amp; j &lt;= length; i = j, j = i + 1) &#123;\n            while (j &lt; length &amp;&amp; intervals[i][1] >= intervals[j][0]) &#123;\n                intervals[i][1] = Math.max(intervals[j][1] , intervals[i][1]);\n                j++;\n            &#125;\n            result[count] = intervals[i];\n            // System.out.println(\"current:  i = \" + i + \" , j = \" + j);\n            count++;\n        &#125;\n        // System.out.println(\"count : \" + count);\n        return Arrays.copyOf(result, count);\n    &#125;\n&#125;\n代码2\npublic class Solution2 &#123;\n    public int[][] merge(int[][] intervals) &#123;\n        // 排序\n        Arrays.sort(intervals, new Comparator&lt;int[]>() &#123;\n            public int compare(int[] interval1, int[] interval2) &#123;\n                return interval1[0] - interval2[0];\n            &#125;\n        &#125;);\n\n        int length = intervals.length;\n        int[][] result = new int[length][2];\n        int count = -1;\n        for (int[] array : intervals) &#123;\n            if (count == -1 || array[0] > result[count][1]) &#123;\n                // 记当前遍历到的数组元素为array\n                // 当result数组为空，将array添加进result\n                // 或者\n                // 当array的左侧区间值大于result数组最后一个元素的右侧区间值，即两个区间无重合时，将array添加进result\n                result[++count] = array;\n            &#125;else &#123;\n                // 当array的左侧区间值不大于result数组最后一个元素的右侧区间值，即两个区间有重合时，更新result数组最后一个元素的右侧区间值\n                result[count][1] = Math.max(array[1] , result[count][1]);\n            &#125;\n        &#125;\n        // System.out.println(\"count : \" + (count+1));\n        return Arrays.copyOf(result, count + 1);\n    &#125;\n&#125;","categories":["LeetCode"],"tags":["Java","LeetCode","数组","排序","列表"]},{"title":"LeetCode精选TOP面试题008.字符串转换整数 (atoi)","url":"/archives/8d5596f2.html","content":"题目描述\n实现一个 myAtoi(string s) 函数，使其能将字符串转换成一个 32 位有符号整数（类似 C/C++ 中的 atoi 函数）。\n函数 myAtoi(string s) 的算法如下：\n1、读入字符串并丢弃无用的前导空格\n2、检查下一个字符（假设还未到字符末尾）为正还是负号，读取该字符（如果有）。 确定最终结果是负数还是正数。 如果两者都不存在，则假定结果为正。\n3、读入下一个字符，直到到达下一个非数字字符或到达输入的结尾。字符串的其余部分将被忽略。\n4、将前面步骤读入的这些数字转换为整数（即，”123” -&gt; 123， “0032” -&gt; 32）。如果没有读入数字，则整数为 0 。必要时更改符号（从步骤 2 开始）。\n5、如果整数数超过 32 位有符号整数范围 [−231,  231 − 1] ，需要截断这个整数，使其保持在这个范围内。具体来说，小于 −231 的整数应该被固定为 −231 ，大于 231 − 1 的整数应该被固定为 231 − 1 。\n6、返回整数作为最终结果。\n本题中的空白字符只包括空格字符 ‘ ‘ 。\n除前导空格或数字后的其余字符串外，请勿忽略 任何其他字符。\n0 &lt;= s.length &lt;= 200\ns 由英文字母（大写和小写）、数字（0-9）、’ ‘、’+’、’-‘ 和 ‘.’ 组成\n\nexample\ninput  : s = \"42\"\noutput : 42\nnote   : 加粗的字符串为已经读入的字符，插入符号是当前读取的字符。\n         第 1 步：\"42\"（当前没有读入字符，因为没有前导空格）\n                  ^\n         第 2 步：\"42\"（当前没有读入字符，因为这里不存在 '-' 或者 '+'）\n                  ^\n         第 3 步：\"42\"（读入 \"42\"）\n                    ^\n         解析得到整数 42 。\n         由于 \"42\" 在范围 [-231, 231 - 1] 内，最终结果为 42 。\ninput  : s = \"   -42\"\noutput : -42\nnote   : 第 1 步：\"   -42\"（读入前导空格，但忽视掉）\n                     ^\n         第 2 步：\"   -42\"（读入 '-' 字符，所以结果应该是负数）\n                      ^\n         第 3 步：\"   -42\"（读入 \"42\"）\n                        ^\n         解析得到整数 -42 。\n         由于 \"-42\" 在范围 [-231, 231 - 1] 内，最终结果为 -42 。\ninput  : s = \"4193 with words\"\noutput : 4193\nnote   : 第 1 步：\"4193 with words\"（当前没有读入字符，因为没有前导空格）\n                  ^\n         第 2 步：\"4193 with words\"（当前没有读入字符，因为这里不存在 '-' 或者 '+'）\n                  ^\n         第 3 步：\"4193 with words\"（读入 \"4193\"；由于下一个字符不是一个数字，所以读入停止）\n                      ^\n         解析得到整数 4193 。\n         由于 \"4193\" 在范围 [-231, 231 - 1] 内，最终结果为 4193 。\ninput  : s = \"words and 987\"\noutput : 0\nnote   : 第 1 步：\"words and 987\"（当前没有读入字符，因为没有前导空格）\n                  ^\n         第 2 步：\"words and 987\"（当前没有读入字符，因为这里不存在 '-' 或者 '+'）\n                  ^\n         第 3 步：\"words and 987\"（由于当前字符 'w' 不是一个数字，所以读入停止）\n                  ^\n         解析得到整数 0 ，因为没有读入任何数字。\n         由于 0 在范围 [-231, 231 - 1] 内，最终结果为 0 。\ninput  : s = \"-91283472332\"\noutput : -2147483648\nnote   : 第 1 步：\"-91283472332\"（当前没有读入字符，因为没有前导空格）\n                  ^\n         第 2 步：\"-91283472332\"（读入 '-' 字符，所以结果应该是负数）\n                   ^\n         第 3 步：\"-91283472332\"（读入 \"91283472332\"）\n                              ^\n         解析得到整数 -91283472332 。\n         由于 -91283472332 小于范围 [-231, 231 - 1] 的下界，最终结果被截断为 -231 = -2147483648 。\n\n解题思路思路1 借助Long\n\n1、去空格\n2、获取正负号\n3、借助stringBuilder获取数字字符\n4、删除前缀0\n5、长度判断，过长则截取\n6、判断是否越界\n7、返回结果\n\n思路2 借助字符串\n\n1、去空格\n2、获取正负号\n3、借助stringBuilder获取数字字符\n4、删除前缀0\n5、借助字符串和int类型整数进行数值转换，提前进行越界判断，对界值进行缩小来和当前值比较，而不是放大当前值去和界值比较，因为会越界。\n6、返回结果\n\n代码（Java）思路1代码\npublic class Solution1 &#123;\n    public int myAtoi(String s) &#123;\n        if (s.length() == 0) &#123;\n            return 0;\n        &#125;\n        // 去空格\n        String string = s.trim();\n        if (string.length() == 0) &#123;\n            return 0;\n        &#125;\n        int length = string.length();\n        // 获取正负号\n        int symbol = 1;\n        if (string.charAt(0) == '-') &#123;\n            symbol = -1;\n        &#125;\n\n        int index = 0;\n        if (symbol == -1 || string.charAt(0) == '+') &#123;\n            index = 1;\n        &#125;\n        // 获取数字字符\n        while (index &lt; length &amp;&amp; string.charAt(index) >= '0' &amp;&amp; string.charAt(index) &lt;= '9') &#123;\n            stringBuilder.append(string.charAt(index));\n            index++;\n        &#125;\n        if (stringBuilder.length() == 0) &#123;\n            return 0;\n        &#125;\n        // 删除前缀0\n        int i = 0;\n        while (i &lt; stringBuilder.length() &amp;&amp; stringBuilder.charAt(i++) == '0') ;\n        String input = stringBuilder.toString().substring(i - 1);\n        // 长度判断，过长则截取\n        long number;\n        if (input.length() > 10) &#123;\n            number = Long.parseLong(input.substring(0, 11));\n        &#125; else &#123;\n            number = Long.parseLong(input);\n        &#125;\n        // 判断是否越界\n        if (symbol == 1 &amp;&amp; number > ((int) (Math.pow(2, 31)) - 1)) &#123;\n            return 2147483647;\n        &#125;\n        if (symbol == -1 &amp;&amp; -number &lt; -((int) (Math.pow(2, 31)) + 1)) &#123;\n            return -2147483648;\n        &#125;\n        return (int) (symbol * number);\n    &#125;\n&#125;\n思路2代码\npublic class Solution2 &#123;\n    public int myAtoi(String s) &#123;\n        if (s.length() == 0) &#123;\n            return 0;\n        &#125;\n        // 去空格\n        String string = s.trim();\n        if (string.length() == 0) &#123;\n            return 0;\n        &#125;\n        // 获取正负号\n        int symbol = 1;\n        if (string.charAt(0) == '-') &#123;\n            symbol = -1;\n        &#125;\n\n        int index = 0;\n        if (symbol == -1 || string.charAt(0) == '+') &#123;\n            index = 1;\n        &#125;\n\n        int length = string.length();\n        StringBuilder stringBuilder = new StringBuilder();\n        while (index &lt; length &amp;&amp; string.charAt(index) >= '0' &amp;&amp; string.charAt(index) &lt;= '9') &#123;\n            stringBuilder.append(string.charAt(index));\n            index++;\n        &#125;\n        if (stringBuilder.length() == 0) &#123;\n            return 0;\n        &#125;\n\n        // 去除前导0\n        int i = 0;\n        while (i &lt; stringBuilder.length() &amp;&amp; stringBuilder.charAt(i++) == '0') ;\n        String input = stringBuilder.toString().substring(i - 1);\n\n        // 有效数值转换\n        int number = 0;\n        for (i = 0; i &lt; input.length(); i++) &#123;\n            if (symbol == 1 &amp;&amp; (number > Integer.MAX_VALUE / 10\n                    || (number == Integer.MAX_VALUE / 10 &amp;&amp; (input.charAt(i) - '0') > Integer.MAX_VALUE % 10))) &#123;\n                return Integer.MAX_VALUE;\n            &#125;\n            if (symbol == -1 &amp;&amp; (number > Integer.MIN_VALUE / (-10)\n                    || (number == Integer.MIN_VALUE / (-10) &amp;&amp; (input.charAt(i) - '0') > -(Integer.MIN_VALUE % 10)))) &#123;\n                return Integer.MIN_VALUE;\n            &#125;\n            number = number * 10 + (input.charAt(i) - '0');\n        &#125;\n        return symbol * number;\n    &#125;\n&#125;","categories":["LeetCode"],"tags":["Java","LeetCode","面试","字符串"]},{"title":"LeetCode精选TOP面试题162.寻找峰值","url":"/archives/77c37fe2.html","content":"题目描述\n峰值元素是指其值严格大于左右相邻值的元素。\n给你一个整数数组 nums，找到峰值元素并返回其索引。数组可能包含多个峰值，在这种情况下，返回 任何一个峰值 所在位置即可。\n可以假设 nums[-1] = nums[n] = -∞ 。\n\nexample\ninput  : nums = &#123;1,2,3,1&#125;\noutput : 2\ninput  : nums = &#123;1,2,1,3,5,6,4&#125;\noutput : 1 (或 5， 都对输出一个即可) \n\n\n\n解题思路思路1 顺序遍历\n\n找到第一个大于其后相邻元素值的元素返回下标即可\n若遍历结束没有找到，则直接返回 nums.length - 1，即数组的最后一个元素即是一个峰值，只不过没有右邻元素做比较\n因为元素值各不相等，所以找到第一个大于其后相邻元素值的元素（A）的时候，隐含的信息是A一定大于其前的所有元素\n如果在A之前，有B大于A，不管B是不是A的左邻元素 【 如 ： 1，4（B），2，3（A），0；或者 1，4（B），3（A），0】，B的下标肯定早就因为大于B的值右邻元素值被返回了\n时间复杂度O(n)\n\n思路 二分查找\n\n评论区大佬们把这方法叫做爬坡法\n使用二分查找的方式，比较 nums[middle] 和  nums[middle + 1] 的大小\n若 nums[middle] &gt; nums[middle + 1] 说明坡在左边，right 置为 middle\n若 nums[middle] &lt;= nums[middle + 1] 说明坡在右边，left 置为 middle + 1\n等号在哪侧都可以\n时间复杂度O(log n)\n\n代码（Java）思路1代码\npublic class Solution1 &#123;\n    public int findPeakElement(int[] nums) &#123;\n        if (nums.length == 0) &#123;\n            return -1;\n        &#125;\n        for (int i = 0; i &lt; nums.length - 1; i ++) &#123;\n            if (nums[i] > nums[i + 1]) &#123;\n                return i;\n            &#125;\n        &#125;\n        return nums.length - 1;\n    &#125;\n&#125;\n思路2代码\npublic class Solution2 &#123;\n    public int findPeakElement(int[] nums) &#123;\n        if (nums.length == 0) &#123;\n            return -1;\n        &#125;\n        int left = 0;\n        int right = nums.length - 1;\n        while (left &lt; right) &#123;\n            int middle = (right + left) / 2;\n            // System.out.println(left + \" , \" + middle + \" , \"+ right);\n            if (nums[middle] > nums[middle + 1]) &#123;\n                right = middle;\n            &#125; else if (nums[middle] &lt;= nums[middle + 1]) &#123;\n                left = middle + 1;\n            &#125;\n        &#125;\n        return left;\n    &#125;\n&#125;","categories":["LeetCode"],"tags":["Java","LeetCode","数组","二分查找"]},{"title":"LeetCode精选TOP面试题034.在排序数组中查找元素的第一个和最后一个位置","url":"/archives/f408473a.html","content":"题目描述\n给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。\n如果数组中不存在目标值 target，返回 [-1, -1]。\n可以设计并实现时间复杂度为 O(log n) 的算法解决此问题吗？example\ninput  : nums = &#123;5,7,7,8,8,10&#125;, target = 8\noutput : &#123;3,4&#125;\ninput  : nums = &#123;5,7,7,8,8,10&#125;, target = 6\noutput : &#123;-1,-1&#125;\ninput  : nums = &#123;&#125;, target = 0\noutput : &#123;-1,-1&#125;\n\n解题思路\n\n思路1 二分查找\n\n第一个位置是找nums[i] &gt;= target\n最后一个位置是找nums[i] &gt; target\n时间复杂度O(log n)\n\n思路2 双指针\n\n双向遍历，向中间收缩\n第一个位置找第一个不小于 target 的元素下标\n最后一个位置找第一个不大于 target 的元素下标\n时间复杂度O(n)\n\n代码（Java）思路1代码\npublic class Solution1 &#123;\n    public int[] searchRange(int[] nums, int target) &#123;\n        if (nums.length == 0 || target &lt; nums[0] || target > nums[nums.length - 1]) &#123;\n            return new int[]&#123;-1, -1&#125;;\n        &#125;\n        int left = findIndex(nums, target);\n        int right = findIndex(nums, target + 1) - 1;\n        if (left > right) &#123;\n            return new int[]&#123;-1, -1&#125;;\n        &#125;\n        return new int[]&#123;left, right&#125;;\n    &#125;\n\n    private int findIndex(int[] nums, int target) &#123;\n        int left = 0, right = nums.length - 1;\n        while (left &lt;= right) &#123;\n            // System.out.println(left + \" , \" + right);\n            int mid = (left + right) / 2;\n            if (nums[mid] >= target) &#123;\n                right = mid - 1;\n            &#125; else &#123;\n                left = mid + 1;\n            &#125;\n        &#125;\n        return left;\n    &#125;\n&#125;\n思路2代码\npublic class Solution2 &#123;\n    public int[] searchRange(int[] nums, int target) &#123;\n        int[] result = &#123;-1, -1&#125;;\n        int length = nums.length;\n        if (nums.length == 0 || target &lt; nums[0] || target > nums[length - 1]) &#123;\n            return result;\n        &#125;\n        int left = 0, right = length - 1;\n        while (nums[left] &lt; target) &#123;\n            left++;\n        &#125;\n        if (nums[left] == target) &#123;\n            result[0] = left;\n        &#125;\n\n        while (nums[right] > target) &#123;\n            right--;\n        &#125;\n        if (nums[right] == target) &#123;\n            result[1] = right;\n        &#125;\n        // 执行到此处，若left为-1，说明数组中没有target元素，则right一定为-1，不需要额外的判断了。\n        return result;\n    &#125;\n&#125;","categories":["LeetCode"],"tags":["Java","LeetCode"]},{"title":"LeetCode精选TOP面试题033.搜索旋转排序数组","url":"/archives/7fd81635.html","content":"题目描述整数数组 nums 按升序排列，数组中的值 互不相同 。在传递给函数之前，nums 在预先未知的某个下标 k（0 &lt;= k &lt; nums.length）上进行了 旋转，使数组变为 [nums[k], nums[k+1], …, nums[n-1], nums[0], nums[1], …, nums[k-1]]（下标 从 0 开始 计数）。例如， [0,1,2,4,5,6,7] 在下标 3 处经旋转后可能变为 [4,5,6,7,0,1,2] 。\n给定 旋转后 的数组 nums 和一个整数 target ，如果 nums 中存在这个目标值 target ，则返回它的下标，否则返回 -1 。\nexample\ninput  : nums = &#123;4,5,6,7,0,1,2&#125;, target = 0\noutput : 4\ninput  : nums = &#123;4,5,6,7,0,1,2&#125;, target = 3\noutput : -1\ninput  : nums = &#123;3,1&#125;, target = 1\noutput : 1\ninput  : nums = &#123;1&#125;, target = 0\noutput : -1\n\n解题思路思路 二分查找\n\n先找到数组旋转后的分界线，即前后两个有序数组的分界线\n根据 target 的大小，决定在左侧有序数组还是右侧有序数组进行二分查找\n执行二分查找确定目标位置\n\n代码（Java）代码\npublic class Solution &#123;\n    public int search(int[] nums, int target) &#123;\n        int div = 0;\n        for (int i = 0; i &lt; nums.length - 1; i++) &#123;\n            if (nums[i] > nums[i + 1]) &#123;\n                div = i;\n                break;\n            &#125;\n        &#125;\n        // System.out.println(div);\n        // 二分查找\n        int left, right;\n        int length = nums.length;\n        if (nums[div] >= target &amp;&amp; nums[0] &lt;= target) &#123;\n            left = 0;\n            right = div;\n        &#125; else if (nums[length - 1] >= target) &#123;\n            left = div + 1;\n            right = length - 1;\n        &#125; else &#123;\n            return -1;\n        &#125;\n        // System.out.println(left + \",\" + right);\n        while (left &lt;= right) &#123;\n            // 防止溢出，通常可写作 middle = (right + left) / 2\n            int middle = (right - left) / 2 + left;\n            if (target == nums[middle] &amp;&amp; left &lt;= right) &#123;\n                return middle;\n            &#125;\n            if (target > nums[middle] &amp;&amp; left &lt;= right) &#123;\n                left = middle + 1;\n            &#125; else if (target &lt; nums[middle] &amp;&amp; left &lt;= right) &#123;\n                right = middle - 1;\n            &#125;\n        &#125;\n        return -1;\n    &#125;\n&#125;\n","categories":["LeetCode"],"tags":["Java","LeetCode","面试","数组","二分查找"]},{"title":"LeetCode精选TOP面试题94.二叉树的中序遍历","url":"/archives/c1da328e.html","content":"题目描述给定一个二叉树的根节点 root ，返回它的 中序 遍历。\nexample\ninput  : root = [1,null,2,3]\noutput : [1,3,2]\ninput  : root = []\noutput : []\ninput  : root = [1]\noutput : [1]\n\n解题思路思路1 递归典型的递归遍历树结构。\n思路2 迭代通过栈模拟递归的实现过程。递归的时候隐式地维护了一个栈，而我们在迭代的时候需要显式地将这个栈模拟出来。\n代码（Java）思路1代码\npublic class Solution1 &#123;\n\n    public List&lt;Integer> inorderTraversal(TreeNode root) &#123;\n        List&lt;Integer> list = new ArrayList&lt;>();\n        middleReader(root, list);\n        return list;\n    &#125;\n\n    private void middleReader(TreeNode root, List&lt;Integer> list) &#123;\n        if (root == null) &#123;\n            return;\n        &#125;\n        middleReader(root.left, list);\n        list.add(root.val);\n        middleReader(root.right, list);\n    &#125;\n&#125;\n思路2代码\npublic class Solution2 &#123;\n\n    public List&lt;Integer> inorderTraversal(TreeNode root) &#123;\n        List&lt;Integer> list = new ArrayList&lt;>();\n        Stack&lt;TreeNode> stack = new Stack&lt;>();\n\n        while (root != null || !stack.empty()) &#123;\n            while (root != null) &#123;\n                stack.push(root);\n                root = root.left;\n            &#125;\n            root = stack.pop();\n            list.add(root.val);\n            root = root.right;\n        &#125;\n        return list;\n    &#125;\n&#125;","categories":["LeetCode"],"tags":["Java","LeetCode","面试","遍历","列表","树"]},{"title":"LeetCode精选TOP面试题125.验证回文串","url":"/archives/2dfc3976.html","content":"题目描述\n给定一个字符串，验证它是否是回文串，只考虑字母和数字字符，可以忽略字母的大小写。\n将空字符串定义为有效的回文串。\n1 &lt;= s.length &lt;= 2 * 10^5\n字符串 s 由 ASCII 字符组成example\ninput  : \"A man, a plan, a canal: Pana\noutput : true\ninput  : \"race a car\"\noutput : false\ninput  : \"0p\"\noutput : false\n\n解题思路\n首先对字符串进行大小写转换，全部转成小写toLowerCase（也可以是大写toUpperCase），然后使用trim去掉空格，得到string。\n\n\n\n思路1 for 循环从0到string.length/2循环，比较下标 i 和对应下标 string.length - 1 - i 处元素是否相同。若否则直接return false，是则继续循环。思路2 while 循环 原理同1设置left = 0， right = string.length - 1, left 不断向右加1，right 不断向左减1，比较对应元素是否相同。若否则返回false，是则继续循环。思路3 借助Java中字符串的reserve()方法创建一个新的字符串 newString 为 string的反转串，此处借助reserve()方法。直接返回newString.equals(string)的判断结果。\n代码（Java）思路1代码\npublic class Solution1 &#123;\n    public boolean isPalindrome(String s) &#123;\n        s = s.toLowerCase().trim();\n        StringBuilder stringBuilder = new StringBuilder();\n        for (int i = 0; i &lt; s.length(); i++) &#123;\n            char ch = s.charAt(i);\n            if (ch >= 'a' &amp;&amp; ch &lt;= 'z') &#123;\n                stringBuilder.append(ch);\n            &#125; else if (ch >= '0' &amp;&amp; ch &lt;= '9') &#123;\n                stringBuilder.append(ch);\n            &#125;\n        &#125;\n        int length = stringBuilder.length();\n        for (int i = 0; i &lt; length / 2; i++) &#123;\n            if (stringBuilder.charAt(i) != stringBuilder.charAt(length - 1 - i)) &#123;\n                return false;\n            &#125;\n        &#125;\n        return true;\n    &#125;\n&#125;\n思路2代码\npublic class Solution3 &#123;\n    public boolean isPalindrome(String s) &#123;\n        String str = s;\n        str = str.toLowerCase().trim();\n        StringBuilder stringBuilder = new StringBuilder();\n        for (int i = 0; i &lt; str.length(); i++) &#123;\n            char ch = str.charAt(i);\n            if (ch >= 'a' &amp;&amp; ch &lt;= 'z') &#123;\n                stringBuilder.append(ch);\n            &#125; else if (ch >= '0' &amp;&amp; ch &lt;= '9') &#123;\n                stringBuilder.append(ch);\n            &#125;\n        &#125;\n        int left = 0;\n        int right = stringBuilder.length() - 1;\n        while (left &lt; right) &#123;\n            if (stringBuilder.charAt(left++) != stringBuilder.charAt(right--)) &#123;\n                return false;\n            &#125;\n        &#125;\n\n        return true;\n    &#125;\n&#125;\n思路3代码\npublic class Solution2 &#123;\n    public boolean isPalindrome(String s) &#123;\n        s = s.toLowerCase().trim();\n        StringBuilder stringBuilder = new StringBuilder();\n        for (int i = 0; i &lt; s.length(); i++) &#123;\n            char ch = s.charAt(i);\n            if (ch >= 'a' &amp;&amp; ch &lt;= 'z') &#123;\n                stringBuilder.append(ch);\n            &#125; else if (ch >= '0' &amp;&amp; ch &lt;= '9') &#123;\n                stringBuilder.append(ch);\n            &#125;\n        &#125;\n        StringBuilder reserve = new StringBuilder(stringBuilder).reverse();\n        return reserve.toString().equals(stringBuilder.toString());\n    &#125;\n&#125;","categories":["LeetCode"],"tags":["Java","LeetCode","字符串"]},{"title":"LeetCode精选TOP面试题88.合并两个有序数组","url":"/archives/54dae455.html","content":"题目描述\n给定两个 非递减顺序 排列的整数数组 nums1 和 nums2，另有两个整数m和n，分别表示nums1和nums2中的元素数目。\n合并nums2到nums1中，使合并后的数组同样按 非递减顺序 排列。最终合并后数组不应由函数返回，而是存储在数组 nums1 中。\n为了应对这种情况，nums1 的初始长度为 m + n，其中前 m 个元素表示应合并的元素，后 n 个元素为 0 ，应忽略。nums2 的长度为 n 。\nnums1.length == m + n; \nnums2.length == n\n0 &lt;= m, n &lt;= 200\n1 &lt;= m + n &lt;= 200\n-109 &lt;= nums1[i], nums2[j] &lt;= 109\n\nexample\ninput  : nums1 = &#123;1,2,3,0,0,0&#125;, m = 3, nums2 = &#123;2,5,6&#125;, n = 3\noutput : &#123;1,2,2,3,5,6&#125;\ninput  : nums1 = &#123;1&#125;, m = 1, nums2 = &#123;&#125;, n = 0\noutput : &#123;1&#125;\ninput  : nums1 = &#123;0&#125;, m = 0, nums2 = &#123;2&#125;, n = 1\noutput : &#123;2&#125;\n\n解题思路关键点：两个数组都是有序数组思路1 逆序双指针\n\n因为nums1的后几位是与nums2等长的0元素，所以逆序用双指针分别指向两个数组末尾，找到最大元素，将其值赋给nums1尾部，依次循环向前\n当某个指针遍历结束时停止第一轮遍历，此时肯定有一个数组已经被完全纳入到nums1尾部\n且此时并不会对nums1和nums2这两个数组的未排序元素造成影响\n之后，若nums1未被全部遍历，则不需要继续处理，因为此时数组必定已经有序；若nums2未被全部遍历，则需继续逆序遍历nums2，将其元素值依次赋值到nums1中\n\n思路2 合并数组后排序\n代码（Java）思路1代码\npublic class Solution1 &#123;\n    public void merge(int[] nums1, int m, int[] nums2, int n) &#123;\n        if (n == 0) &#123;\n            return;\n        &#125;\n        int length = m + n;\n        int i = m - 1, j = n - 1;\n        while (i >= 0 &amp;&amp; j >= 0) &#123;\n            nums1[--length] = nums1[i] > nums2[j] ? nums1[i--] : nums2[j--];\n        &#125;\n        while (i >= 0) &#123;\n            nums1[--length] = nums1[i--];\n        &#125;\n        while (j >= 0) &#123;\n            nums1[--length] = nums2[j--];\n        &#125;\n    &#125;\n&#125;\n思路2代码\npublic class Solution2 &#123;\n    public void merge(int[] nums1, int m, int[] nums2, int n) &#123;\n        if (n == 0) &#123;\n            return;\n        &#125;\n        for (int i = 0; i &lt; n; i++) &#123;\n            nums1[i + m] = nums2[i];\n        &#125;\n        Arrays.sort(nums1);\n    &#125;\n&#125;","categories":["LeetCode"],"tags":["Java","LeetCode","面试","数组","排序"]},{"title":"LeetCode精选TOP面试题20.有效的括号","url":"/archives/8d1aee98.html","content":"题目描述\n给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串 s ，判断字符串是否有效。\n有效字符串需满足：\n①左括号必须用相同类型的右括号闭合。\n②左括号必须以正确的顺序闭合。example\ninput  : s = \"()\"\noutput : true\ninput  : s = \"()[]&#123;&#125;\"\noutput : true\ninput  : s = \"([)]\"\noutput : false\ninput  : s = \"(]\"\noutput : false\n\n解题思路借助栈\n遍历字符串数组\n遇到左括号直接入栈\n遇到右括号\n若栈为空：直接返回false\n若栈不为空：获取栈顶元素是否为与其配对的左括号\n若匹配则栈顶元素出栈，继续循环\n若不匹配则返回false代码（Java）public class Solution &#123;\n    public boolean isValid(String s) &#123;\n        Stack&lt;Character> stack = new Stack();\n        for (int i = 0; i &lt; s.length(); i++) &#123;\n            if (s.charAt(i) == '(' || s.charAt(i) == '[' || s.charAt(i) == '&#123;') &#123;\n                stack.push(s.charAt(i));\n            &#125;\n            if (s.charAt(i) == ')') &#123;\n                if (stack.empty() || stack.peek() != '(') &#123;\n                    return false;\n                &#125; else &#123;\n                    stack.pop();\n                &#125;\n            &#125; else if (s.charAt(i) == ']') &#123;\n                if (stack.empty() || stack.peek() != '[') &#123;\n                    return false;\n                &#125; else &#123;\n                    stack.pop();\n                &#125;\n            &#125; else if (s.charAt(i) == '&#125;') &#123;\n                if (stack.empty() || stack.peek() != '&#123;') &#123;\n                    return false;\n                &#125; else &#123;\n                    stack.pop();\n                &#125;\n            &#125;\n        &#125;\n        if (!stack.empty()) &#123;\n            return false;\n        &#125;\n        return true;\n    &#125;\n&#125;\n\n\n\n\n\n\n\n\n\n","categories":["LeetCode"],"tags":["Java","LeetCode","面试","字符串","字符匹配"]},{"title":"LeetCode精选TOP面试题69.Sqrt(x)","url":"/archives/198edf56.html","content":"题目描述给定一个非负整数 x ，计算并返回 x 的 算术平方根 。由于返回类型是整数，结果只保留 整数部分 ，小数部分将被舍去 。不允许使用任何内置指数函数和算符，例如 pow(x, 0.5) 或者 x ** 0.5 。\nexample\ninput  : x = 4\noutput : 2\ninput  : x = 8\noutput : 2\nnote   : 8 的算术平方根是 2.82842..., 由于返回类型是整数，小数部分将被舍去。\ninput  : x = 2147483647\noutput : 46340\nnote   : 可能会存在溢出情况的计算边界，需要注意\n\n解题思路思路1 直接比较\n\n从1遍历到x的一半，遍历过程中不断比较，效率较低\n时间复杂度O(n)\n空间复杂度O(1)\n\n思路2 二分查找使用二分查找并做比较，效率比思路1高\n\n时间复杂度O(log n)\n空间复杂度O(1)\n\n思路3 牛顿迭代法递归使用牛顿迭代法，该方法为二次收敛，效率比思路2略高\n\n时间复杂度O(log n)\n空间复杂度O(1)代码（Java）\n\n思路1代码\npublic class Solution1 &#123;\n    public int mySqrt(int x) &#123;\n        long y = x;\n        long result = 0;\n        int middle = x / 2 + 1;\n        for (result = 1; result &lt;= middle; result++) &#123;\n            long compare = result * result;\n            if (compare > y) &#123;\n                return (int)result - 1;\n            &#125; else if (compare == y) &#123;\n                return (int)result;\n            &#125;\n        &#125;\n        return (int)result;\n    &#125;\n&#125;\n思路2代码\npublic class Solution2 &#123;\n    public int mySqrt(int x) &#123;\n        int result = 0;\n        int left = 0;\n        int right = x;\n        while (left &lt;= right) &#123;\n            int middle = left + (right - left) / 2;\n            if ((long) middle * middle &lt;= x) &#123;\n                left = middle + 1;\n                result = middle;\n            &#125; else &#123;\n                right = middle - 1;\n            &#125;\n        &#125;\n        return result;\n    &#125;\n&#125;\npublic class Solution3 &#123;\n    public int mySqrt(int x) &#123;\n        int c = x;\n        if (x == 0) return 0;\n        return (int) sqrt(x, c);\n    &#125;\n\n    public double sqrt(double x, int c) &#123;\n        double result = (x + c / x) / 2;\n        if (result == x) &#123;\n            return result;\n        &#125; else &#123;\n            return sqrt(result, c);\n        &#125;\n    &#125;\n&#125;","categories":["LeetCode"],"tags":["Java","数值计算","LeetCode","面试","二分查找","迭代"]},{"title":"LeetCode精选TOP面试题66.加一","url":"/archives/74bdedc7.html","content":"题目描述给定一个由 整数 组成的 非空 数组所表示的非负整数，在该数的基础上加一。最高位数字存放在数组的首位， 数组中每个元素只存储单个数字。假设除了整数 0 之外，这个整数不会以零开头\nexample\ninput  : &#123;0&#125;\noutput : &#123;1&#125;\ninput  : &#123;1,9&#125;\noutput : &#123;2,0&#125;\ninput  : &#123;9,9,9&#125;\noutput : &#123;1,0,0,0&#125;\n\n解题思路思路1 借助大数BigDecimal\n\n先将数组转换为StringBuilder sb\n再借助sb生成大数bd，使用大数的运算规则做加一\n将大数bd转换为字符串s，再将s转换为数组\n时间复杂度O(n)\n空间复杂度O(n)\n\n思路2 逆序遍历做加法\n\n按照最基本的想法，做逆向遍历，做加法\n若最后一位加1后等于10则置0并进位，进入循环计算，直至某次计算不需要进位，或者进位到数组开头（此时需要扩展数组长度都+1，并将首位置1，后续全为0）\n若最后一位加1后不为10则直接为其赋新值并返回数组\n时间复杂度O(n)\n空间复杂度O(n)\n\n思路3 逆向遍历找最长的后缀“9……9”串\n\n逆向遍历，找最长的连续“999……9”串string，直至找到第一个不为9的数值（记录位置index），或者全部为9逆向遍历到数组开头\n若string的长度不等于数组长度，则使index位置的数值加1，并置其后续所有数组元素为0\n若string的长度等于数组长度，则扩展数组长度+1，置首位为1，后续全为0\n时间复杂度O(n)\n空间复杂度O(n)代码（Java）\n\n思路1代码\npublic class Solution1 &#123;\n    public int[] plusOne(int[] digits) &#123;\n        StringBuilder stringBuilder = new StringBuilder();\n        for (int i = 0; i &lt; digits.length; i++) &#123;\n            stringBuilder.append(digits[i]);\n        &#125;\n        BigDecimal bigDecimal = new BigDecimal(stringBuilder.toString());\n        bigDecimal = bigDecimal.add(new BigDecimal(1));\n        System.out.println(\"big decimal:\" + bigDecimal);\n        String string = bigDecimal.toString();\n        int[] result = new int[string.length()];\n        for (int i = 0; i &lt; string.length(); i++) &#123;\n            result[i] = string.charAt(i) - '0';\n        &#125;\n        return result;\n    &#125;\n&#125;\n思路2代码\npublic class Solution2 &#123;\n    public int[] plusOne(int[] digits) &#123;\n        StringBuilder stringBuilder = new StringBuilder();\n        for (int i = 0; i &lt; digits.length; i ++) &#123;\n            stringBuilder.append(digits[i]);\n        &#125;\n        int add = stringBuilder.charAt(stringBuilder.length() - 1) - '0' + 1;\n        if (add != 10) &#123;\n            stringBuilder.setCharAt(stringBuilder.length() - 1,String.valueOf(add).charAt(0));\n        &#125; else &#123;\n            if (stringBuilder.length() == 1) &#123;\n                int[] result = &#123;1,0&#125;;\n                return result;\n            &#125; else if (stringBuilder.length() >= 1)&#123;\n                stringBuilder.setCharAt(stringBuilder.length() - 1,'0');\n                for (int j = stringBuilder.length() - 2; j >= 0; j --) &#123;\n                    add = stringBuilder.charAt(j) - '0' + 1;\n                    if (add == 10) &#123;\n                        stringBuilder.setCharAt(j, '0');\n                        continue;\n                    &#125; else &#123;\n                        stringBuilder.setCharAt(j, String.valueOf(add).charAt(0));\n                        break;\n                    &#125;\n                &#125;\n            &#125;\n        &#125;\n        if(add == 10)&#123;\n            int[] result = new int[stringBuilder.length() + 1];\n            result[0] = 1;\n            for (int k = 1; k &lt; result.length; k ++) &#123;\n                result[k] = stringBuilder.charAt(k - 1) - '0';\n                System.out.print(result[k]);\n            &#125;\n            return result;\n        &#125; else &#123;\n            int[] result = new int[stringBuilder.length()];\n            for (int k = 0; k &lt; result.length; k ++) &#123;\n                result[k] = stringBuilder.charAt(k) - '0';\n                System.out.print(result[k]);\n            &#125;\n            return result;\n        &#125;\n    &#125;\n&#125;\n思路3代码\npublic class Solution3 &#123;\n    public int[] plusOne(int[] digits) &#123;\n        int length = digits.length;\n        int last = length - 1;\n        while (last >= 0 &amp;&amp; digits[last] == 9) &#123;\n            last--;\n        &#125;\n        if (last + 1 != length) &#123;\n            if (last == -1) &#123;\n                int[] result = new int[digits.length + 1];\n                result[0] = 1;\n                return result;\n            &#125; else if (last != -1) &#123;\n                digits[last]++;\n                for (int i = last + 1; i &lt; length; i++) &#123;\n                    digits[i] = 0;\n                &#125;\n                return digits;\n            &#125;\n        &#125; else if (last + 1 == length) &#123;\n            digits[length - 1]++;\n            return digits;\n        &#125;\n        return digits;\n    &#125;\n&#125;","categories":["LeetCode"],"tags":["Java","数值计算","LeetCode","面试","数组"]},{"title":"LeetCode精选面试题326.3的幂","url":"/archives/fb6a9bed.html","content":"题目描述给定一个整数，写一个函数来判断它是否是 3 的幂次方。若是，返回 true ；否则，返回 false 。\nexample\ninput  : n = 0\noutput : false\ninput  : n = 9\noutput : true\ninput  : n = 45\noutput : false\n\n解题思路思路1从n往1做除法思路2从1往n做乘法\n代码（Java）思路1代码\npublic class Solution &#123;\n    public boolean isPowerOfThree(int n) &#123;\n        while (n != 0 &amp;&amp; n % 3 == 0) &#123;\n            n /= 3;\n        &#125;\n        return n == 1;\n    &#125;\n&#125;\n思路2代码\npublic class Solution &#123;\n    public boolean isPowerOfThree(int n) &#123;\n        if (n % 3 != 0) &#123;\n            // 防止超时，先做一次判断，把不能整除3的都筛除，对3取余是0的数值包含了3的幂次方\n            return false;\n        &#125;\n        int i = 1;\n        while (i &lt; n) &#123;\n            i *= 3;\n        &#125;\n        return n == i;\n    &#125;\n&#125;","categories":["LeetCode"],"tags":["Java","数值计算","LeetCode"]},{"title":"LeetCode精选TOP面试题234.回文链表","url":"/archives/f4a8c7a0.html","content":"题目描述给定一个单链表的头节点 head ，判断该链表是否为回文链表。若是，返回 true ；否则，返回 false 。\nexample\ninput  : head = 1->2->2->1\noutput : true\ninput  : head = 1->2\noutput : false \n\n解题思路思路1\n\n头插法改变后半部分链表\n时间复杂度O(n)\n空间复杂度O(n)\n\n思路2\n\n头插法改变前半部分链表\n时间复杂度O(n)\n空间复杂度O(n)\n\n思路3\n\n借助栈，不改变链表结构，只对比节点数值。\n时间复杂度O(n)\n空间复杂度O(n)代码（Java）\n\n思路1代码\npublic class Solution1 &#123;\n    public boolean isPalindrome(ListNode head) &#123;\n        // 改变后半部分节点，头插法\n        int length = 0;\n        ListNode p = head;\n        while (p != null) &#123;\n            length++;\n            p = p.next;\n        &#125;\n        p = head;\n        for (int i = 0; i &lt; length / 2; i++) &#123;\n            p = p.next;\n        &#125;\n        if (length % 2 != 0) &#123;\n            p = p.next;\n        &#125;\n        ListNode q = p;\n        ListNode newHead = new ListNode(0);\n        newHead.next = null;\n        for (int i = 0; i &lt; length / 2 &amp;&amp; p != null; i++) &#123;\n            p = p.next;\n            q.next = newHead;\n            newHead = q;\n            q = p;\n        &#125;\n        for (int j = 0; j &lt; length / 2; j++) &#123;\n            if (newHead.val != head.val) &#123;\n                return false;\n            &#125;\n            head = head.next;\n            newHead = newHead.next;\n        &#125;\n        return true;\n    &#125;\n&#125;\n思路2代码\npublic class Solution2 &#123;\n    public boolean isPalindrome(ListNode head) &#123;\n        // 改变前半部分节点，头插法\n        int length = 0;\n        ListNode p = head;\n        while (p != null) &#123;\n            length++;\n            p = p.next;\n        &#125;\n        p = head;\n        for (int i = 0; i &lt; length / 2; i++) &#123;\n            p = p.next;\n        &#125;\n\n        ListNode newList = new ListNode(0);\n        newList.next = null;\n        p = head;\n        ListNode q = p;\n\n        for (int i = 0; i &lt; length / 2; i++) &#123;\n            p = p.next;\n            q.next = newList.next;\n            newList.next = q;\n            q = p;\n        &#125;\n        if (length % 2 != 0) &#123;\n            p = p.next;\n        &#125;\n\n        q = newList.next;\n        for (int j = 0; j &lt; length / 2; j++) &#123;\n            if (q.val != p.val) &#123;\n                return false;\n            &#125;\n            p = p.next;\n            q = q.next;\n        &#125;\n        return true;\n    &#125;\n&#125;\n思路2代码\nimport java.util.Stack;\n\npublic class Solution3 &#123;\n    public boolean isPalindrome(ListNode head) &#123;\n        int length = 0;\n        ListNode p = head;\n        while (p != null) &#123;\n            length++;\n            p = p.next;\n        &#125;\n        Stack&lt;Integer> stack = new Stack&lt;>();\n\n        p = head;\n        for (int i = 0; i &lt; length / 2; i++) &#123;\n            stack.push(p.val);\n            p = p.next;\n        &#125;\n\n        if (length % 2 != 0) &#123;\n            p = p.next;\n        &#125;\n        for (int i = 0; i &lt; length / 2 &amp;&amp; p != null; i++) &#123;\n            if (stack.pop() != p.val) &#123;\n                return false;\n            &#125;\n            p = p.next;\n        &#125;\n        return true;\n    &#125;\n&#125;\n链表类定义\npublic class ListNode &#123;\n    int val;\n    ListNode next;\n\n    ListNode() &#123;\n    &#125;\n\n    ListNode(int val) &#123;\n        this.val = val;\n    &#125;\n\n    ListNode(int val, ListNode next) &#123;\n        this.val = val;\n        this.next = next;\n    &#125;\n&#125;\n** Main函数 **\npublic class Main &#123;\n    public static void main(String[] args) &#123;\n        ListNode head = new ListNode(0);\n        head.next = new ListNode(1);\n        head.next.next = new ListNode(2);\n        head.next.next.next = new ListNode(3);\n        head.next.next.next.next = new ListNode(2);\n        head.next.next.next.next.next = new ListNode(1);\n        ListNode p = head;\n\n        p = head.next;\n        while (p.next != null) &#123;\n            System.out.print(p.val + \"->\");\n            p = p.next;\n        &#125;\n        System.out.println(p.val);\n        System.out.println(\"solution3 and solution2 will not change the structure of list, solution1 will change it.\\n\");\n        System.out.println(\"==solution3=============\");\n        Solution3 solution3 = new Solution3();\n        boolean result3 = solution3.isPalindrome(head.next);\n        System.out.println(\"result3 : \" + result3);\n        System.out.println(\"==after solution3=======\");\n        p = head.next;\n        while (p.next != null) &#123;\n            System.out.print(p.val + \"->\");\n            p = p.next;\n        &#125;\n        System.out.println(p.val);\n        /**\n         * solution 2 和 solution 3 不能同时调用\n         * 因为使用其中一个后会改变链表结构。\n         */\n        System.out.println(\"\\n==solution2=============\");\n        Solution2 solution2 = new Solution2();\n        boolean result2 = solution2.isPalindrome(head.next);\n        System.out.println(\"result2 : \" + result2);\n        System.out.println(\"==after solution2=======\");\n        p = head.next;\n        while (p.next != null) &#123;\n            System.out.print(p.val + \"->\");\n            p = p.next;\n        &#125;\n        System.out.println(p.val);\n\n        System.out.println(\"\\n==solution1=============\");\n        Solution1 solution1 = new Solution1();\n        boolean result1 = solution1.isPalindrome(head.next);\n        System.out.println(\"result1 : \" + result1);\n        System.out.println(\"==after solution1=======\");\n        p = head.next;\n        while (p.next != null) &#123;\n            System.out.print(p.val + \"->\");\n            p = p.next;\n        &#125;\n        System.out.println(p.val);\n    &#125;\n&#125;\n","categories":["LeetCode"],"tags":["Java","LeetCode","链表"]},{"title":"LeetCode精选面试题14.最长公共前缀","url":"/archives/dc9490b9.html","content":"题目描述编写一个函数来查找字符串数组中的最长公共前缀。如果不存在公共前缀，返回空字符串 “”。\nexample\ninput  : str1 = &#123;\"flower\",\"flow\",\"flight\"&#125;\noutput : \"fl\"\ninput  : str2 = &#123;\"dog\",\"race\",\"car\"&#125;\noutput : \"\"\n\n解题思路思路1\n\n纵向扫描，直接遍历对比。从前向后遍历所有字符串的每一列，比较相同列上的字符是否相同。如果相同则继续对下一列进行比较，如果不相同则当前列不再属于公共前缀，当前列之前的部分就是最长公共前缀。1   2   3   4   5   6\n---------------------\nf   l   o   w   e   r\n\nf   l   o   w\n\nf   l   i   g   h   t\n时间复杂度：O(mn)，m是数组中的字符串的平均长度，n是字符串数量。最坏情况下数组中每个字符串的每个字符都会被比较一次。\n空间复杂度：O(1)。使用的额外空间复杂度为常数。\n\n思路2\n\n分治策略\n\n最长公共前缀（LCP）的计算满足结合律\nLCP(S1,……,Sn) = LCP(LCP(S1,……,Sk),LCP(Sk+1,……,Sn))\n时间复杂度：O(mn)，m是数组中的字符串的平均长度，n是字符串数量。递推公式：T(n) = 2 × T(n/2)+O(m) =&gt; T(n)=O(mn)\n\n空间复杂度：O(m × log n)，其中m是字符串数组中的字符串的平均长度，n是字符串的数量。空间复杂度主要取决于递归调用的层数，层数最大为log n，每层需要m的空间存储返回结果。\n代码（Java）\n\n思路1代码\npublic class Solution1 &#123;\n    public String longestCommonPrefix(String[] strs) &#123;\n        if (strs == null || strs.length == 0) &#123;\n            return \"\";\n        &#125;\n        // solution1\n        int length = strs[0].length();\n        for(int k = 0; k &lt; length; k ++)&#123;\n            char ch = strs[0].charAt(k);\n            for (int i = 1; i &lt; strs.length; i++) &#123;\n                if(k == strs[i].length() || strs[i].charAt(k) != ch)&#123;\n                    return strs[0].substring(0, k);\n                &#125;\n            &#125;\n        &#125;\n        return strs[0];\n    &#125;\n&#125;\n思路2代码\npublic class Solution2 &#123;\n    public String longestCommonPrefix(String[] strs) &#123;\n        if (strs == null || strs.length == 0) &#123;\n            return \"\";\n        &#125;\n        /**\n         * solution2 divide and conquer\n         */\n        else &#123;\n            return divideAndConquer(strs, 0, strs.length - 1);\n        &#125;\n    &#125;\n\n    private String divideAndConquer(String[] strings, int start, int end) &#123;\n        if (start == end) &#123;\n            return strings[start];\n        &#125; else &#123;\n            // 防止加法溢出\n            int middle = (end - start) / 2 + start;\n            String lcpLeft = divideAndConquer(strings, start, middle);\n            String lcpRight = divideAndConquer(strings, middle + 1, end);\n            return commonPrefix(lcpLeft, lcpRight);\n        &#125;\n    &#125;\n\n    private String commonPrefix(String lcpLeft, String lcpRight) &#123;\n        int minLength = Math.min(lcpLeft.length(), lcpRight.length());\n        for (int index = 0; index &lt; minLength; index++) &#123;\n            if (lcpLeft.charAt(index) != lcpRight.charAt(index)) &#123;\n                return lcpLeft.substring(0, index);\n            &#125;\n        &#125;\n        return lcpLeft.substring(0, minLength);\n    &#125;\n&#125;\nMain代码\npublic class Main &#123;\n    public static void main(String[] args) &#123;\n        String[] strings = &#123;\"abc\",\"ab\", \"abd\"&#125;;\n        Solution solution = new Solution();\n        String result = solution.longestCommonPrefix(strings);\n        System.out.println(\"result: \" + result);\n    &#125;\n&#125;","categories":["LeetCode"],"tags":["Java","LeetCode","面试","字符串","分治"]},{"title":"《The Book of Why》 — Chapter10","url":"/archives/7d28ba88.html","content":"第十章 大数据，人工智能和大问题\nCHAPTER 10 Big Data, Artificial Intelligence, and the  Big Questions\n\n\n\n\n借助贝叶斯网络，教会了机器在灰色地带进行思考，这是贝叶斯网络迈向强人工智能的重要一步。但目前仍无法教会机器理解事情的前因后果。（323）\n因果革命的星火逐渐覆盖包括流行病学、心理学、遗传学、生态学、地质学、气候科学等在内的多个专业领域。（324）\n\n因果模型与大数据\n因果问题从来不能单靠数据来回答，他要求我们构建关于数据生成过程的模型，或者至少要构建关于该过程的某些方面的模型。（325）\n\n解释数据就意味着做出一种假设，这种假设建基于事物在现实世界中的运作方式。（326）\n\n当变量较多时，统计估计这一步的难度不容小觑，只有借助大数据和现代机器学习技术，才有可能真正应对维度灾难。（326）\n\n因果推断能屏蔽不相关的特征，也能从不同的研究中把这些在关键方面相似的个体聚集起来，而大数据则能让我们收集到的关于这些个体的充分信息。（326）\n\n在一些案例中，无法将任何一项以往的相关研究所得出的效应迁移出去，但可以从这些效应的某种形式的组合中估计出目标总体的效应。（329）\n\ndo演算提供了一种确定可迁移性的一般标准：如果可以执行一系列的有效do演算，将目标效应的表达式转换为一个新的表达式，其中任何涉及S的因子都不包含do算子，则这一估计值就是可迁移的。\n其遵循的逻辑很简单：任何此类因子都可以从现有数据中估计出来，且不受差异因子S的影响。（329）\n\n\n强人工智能和自由意志\n在贝叶斯网络中，信息被有意地设计为在因果和诊断两个方向上来回流动。事实上，贝叶斯网络甚至无法解释因果方向是什么。（332）\n因果不对称在某些学科领域的重要性。（332）\n深度学习最主要地局限体现在其无法超越因果关系之梯地第一层级（335）\n谈论强人工智能时，因果模型就从奢侈品变成了必需品，强人工智能应该是能反思其行为，并能从过去的错误中吸取教训的机器，它应该能够理解“我本应该采取不同的行为”这句话，无论这句话是由人类告诉它的还是由它自己分析得出的。（336）\n理解自己的意图，并用它作为因果推断的证据，具备这一能力就说明行为主体的智能已经达到了自我察觉的水平。（336）\n在涉及高度自动化的人工智能系统时，应当确保其目标和行为在整个运行过程中与人类价值观保持一致。（342）\n\n\n《THE BOOK OF WHY: THE NEW SCIENCE OF CAUSE AND EFFECT》\n——JUDEA PEARL AND DANA MACKENZIE\n\n","categories":["Causality"],"tags":["Causality","因果推断"]},{"title":"《The Book of Why》 — Chapter9","url":"/archives/2e95c1ab.html","content":"第九章 中介：寻找蕴藏的作用机制\nCHAPTER 9 — Mediation: The Search for a Mechanism\n\n\n\n\n关于中介物，一个典型的问题是：他是否可以解释全部结果？（276）\n总效应、直接效应（不通过中介物）、间接效应（通过中介物）（276）\n“中介”使我们能够（更经常地从匮乏的数据中）量化由任何期望路径介导的效应的比例。（276）\n因果革命提供了一套明确而简单的规则，用以量化一个给定效应中直接效应和间接效应所占的比例。（277）\n\n坏血病：错误的中介物\n中介分析绝不仅仅是一个抽象的数学联系。（280）\n\n先天因素与后天培养：巴巴拉·伯克斯的悲剧寻找一种语言（伯克利大学招生悖论）\n悖论的正确解决很大程度上取决于要回答的问题是什么。（285）\n\n偏倚是一个不稳定的统计概念，如果采用不同的方法切分数据，偏倚就会消失。而作为一种因果概念，其实反映的是事实，因而必须保持稳定。（290）\n\n中介谬误：以中介物为条件（对中介物进行变量控制）而不是保持中介物恒定（设其为常量）。（290）\n若中介物和结果之间没有混杂，则这一错误无实际危害；\n若中介物和结果之间有混杂，则这一错误完全可以反转分析结果。\n\n总体的直接效应根据其定义就应取决于子总体直接效应的总和。\n简言之，每个局部的公平就意味着总体的公平！（291）\n\n\n黛西、小猫和间接效应\n受控直接效应CDE（controlled direct effect）\nCDE(0) = P(Y=1|do(X=1), do(M=0))- P(Y=1|do(X=0),do(M=0))\nCDE(1) = P(Y=1|do(X=1), do(M=1)) - P(Y=1|do(X=0),do(M=1))  (9.1)\n\n自然直接效应NDE（natural direct effect）\nNDE = P(YM=M0=1|do(X=1)) - P(YM=M0=1|do(X=0))  (9.2)\n\n自然间接效应NIE（natural indirect effect），指的是结果的预期变化。\nNIE = P(YM=M1=1|do(X=0)) - P(YM=M0=1|do(X=0))  (9.3)\n\n中介公式使NDE成为一种真正实用的工具。实现了从观测到的数据中将其直接估算出来的目标。（293-294）\n\nSCM中的方程具有确定性性质（296）\n\n\n线性“仙境”中的中介\n对于线性模型：总效应 = 直接效应 + 间接效应   (9.4)（297）\n\n线性模型的中介分析十分简单的首要原因：直接效应CDE不取决于中介物的水平，即CDE(m)对于所有m值来说都是相同的。（297-298）\n\n中介效应可以通过纯粹的统计学方法来定义和计算。（299）\n\n相加性原则的“自然效应”版本（其实是相减性原则）可在非线性函数中成立：\n总效应(X=0 —&gt; X=1)  = NDE(X=0 —&gt; X=1)   - NIE(X=0 —&gt; X=1)  \n\n在线性模型之外，间接效应对回归分析来说就不再有意义了，其仅剩的意义就是代数步骤的结果（“路径系数的乘积”）。\n\n\n拥抱假如世界\n两个行动有时比一个行动更容易分析，因为行动对应于删除图上的某些箭头，两个行动可以让图示变得更稀疏，更简单。（304）\n\n每一种直接效应和间接效应都可以转化为反事实表达式。（306）\n\n中介公式，实际上包含了两个公式，分别用于计算自然直接效应和自然间接效应。当其满足因果图所明确、透明地显示出的假设时，就能展示如何根据数据估算出两个效应的值。\n\n下图适用的中介公式（306）：\nNIE = Σm[P(M=m|X=1)-P(M=m|X=0)] × P(Y=1|X=0,M=m)   (9.5)\n中括号内的表达式代表X对M的影响，乘号后的表达式代表了M对Y的影响（当X=0时）。由此就揭示了系数乘积规则的起源，并展示了两个非线性效应的乘积具体应当如何计算。与方程(9.3)不同，方程 (9.5)没有下标和do算子，因此其结果可以直接根据第一层的数据估计出来。\n\n\n从中介公式中，可以一目了然的看到有关直接效应和间接效应的一切：使它们变大或者变小都需要什么，什么时候回可以从观察或干预数据中估算它们，什么时候可以认为 一个中介物要对将观察到的变化传递给结果变量这件事“负责”。\n\n\n中介个案研究“全民学代数”：一套方案和它的副作用\n\n\n\n\n吸烟基因：中介与干预\n=&gt;\n\n止血带：隐藏的谬误\n\n\n\n\n\n\n《THE BOOK OF WHY: THE NEW SCIENCE OF CAUSE AND EFFECT》\n——JUDEA PEARL AND DANA MACKENZIE\n\n","categories":["Causality"],"tags":["Causality","因果推断"]},{"title":"《The Book of Why》 — Chapter7","url":"/archives/c92decac.html","content":"第七章 超越统计调整：征服干预之峰\nCHAPTER 7 — Beyond Adjustment: The Conquest of  Mount Intervention\n\n\n\n\n因果之梯的第二层：对未尝试过的行动和策略的效果进行预测。混杂因子是导致我们预测混淆的主要障碍。在用“路径阻断”工具和后门标准消除这一障碍后，就能精确而系统地绘制出登上干预之峰地路线图。（路径阻断工具是d-separation）（195）\ndo演算允许研究者探索并绘制出通往干预之峰的所有可能的路线。（195）\n\n最简单的路线：后门调整公式\n最常用的预测干预效果的方法是使用统计调整公式“控制”混杂因子，如果确定已经掌握了变量的一个充分集（去混因子）的数据就可以用来阻断干预和结果之间的所有后门路径，就可以使用此方法。为了做到这一点，需要首先估计去混因子在每个“水平”或数据分层中产生的效应，并据此测算出干预的平均因果效应。然后需要计算这些层的因果效应的加权平均值，为此需要对每个层都按期在总体中的分布频率进行加权。（195-196）\n\n后门准则在估算平均因果效应的过程中所起的作用是，保证去混因子在各层中的因果效应与我们在这一层观察到的趋势相一致。据此可以从数据中逐层估计出因果效应，若没有后门准则，研究者就无法保证所有的统计调整都是合理的。(196)\n\n当有多个混杂因子和多个数据分层时，就很难将所有的可能性都罗列出来，一个补救办法是将数值分成有限并且数目可控的类别，但是这种分类方式的选择上可能存在主观性，如果需要进行统计调整的变量比较多，那么类别的数量就会呈指数增长，这将使计算过程变得难以执行，更糟糕的是，在分类完成后，很可能会发现许多层缺乏样本，因此无法对其进行任何概率估计。为应对“维度灾难”问题，设计了数据外推法，即通过一个与数据拟合的光滑函数来填充空的层所形成的洞。运用最为广泛的光滑函数是线性近似，使用时每个因果效应都可以用一个数字（因果系数）来表示，并且根据统计调整公式进行计算的过程非常简单。（197）\n\n无论是否经过统计调整，回归系数只表示一种统计趋势，其自身并不能传递因果信息。（198）\n回归系数有时可以体现因果效应，有时则无法体现，而其中的差异无法仅依靠数据来说明。还需要具备另外两个条件才能赋予偏回归系数rYXZ 以因果合法性：\n​    （1）所绘制的相应的因果图能够合理地解释现实情况；\n​    （2）需要据其进行统计调整的变量Z应该满足后门准则。（198）\n\n基于回归的统计调整只适用于线性模型：\n（1）一旦使用了线性模型，就失去了为非线性的相互作用建模的能力；（2）即使不知道图中箭头背后的函数是什么，后门调整仍有效。（199）\n\n后门准则和后门调整公式的关系：\n后门准则用于判定哪些变量集可以用来去除数据中的混杂；\n后门调整公式所做的实际上就是去混杂。（199）\n\n如果因缺乏必要的数据而无法阻断某条后台路径，统计调整公式就会完全失灵。（199）\n\n\n前门准则\n\n\n由于缺乏混杂因子的数据，不能阻断“吸烟 &lt;— 混杂因子 —&gt; 癌症”的后门路径，因此不能使用后门调整来控制混杂因子的影响。（200）\n前门指的是直接的因果路径“吸烟 —&gt; 焦油沉积 —&gt; 癌症”。（201）\n\n可以用纯数学的方式在不引入do算子本身（不进行实际干预）的情况下算出概率结果。（202）\n\n在不引入do算子的前提下表示 P（癌症 | do （吸烟）） 就被称作前门调整（202）\n\n依据上图，设X代表吸烟，Y代表癌症，Z代表焦油沉积，U代表不可观测的变量（未出现在公式中），公式如下\n\n前门调整公式：\n​         P(Y|do(X)) = Σz P(Z=z,X)Σx P(Y|X=x,Z=z)P(X=x)\n\n后门调整公式：\n​         P(Y|do(X)) = Σz P(Y|X,Z=z)P(Z=z)\n\n从前门公式中可知：\n（1）在公式的任何地方都看不到U，这是整个问题的关键；\n（2）将被估量视为一种针对问题中的目标量的计算方法。\n\n\n\n因果图的一个主要优势就算让假设变得透明，以供专家和决策者探讨和辩论。（203）\n\n在假设正确的情况下，即使没有混杂因子的数据，仍然可以用数学方式消除混杂因子的影响。（203）\n\n前门调整是一个强大的工具，因为：\n它允许我们控制混杂因子，并且这些混杂因子可以是我们无法观测（如“动机”）甚至无法命名的。也正是因为同样的原因，随机对照试验被认为是估计因果效应的黄金标准。（206）\n\n\ndo演算，或者心胜于物\n前门调整公式和后门调整公式的最终目标是根据P（Y|X,A,B,Z,……）此类不涉及do算子的数据估算干预的效果，即P（Y|do（X））。\n如果可以成功消除计算过程中的do概率，就可以利用观测数据来估计因果效应，就可以从因果关系之梯的第一层踏上第二层。（206）\n\n三条合法的do表达式变换⭐：（209）\n\n规则1：如果我们观察到变量W和Y无关（其前提可能是以其他变量Z为条件），那么Y的概率分布就不会随W而改变。等式成立的条件是，在删除了指向X的所有箭头之后，变量集Z会阻断所有从W到Y的路径。\n句法解释：允许增加或删除某个观察结果。\nP(Y|do(X), Z, W) = P(Y|do(X),Z)\n\n规则2：如果变量Z阻断了X到Y的的所有后门路径，那么以Z为条件（对Z进行变量控制），则do（X）等同于see（X）。即在控制了一个充分的去混因子之后，留下的相关性就是真正的因果效应。\n句法解释：允许用观察替换干预。\nP(Y|do(X),Z) = P(Y|X,Z)\n\n规则3：如果没有从X到Y的因果路径，就可以将do(X)和从P(Y|do(X))中移除。即如果我们实施的干预行动（do）不会影响Y，那么Y的概率分布就不会改变。\n句法解释：允许删除或添加干预。\nP(Y|do(X)) = P(Y)\n\n\n\n有了上述三条规则，就可以推导出前门调整公式。这是一个不以控制混杂因子为手段来估计因果效应的方法。（210）\n\n如果我们在规则1到3中找不到根据数据估计P(Y|do(X))的方法，那么对于这个问题，解决方案就是不存在的。\n在此情况下，除了进行随机对照试验别无选择。这三条规则还能告诉我们，对于某个特定的问题，什么样的额外假设或实验可以使因果效应从不可估计变为可估计。（212）\n\n伊利亚·斯皮塞=&gt;发现可以用于确定某个解决方案是否存在“多项式时间”的算法。（213）\n\n\n案例：斯诺医生的离奇案例\n工具变量（222）如图，Z就是一个工具变量：\n（1）Z和U之间没有箭头（二者独立）\n（2）Z和X之间有一个箭头\n（3）Z和Y之间没有直接箭头\n\n\n工具变量允许我们执行与前门调整相同的处理：在无法控制混杂因子或收集其数据的情况下估计X对Y的效应。（223）\n\n路径图所体现的假设在本质上是因果关系。（223）\n\n\n好胆固醇与坏胆固醇\n“未履行问题”，如受试者虽然随机地接受了药物安排，但实际上并没有复用被分配的药物。（226）\n\n当变量都是二元变量，而不是数值变量时，意味着不能使用线性模型，因此工具变量公式也不适用。在这种情况下，通常可以使用被称为“单调性”的弱相关来代替线性假设。但在这么做之前，需要先确保工具变量的三个假设都是有效的（226-227）：\n（1）工具变量Z独立于混杂因子\n（2）Z到Y无直接路径\n（3）Z和X之间存在强关联\n\n取最好和最坏情况的做法通常会得到一个估计结果的取值范围。（228）\n\n在做任何干预研究之前，都要看我们实际操作的变量（如低密度脂蛋白的终生水平）是否与我们认为自己正在操作的变量（如低密度脂蛋白的当前水平）相同。\n工具变量是一个重要的工具，他能我们帮助我们揭示do演算无法解释的因果信息，do演算强调的是点估计，而非不等式。\n相比工具变量，do演算具有更强大的灵活性，因为在do演算中，我们不需要对因果模型中函数的性质做任何假设。而如果我们的确有足够的科学依据证实类似单调性或线性这样的假设的话，那么像工具变量这种针对性更强的工具就更值得考虑。（230-231）\n\n\n\n《THE BOOK OF WHY: THE NEW SCIENCE OF CAUSE AND EFFECT》\n——JUDEA PEARL AND DANA MACKENZIE\n\n","categories":["Causality"],"tags":["Causality","因果推断"]},{"title":"《The Book of Why》 — Chapter8","url":"/archives/5992f13d.html","content":"第八章 反事实：探索关于假如的世界\nCHAPTER 8 — Counterfactuals: Mining Worlds That  Could Have Been\n\n\n\n\n我们已经见识了几种方法，可以用于在各种情景设定和条件下确定干预的效果。在第四章我们讨论了随机对照试验，他被誉为医学临床试验的黄金标准，我们还看到了一些适用于观察性研究的方法，其中处理组和对照组的成员不是随机分配的。对此，如果我们可以采集到能够阻断所有后门路径的变量集的数据，我们就可以使用后门调整公式来估算出干预效果。如果能找到一个被混杂因子“屏蔽”的前门路径，我们就可以引入前门调整。如果我们愿意接受线性或者单调性假设，那么我们就可以使用工具变量（假设该变量可以从因果图中找到，或研究者可以根据试验设计提出一个合适的变量）。此外，那些真正富有冒险精神的研究者还可以使用do演算或者其衍生算法，绘制出一条通往干预之峰的新路线。（235）\n随机对照试验、后门调整公式、前门调整公式、工具变量、do演算等努力目标都是找到研究中处理的某个总效应或者在某些典型个体或子总体中的效应（平均因果效应）。（235）\n责任和过失、遗憾和信誉——这些概念都可以被纳入因果思维之中。（235）\n人类具有想象不存在的世界的能力，我们的天赋是能看到“假如……则本可能是什么”。（236）\n因果关系的理论框架——休厄尔·赖特的路径图及其衍生产物结构因果模型（SCMs）。（236）\n三种不同的因果关系：必要因果关系、充分因果关系、充要因果关系。（237）\n\n从修昔底德和亚伯拉罕到休谟和刘易斯\n剂量—阈值曲线 或 “阈值效应”（239）\n\n潜在结果、结构方程和反事实的算法化\n唐纳德·鲁宾将潜在结果作为一种回答因果问题的语言加以介绍，这一理论成果为研究人员提供乐了一种高度灵活的语言，使其可以在总体和个体层面上表述出几乎所有他们想问的问题。（245）\n\n假设X的值为x，则变量Y一定会取某个与之对应的值YX=x(u)也可写为Yx，其客观存在性与Y在现实中实际取的值相当。潜在结果，或反事实，是在个体层面而非总体层面上定义的。（245）\n\n将因果推断问题看作是数据缺失问题，可能会造成非常严重的误导。（248）\n\n匹配、线性回归等插值方法在本质上是有缺陷的，它们是数据驱动的，不是模型驱动的。没有哪种纯粹基于数据的方法（第一层级）可以回答反事实的问题（第三层级）。即使是标准的数据缺失问题也需要借助因果建模来解决。（249-250）\n\n将中介物误认作混杂因子是因果推断中最知名的错误之一，混淆因子要求统计调整，而中介物禁止统计调整。（251）\n\n方程的创建者必须承诺他所写的方程真实反映了他所认定的现实世界中谁听从于谁的观点。这种承诺或信念上的差异赋予了结构方程支持反事实假设的力量和否定回归方程的力量。（252）\n\n从结构模型中推导反事实的三个步骤（253）：\n\n（1）外展：估计特质因子（外生变量）\n（2）干预：利用do算子改变模型，以反映反事实假设\n（3）预测：利用修改后的模型及有关外生变量的更新信息来估算结果。\n\n\n上述三个步骤中，步骤2告诉我们要用do算子删除指向被赋予了反事实值的变量的箭头，那些可能通过干预变量影响结果的变量，在相应的箭头被删除后就不再被允许以这种方式传递信息了。（253）\n\n以上三个步骤被概况为“因果推断第一定律”：Yx(u) = YMx(u)。\n潜在结果Yx(u)可以通过下述方法来推断：构建模型Mx（确保删除所有指向X的箭头），并计算结果Y(u)。因果关系之梯的第二层级和第三层级中的所有可估量都由此产生。简言之，将反事实简化为一个算法使我们得以在数学所允许的范围内征服第三层级的一大片版图。（254）\n\n有效估计：若模型假设是有效的，潜在的结果与估计值会重合。（254）\n\n借助结构方程得到的任何反事实（潜在）结果，都合乎逻辑地遵循了模型所体现地假设，而根据数据驱动方法所获得地答案就像伪相关一样反复无常，因为它无法被用来解释重要的建模假设。（254）\n\n利用模型和数据结合，可以成功预测个体在某个假设条件下（在反事实的世界中）的表现。但前提是我们做出了强有力的假设，除了断定观察到的变量之间的因果关系，还假设了函数关系是线性的。（—爱丽丝的例子）但事实上我们并不总能获得这些函数的信息。（254）\n\n\n看到你的假设的好处\n珀尔为计算反事实所展示的结构因果模型方法与鲁宾所使用的潜在因果方法不同，一个主要区别就是前者使用了因果图，因果图允许研究者用他们自己能理解的方式表示因果假设，并把所有的反事实作为其世界模型的一种衍生属性。（255）\n如何利用因果图来判断（条件的）可忽略性，以一组匹配变量Z为条件，要确定对于结果Y来说是否可忽略，只需要测试Z是否阻断了X和Y之间的所有后门路径，同时Z的成员都不是X的后代即可。（257）\n我们可以很容易地测试出以因果图为基础建立的模型与数据的兼容性。（258）\n可测试性：无论何时，只要图中X和Y之间的所有路径都被一组节点Z阻断，那么在以Z为条件的前提下，数据中的X和Y就应该是条件独立的。这就是d-separation。这个属性允许我们在数据未能显示出相应的独立性时否定并放弃模型。（258）\n响应函数是赋予结构因果模型处理反事实的能力的关键因素。同时又是结构因果模型和因果贝叶斯模型的一个主要区别点。（258）\n结构因果模型与概率贝叶斯网络、因果贝叶斯网络的不同之处在于，SCM没有条件概率表，指向Y的箭头只简单地表示Y是其父变量和外生变量UY的一个函数：Y = fY(X,A,B,C,…,UY)。（258）\n结构方程模型SEM和结构因果模型SCM的一个重要区别是，SCM中的因果关系不一定是线性的。SCM分析所用到的方法对非线性函数、线性函数和离散变量、连续变量同样有效。（260）\n\n反事实与法律\nPN（probability of necessity）必要性概率\nPS（probability of sufficiency）充分性概率\n必要性概率涉及两个不同世界之间的对比，X=1的现实世界和X=0的反事实世界。是否有事后判断（知道现实世界中发生了什么事）是反事实和干预之间的关键区别。没有事后判断，P(YX=0=0)和P(Y=0|do(X=0))之间就没有区别。（262）\n\n必要因、充分因和气候变化\n选择线性模型通常是出于方便，而不是出于什么可靠的理由。（270）\n\n反事实的世界\n将反事实纳入考虑后，因果推断引擎提出的因果问题的多样性和丰富性就会大大加强。（270）\n\n现在反事实方法最受欢迎的一种应用形式就是“中介分析”。（271）\n\n中介物或者中间变量指的是将处理效应传递给结果的事物。\n人们感兴趣的主要问题是，中介变量是否解释了处理变量的全部影响，或者处理变量的部分效果是否可以不通过中介变量传递给结果。（271）\n\n中介分析的目的是将直接效应（未通过中介物介导）从间接效应（通过中介物介导）中解析出来。（271）\n\n直接效应和间接效应都涉及反事实陈述。（271）\n\n\n\n《THE BOOK OF WHY: THE NEW SCIENCE OF CAUSE AND EFFECT》\n——JUDEA PEARL AND DANA MACKENZIE\n\n","categories":["Causality"],"tags":["Causality","因果推断"]},{"title":"《The Book of Why》 — Chapter5","url":"/archives/27238d80.html","content":"第五章 烟雾缭绕的争论：消除迷雾，澄清事实\nCHAPTER 5 The Smoke-Filled Debate:  Clearing the Air\n\n\n\n\n时间序列对于因果关系的证明来说是一种非常糟糕的证据。（147）\n因果图的美在于它让偏倚的源头变得显而易见。（159）\n\n\n《THE BOOK OF WHY: THE NEW SCIENCE OF CAUSE AND EFFECT》\n——JUDEA PEARL AND DANA MACKENZIE\n\n","categories":["Causality"],"tags":["Causality","因果推断"]},{"title":"《The Book of Why》 — Chapter6","url":"/archives/be2adc3a.html","content":"第六章 大量的悖论⭐（实例）\nCHAPTER 6 — Paradoxes Galore!\n\n\n\n\n出生体重悖论反映了因果关系和相关关系之间的张力，这种张力源自于二者处于因果关系之梯的两个不同层级上，又因为人类的直觉在因果逻辑下运作而数据遵从的则是概率和比例的逻辑而进一步加剧。（165）\n当我们在一个领域所学到的规则误用到其他的领域时，悖论就出现了。（165）\n因果悖论突出强调了直觉性的因果推理模式与概率统计逻辑相冲突的地方。（165）\n\n令人费解的“蒙提·霍尔悖论”\n问题：三个门，两羊一车，选一个，主持人打开另外两个中有羊的一个，此时，换门是否更有利于赢得车？（166）\n\n解决这一悖论的关键是，不仅需要考虑数据，也需要注意数据生成的过程。（167）\n\n习惯“数据约简”而忽略数据的生成过程是不可取的。（168）\n\n\n\n上图为该悖论的因果图，“主持人打开的门”是一个对撞因子，一旦我们获得了关于这个变量的信息，图中所有的概率都变成了关于这一信息的条件概率。但是，当我们以对撞因子为条件时，就会在两个父节点之间制造出一种虚假的依存关系（伪相关）。（169）\n\n贝叶斯分析的一个普遍主题：任何通过了威胁其有效性的测试的假设，其可能性都会变大。威胁越大，幸存下来的假设的可能性就越大。（170）\n\n\n更多的对撞偏倚：伯克森悖论\n问题：两种疾病即使在一般人群中彼此不存在实际联系，在医院的病人中也会形成某种似是而非的关联。（172）\n\n同类型的悖论现象：扔硬币游戏，同时扔两个硬币100次，只在至少一次正面的情况下记录结果，根据这些记录，会发现两枚硬币的抛掷结果并不独立，每次当硬币1为反面落地时，硬币2必为正面落地。\n事实上，这些结果是删除了所有两枚硬币都是背面朝上的结果后得到的，换句话说：对这个对撞因子进行了变量控制。（174）⭐\n\n最纯粹的、最本质的意义上：我们观察到的相关就是一种错觉，我们选择哪些事件进入数据集同时忽略另一些事的做法给我们自己带来了错觉。（175）\n\n\n辛普森悖论\n问题：BBG药物，服用药物对男性患者群体有害，对女性患者群体也有害，但对整体的患者群体有益。（176）\n确凿性原则：假设无论事件C是否发生，某个行动都会增加某一结果的可能性，则该行动也将在我们不知道C是否发生的情况下增加这个结果的可能性，条件是该行动不改变C的概率。（181）\n使用聚合数据或者分割数据，哪种做法更合适，取决于数据的生成过程。（182）\n只有当每个子总体的相对比例在各群组之间一致的情况下，确凿性原则才起作用。（189）\n\n\n《THE BOOK OF WHY: THE NEW SCIENCE OF CAUSE AND EFFECT》\n——JUDEA PEARL AND DANA MACKENZIE\n\n","categories":["Causality"],"tags":["Causality","因果推断"]},{"title":"《The Book of Why》 — Chapter3","url":"/archives/ce4028b5.html","content":"第三章 从证据到因：当贝叶斯牧师遇见福尔摩斯先生\nCHAPTER 3 — From Evidence to Causes: Reverend  Bayes Meets Mr. Holmes\n\n\n\n电脑侦探波拿巴\n贝叶斯网络与因果图的关系很简单：因果图就是一个贝叶斯网络，其中的每个箭头都表示一个直接的因果关系，或者至少表明了存在某个因果关系的可能性。反过来，并不是所有的贝叶斯网络都是因果关系网络。而在很多实际应用中这一点并不重要。（75）\n\n贝叶斯牧师与逆概率问题\n贝叶斯的理论表明可以从一个果推断某个因的概率，即逆概率推理。从因到果是前向概率。（77）\n数据对于因果不对称是不敏感的。（79）\n贝叶斯法则在统计学中最重要的应用：可以在判断较为可靠的一个方向上直接估算出条件概率，并利用数学工具推导处在判断较为模糊的另一个方向上的概率。\n还可以将贝叶斯法则看作一种方法，用以更新对某一特定假设的信念。（81）\n“主观性”，有时被看作贝叶斯网络的一个缺点，但也有一些人认为这是贝叶斯推理的一个强大优势，它允许我们在数学上表达我们的个人经验，并以条理化、易懂的方式将其与数据结合起来。在普通直觉不起作用或情绪可能会导致我们误入歧途的情况下，贝叶斯网络能够引导我们进行正确的推理。（83）\n\n从贝叶斯法则到贝叶斯网络\n贝叶斯法则无可争议的优势：可以同时在诊断模式（结果推原因，逆概率）和预测模式（原因推结果，前向概率）中运行。（88）\n任何人工智能都必须建立在模拟我们所知道的人类神经信息处理过程的基础上，并且不确定性下的机器推理必须借助类似的信息传递的体系结构来构建。信息是一个方向上的条件概率和另一个方向上的似然比。（89）\n\n贝叶斯网络：应如何看待数据\n贝叶斯的逆概率规则是一种形式作为简单的贝叶斯网络。（91）\n\n贝叶斯法则告诉我们是如何逆转正向推理的过程，具体做法就是用先验概率×似然比。（91）\n\n包含两个连接的三节点网络——“接合”，是所有贝叶斯网络（以及因果网络）的构建模块。（92-94）\n\nA—&gt;B—&gt;C ：链\n\nA&lt;—B—&gt;C ：叉\nB通常被视作A和C的共因，或混杂因子，混杂因子会使A和C在统计学上发生关联，即使他们之间没有直接的因果关系。\n\nA—&gt;B&lt;—C ：对撞\n与“对撞偏倚”（“辩解效应”）有关\n\n\n\n\n我的行李箱在哪里？从亚琛到桑给巴尔\n贝叶斯网络的两个方面：图示和条件概率表。（95）\n图示以定性的方式描述了变量之间的关系，条件概率作为定量的输入可以使贝叶斯网络得到一个定量的结果。（95）\n\n真实世界中的贝叶斯网络\n贝叶斯网络一旦建立，就不需要对其进行干预，告诉它该如何评估新的数据片段。整个网络的更新可以很快完成。这个网络是一体化的，这意味着它作为一个整体对所有的新信息作出反应。（102-103）\n贝叶斯网络的透明性使它有别于其他机器学习的模型，后者更倾向于制造高深莫测的“黑盒”。（103）\n因果推断科学的一个目标就是创建更为顺畅的人机接口，比如将调查人员的直觉也纳入信念传播的计算过程。（103）\n\n从贝叶斯网络到因果图⭐\n从理论和实践的角度看，贝叶斯网络抓住了实现因果图与数据的交互的关键。贝叶斯网络的所有概率性质和在其基础上发展起来的信念传播算法在因果图中仍然有效。（106）\n贝叶斯网络与因果图的主要区别在于他们的构造和用途。实际上，贝叶斯网络不过是一张巨大的概率表的简洁表示形式。（106）\n因果图的假设不能是心血来潮地虚构，它必须经过数据地审查，并且是可证伪的。（107）\n解读因果模型的另一种更加便捷的方法是假设实验。因果图中的每个箭头可以被看作一个假设实验的结果陈述。（107）\n因果图的图形结构与它所代表的数据之间的关系，允许我们在不进行实际操作的情况下进行模拟调整。（108）\nA &lt;- B -&gt; C，在不进行任何观测的情况下，A和C伪相关。（108）⭐\n\n\n《THE BOOK OF WHY: THE NEW SCIENCE OF CAUSE AND EFFECT》\n——JUDEA PEARL AND DANA MACKENZIE\n\n","categories":["Causality"],"tags":["Causality","因果推断"]},{"title":"《The Book of Why》 — Chapter4","url":"/archives/5024bd16.html","content":"第四章 混杂和去混杂：或者，消灭潜伏变量\nCHAPTER 4 — Confounding and Deconfounding:  Or, Slaying the Lurking Variable\n\n\n\n\n当一个变量同时影响到选择接受处理的对象以及实验结果时，混杂偏倚就产生了。（115）⭐\n\n\n\n如上图所示，位于叉接合中心的变量Z就是X和Y的混杂因子。真正的因果效应X-&gt;Y与由叉接合X&lt;-Z-&gt;Y诱导的X和Y之间的伪相关混合在一起。（115）\n\n本章的目标之一就是从因果图的角度来解释，为什么随机对照实验能估计出X-&gt;Y的因果效应，同时免除混杂偏倚的影响。因果图使分析重心从混杂因子向去混杂因子的转变成为可能（117）\n\n因果革命允许我们超越费舍尔的随机对照实验，通过非实验性研究推断因果效应，其主要途径就来自这种分析重点的转变。（117）\n\n“后门准则”（back-door criterion）可以明确识别出因果图中哪些变量是去混因子。（118）\n\n目前的普遍共识：（1）混杂需要，也具备一个因果解决方案；（2）因果图提供了一种完整的、系统的方法引领我们找到那个解决方案。（118）\n\n\n对混杂的长期恐惧\n掌握既定结论背后的假设比试图用随机对照试验来规避这些假设更有价值。且随机对照试验本身也由局限性。（120）\n\n对自然的巧妙询问：随机对照试验为何有效混杂的新范式\n已知条件概率P(Y | X)、X与Y之间的因果关系P(Y | do(X))，混杂可定义为导致P(Y | X) ≠ P(Y | do(X))，即两个概率出现差异的所有因素。（127）\n“后门准则”将定义混杂、识别混杂因子和根据混杂因子进行统计调整这些问题变成了一个简单的过程。（133）\n\ndo算子和后门准则⭐（本节有很多图示例子可参考学习）\n可以将链接看作一个管道，找个管道将信息从起点X传递到终点Y。（133）\n\n事实上，非因果路径是混杂的根源。（之前将混杂定义为任何使得P(Y | X) ≠ P(Y | do(X))的因素），do算子会清除指向X的所有箭头，这样它就可以防止有关X的任何信息在非因果方向流动。（133）\n\n需要牢记的一条基本规则：（134）\n控制一个变量的后代节点（或替代物）如同“部分地”控制变量本身；\n控制一个中介物的某个后代节点意味着部分的关闭了信息管道；\n控制一个对撞变量的某个后代节点意味着部分地打开了信息管道。\n\nA&lt;—B&lt;—C—&gt;D&lt;—E—&gt;F—&gt;G&lt;—H—&gt;I—&gt;J\n如上面的因果图，如果这条路径的一个接合被阻断，那么J就无法通过这条路径“找到”A。\n因此有很多办法阻断A和J之间的信息流通：控制B、控制C、不控制D、控制E、控制F、不控制G、控制H、控制I等，并且只需要做到一项就足够了。这就是为什么常规的统计过程——控制我们可以测量的一切，造成了如此严重的误导。\n事实上，对上图所示的路径来说，在不控制任何变量的前提下，这条路径本身就算被阻断的！D和G的对撞在没有任何外部帮助的情况下阻断了这条路径。而控制D和G将打开这条路径，使A和J能完成信息流通。（134）\n\n更确切地说，后门准则（back-door criterion）定义为所有X和Y之间以指向X的箭头为开始的路径；如果阻断了后门路径（这些路径允许X和Y之间的伪相关信息在管道中流动），就完成了对X和Y的去混杂。\n如果试图通过控制某一组变量Z来实现这一点，还需要确保Z的任何成员都不是X的后代，否则可能部分或完全地关闭这条X和Y之间地因果路径。（135）\n\n“M偏倚”指出了传统方法的一个错误：仅仅因为某个变量与X和Y都相关就将该变量视为混杂因子是错误的。（137）\n\n混杂问题的完整解决方案是因果革命的主要两点之一。（140）\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n《THE BOOK OF WHY: THE NEW SCIENCE OF CAUSE AND EFFECT》\n——JUDEA PEARL AND DANA MACKENZIE\n\n","categories":["Causality"],"tags":["Causality","因果推断"]},{"title":"《The Book of Why》 — Preface & Chapter1","url":"/archives/5a47ea4c.html","content":"序言\nPreface\n\n\n\n\n因果革命最重要的成果之一就是解释了如何在不实际实施干预的情况下预测干预效果。如果拥有一个因果模型，就可以在大部分情况下从未经干预处理的数据中预测干预的效果了。（XVI）\n“反事实的算法化”是因果革命的另一项宝贵的成果。（XVII）\n因果推断引擎是一种问题处理机器，他接收三种不同的输入——假设、问题、数据。（XVIII）\n以因果模型的路径来表示变量之间的听从模式通常会导向数据中某种显而易见的模式或相关关系（也被称为可被验证的蕴涵），将D和L之间没有连接路径翻译成统计学语言，就是D和L相互独立，也就是说，发现D的存在不会改变L发生的可能性。（XX）\n如果拥有一个因果模型，就可以在大部分情况下从未经干预处理的数据中预测干预的结果了。（XXIII）\n第一章：因果关系之梯，观察、干预、反事实（XXIV）\n第二章：发展历史\n第三章：贝叶斯网络及实例\n第四章：随机对照试验\n第五章：因果论发展史重要节点\n第六章：悖论\n第七章：干预\n第八章：反事实\n第九章：中介\n第十章：人类智能的自动化（强人工智能）\n\n第一章 因果关系之梯\nCHAPTER 1 — The Ladder of Causation\n\n\n没有哪台机器可以从原始数据中获得解释。对数据的解释需要借助外部推力。（4）\n因果模型的一个关键特征：模块性（6）\n因果图是因果推理引擎的计算核心（6）\n\n因果关系的三个层级\n观察能力seeing、行动能力doing、想象能力imaging \n观察、                    干预、                 反事实\n\n\n\n\n关联 ： 观察寻找规律，如果观察到某一事件改变了观察到的另一个事件的可能性，则称这两个事件关联。（7）\n\n因果关系之梯的第一层级要求我们基于被动观察做出预测（7）\n\n相关分析和回归分析是典型的关联度量之法。（9）\n\n强人工智能的目标是制造出拥有类人智能的机器，让它们能与人类交流并指导人类的探索方向。而深度学习只是让机器具备了高超的能力，而非智能，这种差异是巨大的，原因就在于后者缺少现实模型。（9）\n\n干预涉及主动改变现状。（10）\n\n无论数据集多大或者神经网络多深，只要使用的是被动收集的数据，都无法回答有关干预的问题。（10）\n\n因果关系之梯第二层级的典型问题是：“如果我们实施……行动，将会怎样？”即我们改变环境会发生什么？记作P(Y|do(X))。另一个热门问题是怎么做。（11）\n\n数据就是事实。（12）\n\n反事实位于因果关系之梯的顶层。（13）\n迷你图灵测试\n无论何时，如果想使某件事发生，那么就删除指向该事件的所有箭头，之后继续按照逻辑规则进行分析，就好像那些箭头从未出现过一样。（19）\n\n使某件事发生就意味着将它从所有其他影响因子中解放出来，并使它受限于唯一的影响因子——能强制其发生的那个因子。（19）\n\n构建因果模型不仅仅是画箭头，箭头背后还隐藏着概率。（23）\n\n通常情况下，因果图自身的结构就足以让我们推测出各种因果关系和反事实：简单的或复杂的，确定的或概率的，线性的或非线性的。（23）\n\n\n论概率与因果关系\n因果关系不能被简化为概率！（25）\n概率提高这个概念确实不能单纯的用概率来表示。（27）\n贝叶斯网络是一种关于不确定性的推理方法，它可以根据我们观察到的某些事实迅速推算出某些其他事实为真或为假的概率。（28）\n贝叶斯网络适用于一个所有问题都被简化为概率或者变量间的关联程度的世界，他无法自动升级到因果关系之梯的第二层或第三层。（29）\n作者的主要观点：概率能将我们对静态世界的信念进行编码，而因果论则告诉我们，当世界被改变时，无论改变是通过干预还是通过想象实现的，概率是否会发生改变以及如何改变。（29）\n\n\n《THE BOOK OF WHY: THE NEW SCIENCE OF CAUSE AND EFFECT》\n ——JUDEA PEARL AND DANA MACKENZIE\n\n","categories":["Causality"],"tags":["Causality","因果推断"]},{"title":"《The Book of Why》 — Chapter2","url":"/archives/b9471823.html","content":"第二章 从海盗到豚鼠：因果推断的起源\nChapter2  — From Buccaneers to Guinea Pigs:  The Genesis of Causal Inference\n\n\n\n高尔顿和被丢弃的探索皮尔逊：狂热者的愤怒\n使用因果透镜可知在某些情况下，正确的分析只能来自于聚合数据而非来自分组数据。因果推断的逻辑能够在事实上告诉我们应该信任哪个结果。（50）\n休厄尔·赖特首次建立了一套根据数据回答因果关系的数学方法，被称为路径图或者路径分析。赖特首次证明了“相关关系不等于因果关系”这个判定应该让位于“某些相关关系确实意味着因果关系”。（53）\n\n但它仍在动\n因果关系绝不仅是针对数据的关系，在因果分析中，必须将对数据生成过程的理解体现出来，并以此得出初始数据不包含的内容。（63）\n结构方程建模（SEM）（64）\n\n从主观性到客观性——贝叶斯连接\n与相关性分析和大多数主流统计学不同，因果分析要求研究者做出主观判断。绘制的因果图是对于某个研究课题所涉及的因果过程拓扑结构的定性判断，在因果关系方面，睿智的主观性比任何客观性都更能阐明我们所处的这个真实世界。（67）\n贝叶斯分析的原型：先验判断+新的证据-&gt;经过修正的判断。（67）\n许多例子已经证明，随着数据量的增加，先验判断的影响会越来越小，乃至彻底消失，这就让我们最终得到的那个结论仍然是客观的。（68）\n\n\n《THE BOOK OF WHY: THE NEW SCIENCE OF CAUSE AND EFFECT》\n——JUDEA PEARL AND DANA MACKENZIE\n\n","categories":["Causality"],"tags":["Causality","因果推断"]},{"title":"SQL学习：INDEX、DROP、ALTER、 AUTO INCREMENT","url":"/archives/38f4f5a2.html","content":"创建索引介绍在不读取整个表的情况下，索引能更加快速地查找数据。用户无法看到索引，他们只能被用来提高查询效率。更新一个带有索引的表比更新一个不带索引的表花费更多时间，这是由于索引本身也需要更新导致的。因此，理想的做法是仅在经常被搜索的表上创建索引。\n\n语法创建简单索引，允许重复\n\nCREATE INDEX index_name\nON table_name (column_name);\n\n创建简单索引（在多个列上），允许重复\n\nCREATE INDEX index_name\nON table_name (column_name1, column_name2);\n\n创建唯一索引，不允许重复，唯一索引意味着两个行不能拥有同一个索引值\n\nCREATE UNIQUE INDEX index_name\nON table_name (column_name)\n\n实例CREATE INDEX PIndex\nON Persons (LastName);\n\nCREATE INDEX PIndex\nON Persons (LastName, FirstName);\n\nDROP介绍通过DROP语句可以删除索引、表、数据库\n语法1 撤销索引 DROP INDEX(Oracle)\nDROP INDEX index_name;\n\n语法2 撤销表 DROP TABLEDROP TABLE table_name;\n\n语法3 撤销数据库 DROP DATABASEDROP DATABASE database_name;\n\n语法4 TRUNCATE TABLE语句只删除表中内容，不删除表\nTRUNCATE TABLE table_name;\n\nALTER TABLE介绍ALTER TABLE 语句用于在已有的表中 添加、删除 或 修改 各个列。\n语法1 在表中添加列ALTER TABLE table_name\nADD column_name data_type;\n语法2 删除表中的列ALTER TABLE table_name\nDROP COLUMN column_name;\n\n语法3 改变表中的数据类中ALTER TABLE table_name\nMODIFY column_name data_type;\n举例Persons表\n\n\nP_id\nLastName\nFirstName\nCity\n\n\n\n1\nsan\nzhang\nBeiJing\n\n\n2\nsi\nli\nShangHai\n\n\n3\nwu\nwang\nGuangZhou\n\n\n实例1在 \"Persons\" 表中添加一个名为 \"DateOfBirth\" 的列\n\nALTER TABLE Persons\nADD DateOfBirth date;\n\n操作后的表如下：| P_id | LastName | FirstName | City | DateOfBirth ||–|–|–|–|–|| 1 | san | zhang | BeiJing ||| 2 | si | li | ShangHai ||| 3 | wu | wang | GuangZhou ||\n实例2改变 \"Persons\" 表中 \"DateOfBirth\" 列的数据类型\nALTER TABLE Persons\nMODIFY DateOfBirth year;\n\n\n实例3删除 \"Person\" 表中的 \"DateOfBirth\" 列\nALTER TABLE Persons\nDROP COLUMN DataOfBirth;\n\n操作后的表如下：| P_id | LastName | FirstName | City ||–|–|–|–|| 1 | san | zhang | BeiJing || 2 | si | li | ShangHai || 3 | wu | wang | GuangZhou |\nAUTO INCREMENT 字段介绍我们通常希望在每次插入新记录时，自动地创建主键字段的值。AUTO INCREMENT 字段可以在新记录插入到表中的时候生成一个唯一的数字\n语法在 Oracle 中，必须通过 sequence 对象（该对象生成数字序列）创建 AUTO INCREMENT 字段:\n\nCREATE SEQUENCE seq_person\nMINVALUE        1\nSTART WITH      1\nINCREMENT BY    1\nCACHE           10\n上面的代码创建一个名为 seq_person 的 sequence 对象，它以1起始且以 1 为单位递增。该对象缓存10个值以提高性能。cache选项规定了为了提高访问速度要存储多少个序列值。\n实例要在 \"Persons\" 表中插入新记录，我们必须使用 nextval 函数（该函数从 seq_person 序列中取回下一个值）：\n\nINSERT INTO Persons (ID,FirstName,LastName)\nVALUES (seq_person.nextval,'Lars','Monsen')\n\n上面的 SQL 语句会在 “Persons” 表中插入一条新记录。“ID” 列会被赋值为来自 seq_person 序列的下一个数字，所以使用了nextval函数；“FirstName”列 会被设置为 “Lars”；”LastName” 列会被设置为 “Monsen”。\nVIEW(试图)介绍视图是可视化的表，下面主要介绍怎样创建、更新和删除视图\n创建视图 CREATE　VIEW语法1 创建视图视图是基于SQL语句的结果集的可视化的表。\n视图包含行和列，像一个真实的表（实际上并不是）。视图中的字段就是来自一个或多个数据库中的真实的表中的字段。\n可以向视图添加WHERE语句、JOIN语句以及SQL函数，也可以呈现数据，就像这些数据来自于某个单一的表一样。\nCREATE VIEW view_name AS -- 创建 -- \nSELECT column_name(s)    \nFROM table_name\nWHERE condition;\n\n视图总是显示最新的数据，每次查询视图时，数据库引擎通过使用视图的SQL语句重建数据。\n\n实例1 创建视图视图 &quot;Current Product List&quot; 会从 &quot;Products&quot; 表列出所有正在使用的产品\n\nCREATE VIEW [Current Product List] AS\nSELECT ProductID, ProductName\nFROM Products\nWHERE Discontinued&#x3D;No;\n实例2 查询实例1中的视图SELECT * \nFROM [Current Product List];\n\n更新视图 REPLACE VIEW语法2CREATE OR REPLACE VIEW view_name AS\nSELECT column_name(s)\nFROM table_name\nWHERE condition;\n实例3向 \"Current Product List\" 视图添加 \"Category\" 列\n\nCREATE VIEW [Current Product List] AS\nSELECT ProductID, ProductName, Category\nFROM Products\nWHERE Discontinued=No \n\n撤销视图 DROP VIEW语法DROP VIEW view_name\n\nNULL 值介绍NULL值代表遗漏的未知数据。表的列默认是可以存放NULL值的。下面介绍 IS NULL 和 IS NOT NULL 操作符。\nNULL 值介绍\n如果表中的某个列是可选的，那么我们可以在不向该列添加值的情况下，插入新记录或更新已有的记录。这意味着该字段将以 NULL值的形式来保存。\n\nNULL 值的处理方式与其他值不同。\n\nNULL 用作未知的 或 不适用 的 值 的 占位符。\n\n无法比较 NULL 和 0，因为它们不等价。\n\n也无法使用比较运算符来测试 NULL 值，比如 =、&lt; 或 &lt;&gt;。\n\n必须使用 IS NULL 和 IS NOT NULL 操作符。\n\n\n实例1 IS NULLSELECT LastName, FirstName, Address FROM Persons\nWHERE Address IS NULL;\n\n实例2 IS NOT NULLSELECT LastName, FirstName, Address FROM Persons\nWHERE Address IS NOT NULL;\n","categories":["SQL"],"tags":["SQL","基础"]},{"title":"SQL学习：CONSTRAINTS","url":"/archives/eed05ae9.html","content":"约束介绍SQL 约束用于规定表中的数据规则。\n如果存在违反约束的数据行为，行为会被约束终止。\n约束可以在创建表时规定（通过 CREATE TABLE 语句）；\n或者在表创建之后规定（通过 ALTER TABLE 语句）。\n语法（CREATE TABLE + CONSTRAINT）CREATE TABLE table_name\n(\ncolumn_name1 data_type(size) constraint_name,\ncolumn_name2 data_type(size) constraint_name,\ncolumn_name3 data_type(size) constraint_name,\n....\n);\n\n在 SQL 中，有以下6个约束：\nNOT NULL          - 指示某列不能存储 NULL 值。\nUNIQUE            - 保证某列的每行必须有唯一的值，独一无二的值。\nPRIMARY KEY(主键) - NOT NULL和 UNIQUE的结合。确保某列（或两个列多个列的结合）有唯一标识，有助于更容易更快速地找到表中的一个特定的记录。\nFOREIGN KEY(外键) - 保证一个表中的数据匹配另一个表中的值的参照完整性。\nCHECK             - 保证列中的值符合指定的条件。\nDEFAULT           - 规定没有给列赋值时的默认值。\n\nNOT NULL 约束介绍在默认的情况下，表的列 是接受 NULL 值的，但NOT NULL约束强制该列不接受 NULL值，强制字段始终包含非空值。如果不向字段添加值，就无法插入或更新记录。\n实例1 创建表时定义not null约束下面的 SQL 语句强制 \"ID\" 列、 \"LastName\" 列以及 \"FirstName\" 列不能为NULL。\n\nCREATE TABLE Persons (\n    ID          int NOT NULL,\n    LastName    varchar(255) NOT NULL,\n    FirstName   varchar(255) NOT NULL,\n    Age         int\n);\n实例2 在已经存在的表中添加 NOT NULL 约束在已创建的Persons表的 \"Age\" 字段中 添加 NOT NULL 约束\n\nALTER TABLE Persons\nMODIFY Age int NOT NULL;\n实例3 删除 NOT NULL 约束在一个已创建的表的 \"Age\" 字段中删除 NOT NULL 约束\n\nALTER TABLE Persons\nMODIFY Age int NULL;\n\nUNIQUE 约束介绍\nUNIQUE 约束唯一标识数据库表中的每条记录。\n\nUNIQUE 和 PRIMARY KEY 约束均为列或列集合提供了唯一性的保证。\n\nPRIMARY KEY 约束拥有自动定义的 UNIQUE 约束。\n\n每个表可以有多个 UNIQUE 约束，但是每个表只能有一个 PRIMARY KEY 约束。\n\n\n实例1 创建表时的UNIQUE约束CREATE TABLE Persons\n(\nP_Id        int NOT NULL UNIQUE,       -- 直接说明了是UNIQUE -- \nLastName    varchar(255) NOT NULL,\nFirstName   varchar(255),\nAddress     varchar(255),\nCity        varchar(255)\n);\n命名 UNIQUE 约束，并定义多个列的 UNIQUE 约束\n\nCREATE TABLE Persons\n(\nP_Id        int NOT NULL,\nLastName    varchar(255) NOT NULL,\nFirstName   varchar(255),\nAddress     varchar(255),\nCity        varchar(255),\nCONSTRAINT  uc_PersonID UNIQUE (P_Id, LastName)\n);\n实例2 更改表时的UNIQUE约束表Persons已经存在，需要在P_ID列创建UNIQUE约束\nALTER TABLE Persons\nADD UNIQUE (P_ID);\n表Persons已经存在，需要重命名UNIQE 约束，并定义多个列的约束\nALTER TABLE Persons\nADD CONSTRAINT uc_PersonID (P_ID, LastName);\n\n实例3 撤销UNIQUE约束ALTER TABLE Persons\nDROP CONSTRAINT uc_Person_ID;\n\nPRIMARY KEY (主键) 约束介绍\nPRIMARY KEY约束 唯一标识数据库表中的每条记录。\n主键必须包含唯一的值。\n主键列不能包含 NULL 值。\n每个表都有且只能有一个主键。\n\n实例1 创建表时的PRIMARY 约束在 \"Persons\" 表创建时在 \"P_Id\" 列上创建 PRIMARY KEY 约束\nCREATE TABLE Persons(\nP_Id        int NOT NULL PRIMARY KEY,  -- 主键定义 -- \nLastName    varchar(255) NOT NULL,\nFirstName   varchar(255),\nAddress     varchar(255),\nCity        varchar(255)\n);\n在建表的同时命名 PRIMARY KEY 约束，并定义多个列的 PRIMARY KEY 约束\nCREATE TABLE Persons\n(\nP_Id        int NOT NULL,\nLastName    varchar(255) NOT NULL,\nFirstName   varchar(255),\nAddress     varchar(255),\nCity        varchar(255),\nCONSTRAINT  pk_PersonID PRIMARY KEY (P_Id,LastName)\n);\n实例2 更改表时的 PRIMARY 约束表Persons 已经被创建，需在 \"P_Id\" 列创建 PRIMARY KEY 约束\nALTER TABLE Persons\nADD PRIMARY KEY (P_Id);\n需要命名 PRIMARY KEY 约束，并定义多个列的 PRIMARY KEY 约束\nALTER TABLE Persons\nADD CONSTRAINT pk_PersonID PRIMARY KEY (P_Id,LastName);\n\n注意事项：使用 ALTER TABLE 语句添加主键的时候，必须把主键列声明为不包含 NULL 值（在表首次创建时）。\n\n实例3 撤销 PRIMARY KEY 约束ALTER TABLE Persons\nDROP CONSTRAINT pk_PersonID;\n\nFOREIGN KEY (外键约束)介绍\n一个表中的 FOREIGN KEY 指向另一个表中的 UNIQUE KEY。\nFOREIGN KEY 约束用于预防破坏表之间连接的行为。\nFOREIGN KEY 约束能防止非法数据插入外键列，因为它必须是它指向的那个表中的值之一。\n\n实例1 创建表时的 FOREIGN KEY 约束下面的 SQL 在 \"Orders\" 表创建时在 \"P_Id\" 列上创建 FOREIGN KEY 约束\n\nCREATE TABLE Orders\n(\nO_Id    int NOT NULL PRIMARY KEY,\nOrderNo int NOT NULL,\nP_Id    int FOREIGN KEY REFERENCES Persons(P_Id) -- 外键定义 -- \n); \n\n命名 FOREIGN KEY 约束，并定义多个列的 FOREIGN KEY 约束\n\nCREATE TABLE Orders\n(\nO_Id    int NOT NULL,\nOrderNo int NOT NULL,\nP_Id    int,\nPRIMARY KEY (O_Id),\nCONSTRAINT fk_PerOrders FOREIGN KEY (P_Id) REFERENCES Persons(P_Id) \n);\n实例2 修改表时的 FOREIGN KEY 约束已经创建\"Orders\"表，如果需要在 \"P_Id\" 列创建 FOREIGN KEY 约束\n\nALTER TABLE Orders\nADD FOREIGN KEY (P_Id) REFERENCES Persons(P_Id); -- 外键定义 -- \n命名 FOREIGN KEY 约束，并定义多个列的 FOREIGN KEY 约束\n\nALTER TABLE Orders\nADD CONSTRAINT fk_PerOrders FOREIGN KEY (P_Id) REFERENCES Persons(P_Id);\n\n实例3 撤销 FOREIGN KEY 约束ALTER TABLE Orders\nDROP CONSTRAINT fk_PerOrders\n\n在创建外键约束时，必须先创建外键约束所依赖的表，并且该列为该表的主键\n\nnotes：\n子表：谁创建外键谁就是子表\n\n父表：这个外键所依赖的表\n\n\nCHECK 约束介绍CHECK 约束用于限制列中的值的范围。\n如果对单个列定义CHECK约束，那么该列只允许存在特定的值。\n如果对一个表定义CHECK约束，那么此约束会基于行中其他列的值在特定的列中对值进行限制。\n实例1 创建表时的 CHECK 约束要求： 创建\"Persons\" 时，在 \"P_Id\" 列上创建 CHECK 约束。\nCHECK 约束规定 \"P_Id\" 列只能存在大于 0 的整数。\nCREATE TABLE Persons\n(\nP_Id        int             NOT NULL CHECK (P_Id > 0), -- check定义 --\nLastName    varchar(255)    NOT NULL,\nFirstName   varchar(255),\nAddress     varchar(255),\nCity        varchar(255)\n);\n\n命名 CHECK 约束，并定义多个列的 CHECK 约束\nCREATE TABLE Persons\n(\nP_Id        int NOT NULL,\nLastName    varchar(255)    NOT NULL,\nFirstName   varchar(255),\nAddress     varchar(255),\nCity        varchar(255),\nCONSTRAINT  chk_Person CHECK (P_Id > 0 AND City = 'QingDao')\n)\n\n实例2 修改表时的 CHECK 约束Person表已创建，在 \"P_Id\" 列创建 CHECK 约束\nALTER TABLE Persons\nADD CHECK (P_Id > 0); \n命名 CHECK 约束，并定义多个列的 CHECK 约束\nALTER TABLE Persons\nADD CHECK chk_Person CHECK (P_Id > 0 AND City = 'Sandnes');\n\n实例3 撤销 CHECK 约束ALTER TABLE Persons\nDROP CONSTRAINT chk_Person;\n\nDEFAULT 约束介绍DEFAULT 约束用于向列中插入默认值。如果没有规定其他的值，那么会将默认值添加到所有的新记录。\n实例1 创建表时的DEFAULT约束创建\"Persons\" 表时，在 \"City\" 列上创建 DEFAULT 约束\nCREATE TABLE Persons\n(\n    P_Id        int NOT NULL,\n    LastName    varchar(255)    NOT NULL,\n    FirstName   varchar(255),\n    Address     varchar(255),\n    City        varchar(255)    DEFAULT 'QingDao' -- DEFAULT约束定义 -- \n);\n\n实例2 创建表时的DEFAULT约束Persons表已经被创建，在 \"City\" 列创建 DEFAULT 约束\n\nALTER TABLE Person\nMODIFY City DEFAULT 'QingDao'; \n实例3 创建表时的DEFAULT约束ALTER TABLE Persons\nALTER COLUMN City DROP DEFAULT;","categories":["SQL"],"tags":["SQL","操作符"]},{"title":"SQL学习：增删改查","url":"/archives/df88b555.html","content":"SELECT简介\nSELECT 语句用于从数据库中选取数据。\n结果被存储在一个结果表中，称为结果集。\n语法SELECT column_name,column_name\nFROM table_name;\n\n\n\n实例SELECT name,country FROM Store;\n\nSELECT DISTINCT简介\n在表中，一个列可能会包含多个重复值，有时也许希望仅仅列出不同（distinct）的值。\nDISTINCT 关键词用于返回唯一不同的值。\n\n语法SELECT DISTINCT column_name,column_name\nFROM table_name;\n\nWHERE\nWHERE 子句用于过滤记录。\n用于提取满足指定条件的记录。\n\n语法SELECT column_name,column_name\nFROM table_name\nWHERE column_name operator value;\n\n实例SELECT * FROM Store WHERE country&#x3D;&#39;China&#39;;\nSQL 中的opreator运算符\n\n\n运算符\n含义\n\n\n\n=\n等于\n\n\n&lt;&gt; or !=\n不等于\n\n\n&gt;\n大于\n\n\n&lt;\n等于\n\n\n&gt;=\n大于等于\n\n\n&lt;=\n小于等于\n\n\nis null\n空值\n\n\nBETWEEN\n在某个范围内\n\n\nLIKE\n搜索某种模式\n\n\nIN\n指定针对某个列的多个可能值\n\n\nexamples:\n\nSelect * from emp where comm is null;\nSelect * from emp where sal between 1500 and 3000;\nSelect * from emp where sal in (5000,3000,1500);\nSelect * from emp where ename like &#39;M%&#39;;\n查询 EMP 表中 Ename 列中有 M 的值，M 为要查询内容中的模糊信息。\n% 表示多个字值，_ 下划线表示一个字符；\nM% : 为能配符，正则表达式，表示的意思为模糊查询信息为 M 开头的。\n%M% : 表示查询包含M的所有内容。\n%M_ : 表示查询以M在倒数第二位的所有内容。\n\n\n\n## 补充\n\n\n\n+ SQL 使用单引号来环绕文本值。\n\n\n\n+ 如果是数值字段，不能使用引号。\n\n\n\nAND 和 OR 运算符简介AND 和 OR 运算符用于基于一个以上条件对记录进行过滤。\nAND如果第一个条件和第二个条件都成立，则 AND 运算符显示一条记录。\nOR 运算符如果第一个条件和第二个条件中只要有一个成立，则 OR 运算符显示一条记录。\n实例只用AND：\nSELECT * FROM Store\nWHERE country&#x3D;&#39;China&#39;\nAND price &gt; 50;\n\n只用OR：\nSELECT * FROM Store\nWHERE country&#x3D;&#39;China&#39;\nOR country&#x3D;&#39;Serbia&#39;;\n\n混合使用AND和OR：\nSELECT * FROM Store\nWHERE price &gt; 15\nAND (country&#x3D;&#39;China&#39; OR country&#x3D;&#39;Serbia&#39;);\n\nORDER BY简介用于对结果集按照一个列或者多个列进行排序。默认按照升序，使用DESC关键词可以实现降序。\n语法SELECT column_name,column_name\nFROM table_name\nORDER BY column_name1, column_name2 ASC|DESC;\n按照多个列名的顺序来一步步进行排序，如上述例子中，先按照column _ name1进行排序得到若干小组，然后在这些小组中按照column _ name2进行排序。得到最终的结果\nINSERT INTO简介用于向表中插入记录\n语法1.不指定要插入数据的列名，只需提供被插入的值即可，此时需要列出新一行的每一列数据：\nINSERT INTO table_name\nVALUES (value1,value2,value3,...);\n2.指定列名及被插入的值：\nINSERT INTO table_name (column1,column2,column3,...)\nVALUES (value1,value2,value3,...);\n\n实例INSERT INTO Store (name, url, price, country)\nVALUES (&#39;RY&#39;,&#39;https:&#x2F;&#x2F;www.baidu.com&#x2F;&#39;,&#39;520&#39;,&#39;China&#39;);\n\nUPDATE简介用于更新表中已经存在的记录\n语法UPDATE table_name \nSET column1 &#x3D; value1, column2 &#x3D; value2,……\nWHERE some_column_name &#x3D; some_concrete_value;\n\n实例UPDATE Store \nSET price&#x3D;&#39;500&#39;, country&#x3D;&#39;CHINA&#39; \nWHERE name&#x3D;&#39;拓展坞&#39;;\n补充慎重执行没有 WHERE 子句的 UPDATE，不然很肯将表中所有数据都按照SET（或其他关键词）的内容给修改掉。\nDELETE简介用于删除表中的行（记录）\n语法DELETE FROM table_name\nWHERE some_column_name &#x3D; some_concrete_value;\n\n实例DELETE FROM Store\nWHERE name&#x3D;&#39;笔记本&#39; AND price&#x3D;&#39;4999&#39;;\n补充管理员可以在不删除表的情况下，删除表中所有的行。这意味着表结构、属性、索引将保持不变：\nDELETE FROM table_name;\n或者\nDELETE * FROM table_name;\n但是在删除记录时要小心，因为无法撤销操作。\n","categories":["SQL"],"tags":["SQL","基础"]},{"title":"SQL学习：SELECT INTO、INSERT INTO SELECT、CREATE DATABASE、CREATE TABLE","url":"/archives/1eee7cd5.html","content":"SELECT INTO介绍可以从一个表复制数据，然后把数据插入到另一个新表中。\n语法SELECT * \nINTO table2 [IN externable]\nFROM table1\n或\nSELECT　column_name(s)\nINTO table2 [IN externaldb]\nFROM table1\n\n实例1 创建website 表的备份SELECT *\nINTO WebsitesBackup2020\nFROM Websites\n实例2 只复制一些列插入到新表中SELECT name, url\nINTO WebsitesBackup2020\nFROM Websites;\n\n实例3 只复制中国的网站插入到新表中SELECT *\nINTO WebsitesBackup2020\nFROM Websites\nWHERE country = 'China';\n实例4 复制多个表中的数据插入到新表中SELECT Websites.name, access_log.count, access_log.date\nINTO WebsitesBackup2020\nFROM Websites\nLEFT JOIN access_log\nON Websites.id=access_log.site_id;\n\nINSERT INTO SELECT介绍可以从一个表复制数据，然后把数据插入到一个已存在的表中。目标表中任何已存在的行都不会受影响。\n语法可以从一个表中复制 所有的列 插入到另一个已存在的表中\nINSERT INTO table2\nSELECT * FROM table1;\n可以从一个表中复制 特定的列 插入到另一个已存在的表中\nINSERT INTO table2 (column_name(s))\nSELECT column_name(s)\nFROM table1;\n实例1 复制APP中的数据插入到Websites中INSERT INTO Websites (name, country)\nSELECT app_name, country FROM apps;\n\n实例2 复制 id 是 1 的 APP 到 “Websites” 中INSERT INTO Websites (name, country)\nSELECT app_name, country FROM apps\nWHERE id=1;\n\nnoteselect into from 和 insert into select 都是用来复制表\n两者的主要区别为： \n\nselect into from 要求目标表不存在，因为在插入时会自动创建；\ninsert into select from 要求目标表存在。\n\nCreate Database介绍创建数据库\n语法CREATE DATABASE database_name;\n实例CREATE DATABASE Store;\nCreate Table介绍创建表\n语法CREATE TABLE table_name\n(\ncolumn_name1 data_type(size),\ncolumn_name2 data_type(size),\ncolumn_name3 data_type(size),\n....\n);\n实例CREATE TABLE Store\n(\ngools_id    int,\ngoods_name  varchar(255),\ngoods_country varchar(255),\ngoods_price varchar(255),\n);","categories":["SQL"],"tags":["SQL","操作符"]},{"title":"SQL学习：JOIN 操作符","url":"/archives/94deee3b.html","content":"JOIN（连接）总介绍把两个或多个表的行连接起来有左连接，右连接，全连接，内连接，外连接等七个\n不同的 JOIN\nINNER JOIN：如果表中有至少一个匹配，则返回行\nLEFT JOIN：即使右表中没有匹配，也从左表返回所有的行\nRIGHT JOIN：即使左表中没有匹配，也从右表返回所有的行\nFULL JOIN：只要其中一个表中存在匹配，则返回行\n\n\n连接的结果可以在逻辑上看作是由SELECT语句指定的列组成的新表。\n\n\n左连接与右连接的左右指的是以两张表中的哪一张为基准，它们都是外连接。\n\n\n外连接就好像是为非基准表添加了一行全为空值的万能行，用来与基准表中找不到匹配的行进行匹配。假设两个没有空值的表进行左连接，左表是基准表，左表的所有行都出现在结果中，右表则可能因为无法与基准表匹配而出现是空值的字段。这部分主要涉及的是表连接的逻辑问题。\n\n\nINNER JOIN（简单的 JOIN） 最常见的 JOIN 类型介绍INNER JOIN 关键字在表中存在至少一个匹配时返回行。\n语法SELECT column_name(s)\nFROM table1\nINNER JOIN table2\nON table1.column_name=table2.column_name;\n或\nSELECT column_name(s)\nFROM table1\nJOIN table2\nON table1.column_name=table2.column_name;\n\n\n\nnote:\n\nINNER JOIN 与 JOIN 是相同的INNER JOIN 关键字在表中存在至少一个匹配时返回行。如果 “table1” 表中的行在 “table2” 中没有匹配，则不会列出这些行。\n实例SELECT Websites.name, access_log.count, access_log.date\nFROM Websites\nINNER JOIN access_log\nON Websites.id=access_log.site_id\nORDER BY access_log.count;\n\n在使用 join 时，on 和 where 条件的区别如下：\n1.on 条件是在生成临时表时使用的条件，它不管 on 中的条件是否为真，都会返回左边表中的记录。\n2.where 条件是在临时表生成好后，再对临时表进行过滤的条件。这时已经没有 left join 的含义（必须返回左边表的记录）了，条件不为真的就全部过滤掉。\n\nLEFT JOIN(左连接)介绍LEFT JOIN 关键字从左表（table1）返回所有的行，即使右表（table2）中没有匹配。如果右表中没有匹配，则结果为 NULL。\n语法SELECT column_name(s)\nFROM table1\nLEFT JOIN table2\nON table1.column_name=table2.column_name;\n或：\nSELECT column_name(s)\nFROM table1\nLEFT OUTER JOIN table2\nON table1.column_name=table2.column_name;\n\n实例SELECT Websites.name, access_log.count, access_log.date\nFROM Websites\nLEFT JOIN access_log\nON Websites.id=access_log.site_id\nORDER BY access_log.count DESC;\n\nRIGHT JOIN(右连接)介绍RIGHT JOIN 关键字从右表（table2）返回所有的行，即使左表（table1）中没有匹配。如果左表中没有匹配，则结果为 NULL。\n语法SELECT column_name(s)\nFROM table1\nRIGHT JOIN table2\nON table1.column_name=table2.column_name;\n或：\nSELECT column_name(s)\nFROM table1\nRIGHT OUTER JOIN table2\nON table1.column_name=table2.column_name;\n实例SELECT Websites.name, access_log.count, access_log.date\nFROM access_log\nRIGHT JOIN Websites\nON access_log.site_id=Websites.id\nORDER BY access_log.count DESC;\n\nFULL OUTER JOIN(全外连接)介绍FULL OUTER JOIN 关键字只要左表（table1）和右表（table2）其中一个表中存在匹配，则返回行.简言之：FULL OUTER JOIN 关键字结合了 LEFT JOIN 和 RIGHT JOIN 的结果。\n语法SELECT column_name(s)\nFROM table1\nFULL OUTER JOIN table2\nON table1.column_name=table2.column_name;\n\n实例SELECT Websites.name, access_log.count, access_log.date\nFROM Websites\nFULL OUTER JOIN access_log\nON Websites.id=access_log.site_id\nORDER BY access_log.count DESC;\n\n\nnote：FULL OUTER JOIN 关键字返回左表（Websites）和右表（access_log）中所有的行。如果 “Websites” 表中的行在 “access_log” 中没有匹配或者 “access_log” 表中的行在 “Websites” 表中没有匹配，也会列出这些行。\n\n","categories":["SQL"],"tags":["SQL","操作符"]},{"title":"SQL学习：BETWEEN、AS、UNION 操作符","url":"/archives/ceb130af.html","content":"BETWEEN 操作符介绍sql操作符用于选取介于两个值之间的数据范围内的值。这些值可以是数值、文本或者日期。\n语法SELECT column_name(s)\nFROM table_name \nWHERE column_name BETWEEN value1 AND value2;\n\n实例1 BRTWEEN下面的 SQL 语句选取 价格（price） 介于 1 和 20 之间的所有商品\nSELECT * \nFROM Store \nWHERE price BETWEEN 1 AND 49;\n\n实例2 NOT BETWEEN下面的 SQL 语句选取 价格（price） 不在 1 和 20 之间的所有商品\nSELECT * \nFROM Store \nWHERE price NOT BETWEEN 1 AND 49;\n\n实例3 混合使用下面的SQL语句选取价格peice在1 和 20 之间并且产地country不是中国也不是印度的所有商品\nSELECT * FROM Store\nWHERE (price BETWEEN 1 AND 20)\nAND country NOT IN ('China', 'India');\n\n带有文本值的 BETWEEN 操作符实例下面的 SQL 语句选取 name 以介于 'A' 和 'H' 之间字母作为起始字母的所有商品\nSELECT * FROM Store\nWHERE name BETWEEN 'A' AND 'H';\n\n带有日期值的 BETWEEN 操作符实例下面的 SQL 语句选取 入库日期 介于 '2020-07-08' 和 '2020-07-27' 之间的所有商品\nSELECT * FROM Store\nWHERE date BETWEEN '2020-07-08' AND '2020-07-27';\n\nAS（别名）介绍通过使用AS，可以为表名称或列名称指定别名。使用别名是为了增强列名的可读性。\n语法表名：SELECT column_name(s)\nFROM table_name AS alias_name;\n列名SELECT column_name AS alias_name\nFROM table_name;\n\nnote:如果列名称包含空格，要求使用双引号或方括号\n\n表的别名实例1下面的 SQL 语句选取 \"电子商城\" 的所访问记录。我们使用 \"Store\" 和 \"access_log\" 表，并分别为它们指定表别名 \"s\" 和 \"a\"\n\nSELECT s.name, s.url, a.count, a.date\nFROM Store AS s, access_log AS a\nWHERE a.site_id=s.id and s.name=\"牛轧糖\";\n\n通过使用别名，可以使 SQL 语句更简短\n\n对比：\n不带别名的相同的 SQL 语句\nSELECT Websites.name, Websites.url, access_log.count, access_log.date\nFROM Websites, access_log\nWHERE Websites.id=access_log.site_id and Websites.name=\"牛轧糖\";\n\n\n列的别名实例1下面的 SQL 语句指定了两个别名，一个是 name 列的别名 n，一个是 proce 列的别名p\n\nSELECT name AS n, price AS p\nFROM store;\n\n列的别名实例2在下面的 SQL 语句中，把三个列（购买链接url、价格price 和 产地country）结合在一起，并创建一个名为 \"gools_info\" 的别名\n\nSELECT name, CONCAT(url, ', ', price, ', ', country) AS site_info\nFROM Store;\n\n在下面的情况下，使用别名很有用：\n在查询中涉及超过一个表\n在查询中使用了函数\n列名称很长或者可读性差\n需要把两个列或者多个列结合在一起\n\nUNION介绍用于合并两个或多个SELECT 语句的结果集。\nUNION 内部的每个 SELECT语句必须拥有相同数量的列。列也必须拥有相似的数据类型。同时，每个 SELECT 语句中的列的顺序必须相同。\n语法(UNION)SELECT column_name(s) FROM table1\nUNION\nSELECT column_name(s) FROM table2;\n注释：UNION 操作符默认选取不同的值。如果允许重复的值，需要使用 UNION ALL。\n语法(UNION ALL)SELECT column_name(s) FROM table1\nUNION ALL\nSELECT column_name(s) FROM table2;\n注释：UNION 结果集中的列名总是等于 UNION 中第一个 SELECT 语句中的列名。\n\n实例(UNION)SELECT country FROM Websites\nUNION\nSELECT country FROM apps\nORDER BY country;\n实例(UNION ALL)SELECT country FROM Websites\nUNION ALL\nSELECT country FROM apps\nORDER BY country;\n注释：UNION ALL可以筛选出重复的值\n实例(带有 WHERE 的 SQL UNION ALL)下面的 SQL 语句使用 UNION ALL 从 “Websites” 和 “apps” 表中选取所有的中国(CN)的数据（包含重复的值）\nSELECT country, name FROM Websites\nWHERE country='China'\nUNION ALL\nSELECT country, app_name FROM apps\nWHERE country='China'\nORDER BY country;","categories":["SQL"],"tags":["SQL","操作符"]},{"title":"SQL学习：SELECT TOP, LIMIT, ROWNUM 子句、LIKE、IN","url":"/archives/b34bf9ab.html","content":"SELECT TOP, LIMIT, ROWNUM 子句介绍SELECT TOP 子句用于规定要返回的记录的数目。\nSELECT TOP 子句对于拥有数千条记录的大型表来说，是非常有用的。** notes **:不是所有的数据库系统都支持 SELECT TOP 语句。MySQL 支持 LIMIT 语句来选取指定的条数数据， Oracle 可以使用 ROWNUM 来选取。\n\n语法SELECT column_name(s)\nFROM table_name\nWHERE ROWNUM &lt;= number;\n\n实例SELECT * \nFROM Store\nWHERE ROWNUM &lt;= 5;\n\nSQL 通配符介绍通配符可以用于替代字符串中的任何其他字符。\n在SQL中，通配符与SQL LIKE操作符一起使用。SQL通配符用于搜索表中的数据\n在SQL中，可以使用以下通配符\n\n\n通配符\n含义\n\n\n\n%\n替代0个或者多个字符\n\n\n_\n替代一个字符\n\n\n[charlist]\n字符中的任何单一字符\n\n\n[^charlist] 或 [!charlist]\n不在字符列中的任何单一字符\n\n\n实例1%\nSELECT * FROM Store\nWHERE url LIKE 'https%'\n该SQL 语句选取 url 以字母 \"https\" 开始的所有商品。\n实例2%\nSELECT * FROM Store\nWHERE url LIKE &#39;%oo%&#39;\n该SQL 语句选取 url 包含模式 &quot;oo&quot; 的所有商品。\n\n实例3_\nSELECT * Store\nFROM Websites\nWHERE name LIKE '_gle';\n该SQL 语句选取 name 以一个任意字符开始，然后是 \"gle\" 的所有商品。\n\n实例4_\nSELECT * FROM Store\nWHERE name LIKE 'G_o_le';\n该 SQL 语句选取 name 以 \"G\" 开始，然后是一个任意字符，然后是 \"o\"，然后是一个任意字符，然后是 \"le\" 的所有商品。\n\n实例5[charlist] \nMySQL 中使用 REGEXP 或 NOT REGEXP 运算符 (或 RLIKE 和 NOT RLIKE) 来操作正则表达式。\n\nSELECT * FROM Store\nWHERE name REGEXP '^[GFs]';\n该 SQL 语句选取 name 以 \"G\"、\"F\" 或 \"s\" 为开头的所有商品：\n实例6[charlist]\nSELECT *\nFROM Store\nWHERE name REGEXP '^[A-H]';\n该SQL语句选取name以A到H字母开头的所有商品。\n\n实例7[^charlist]\nSELECT *\nFROM Store\nWHERE name REGEXP '^[A-H]';\n该SQL语句选取name以A到H字母开头的所有商品。\n\nLIKE 操作符介绍LIKE 操作符用于在 WHERE 子句中 搜索 列中的 指定模式。\n语法SELECT *\nFROM table_name\nWHERE column_name LIKE pattern;\n\n实例1SELECT * \nFROM Store\nWHERE name LIKE 'S%';\n\n该SQL 语句选取 name 以字母 \"S\" 开头的所有客户\n\n实例2SELECT * \nFROM Websites\nWHERE name LIKE '%k';\n\n该SQL 语句选取 name 以字母 \"k\" 结尾的所有客户\n\n实例3SELECT *\nFROM Store\nWHERE name LIKE %ry%;\n\n该SQL 语句选取 name 包含模式 \"ry\" 的所有客户：\n\nnote通过使用 NOT 关键字，您可以选取不匹配模式的记录。\n实例4SELECT *\nFROM Store\nWHERE name NOT LIKE %ry%;\n\nIN 操作符介绍IN 操纵符允许在WHERE子句中规定多个值\n语法SELECT column_name(s)\nFROM table_name\nWHERE column_name IN (value1,value2,...);\n\n实例SELECT * FROM Store\nWHERE name IN ('西瓜','苹果');\n\n该 SQL 语句选取 name 为 \"西瓜\" 或 \"苹果\" 的所有网站\n","categories":["SQL"],"tags":["SQL","基础"]},{"title":"LeetCode精选TOP面试题26.删除排序数组中的重复项","url":"/archives/501582a6.html","content":"题目描述给定一个排序数组，你需要在 原地 删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。不要使用额外的数组空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。\nexample1:\ninput  : [1,1,2] \noutput : [1,2]\nnote   : 函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。 \nexample2:\ninput  : [0,0,1,1,1,2,2,3,3,4]\noutput : [0,1,2,3,4]\nnote   : 函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。\n\n解题思路思路双指针遍历，一个指针i用于遍历数组，另一个指针len用于修改数组。当前元素的值num[i]与其前一个元素的值num[i-1]不相等的时候，num[len]的值更新为num[i]，以此实现对数组的修改。\n代码（Java）class Solution &#123;\n    public int removeDuplicates(int[] nums) &#123;\n        int len = 1;\n        for (int i = 1; i &lt; nums.length; i++)&#123; // 下标从1开始是为了访问i-1时防止出现溢出。\n            if (nums[i] != nums[i-1])&#123;\n                nums[len ++] = nums[i];\n            &#125;\n        &#125;\n        return len;\n    &#125;\n&#125;\n","categories":["LeetCode"],"tags":["Java","LeetCode","面试","数组","遍历"]},{"title":"LeetCode精选TOP面试题53.最大子序和","url":"/archives/4c4d07ae.html","content":"题目描述给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。\nexample:\ninput : -2,1,-3,4,-1,2,1,-5,4\noutput: 6\nnote  : 连续子数组 [4,-1,2,1] 的和最大，为 6\n\n解题思路思路1\n动态规划 – 时间复杂度O(N), 空间复杂度O(1)\n\n（1）从下标1开始遍历数组，当前元素item的前一个元素pre若大于0，则item更新为item+pre，否则继续遍历。\n（2）在遍历过程中比使用Math.max(max, item)函数对比当前最大值和item值的大小以确定最终的最大和。\n\n思路2\n贪心算法 – 时间复杂度O(N), 空间复杂度O(1)\n\n若当前元素之前的元素序列之和小于0，则舍弃这个“和”\n定义temp用于比较“当前元素”与“当前元素之前的元素序列之和”谁更大\n\n思路3\n分治法 – 时间复杂度O(N), 空间复杂度O(logN)这个思路是查看官方题解才了解的，并不是最优的算法，最优算法依然是动态规划，但是并没有理解透彻，所以就不在这里做不准确的解释了。详细内容请到Leetcode官方题解中学习。\n代码（Java）思路1代码\npublic class Solution2 &#123;\n    public int maxSubArray(int[] nums)&#123;\n        int max = nums[0];\n        for (int i = 1; i &lt; nums.length; i++)&#123;\n            if (nums[i-1] > 0)&#123;\n                nums[i] += nums[i-1];       // 当前元素item[i]的前驱元素item[i-1]>0,更新当前元素的值\n            &#125;\n            max = Math.max(nums[i], max);   // 确定目前为止的最大值\n        &#125;\n\n        return max;\n    &#125;\n&#125;\n思路2代码\npublic class Solution &#123;\n    public int maxSubArray(int[] nums)&#123;\n        int temp = nums[0];\n        int max = nums[0];\n        for (int i = 1; i &lt; nums.length; i++)&#123;\n            temp = Math.max(nums[i], temp + nums[i]); // 等价于比较“当前元素”与“当前元素之前的元素序列之和”谁更大\n                                                      // temp = Math.max(0, temp);\n            max = Math.max(temp, max);                // 确定临时最大值\n        &#125;\n        return max;\n    &#125;\n&#125;","categories":["LeetCode"],"tags":["Java","LeetCode","面试","动态规划","贪心算法"]},{"title":"LeetCode精选TOP面试题38.外观数列","url":"/archives/ba31be9f.html","content":"题目描述「外观数列」是一个整数序列，从数字 1 开始，序列中的每一项都是对前一项的描述。前五项如下：\n1.   1\n2.   11\n3.   21\n4.   1211\n5.   111221\n1  被读作  \"one 1\"  (\"一个一\") , 即 11。\n11 被读作 \"two 1s\" (\"两个一\"）, 即 21。\n21 被读作 \"one 2\",  \"one 1\" （\"一个二\" ,  \"一个一\") , 即 1211。\n给定一个正整数 n（1 ≤ n ≤ 30），输出外观数列的第 n 项。\n注意：整数序列中的每一项将表示为一个字符串。\n\n示例 1:\n输入: 1\n输出: \"1\"\n解释：这是一个基本样例。\n\n示例 2:\n输入: 4\n输出: \"1211\"\n解释：当 n = 3 时，序列是 \"21\"，其中我们有 \"2\" 和 \"1\" 两组，\"2\" 可以读作 \"12\"，也就是出现频次 = 1 而 值 = 2；类似 \"1\" 可以读作 \"11\"。所以答案是 \"12\" 和 \"11\" 组合在一起，也就是 \"1211\"。\n解题思路\n借助StringBuilder ，方便在循环中进行拼接操作，初始化一个StringBuilder类型的对象为 “ 1 “；\n当输入的整数n &gt; 1 时，进行第一层循环，次数为 n - 1 次，每次循环得到的StringBuilder类型的临时结果，即对上一层数字解释；\n嵌套的第二层循环需要完成对上一层数值的统计工作\n初始化获取当前字符串的首字符 ch，向后遍历，相等则计数器count + 1 ， 不相等则将计数器count 和 字符 ch 追加到临时StringBuilder对象temp中，然后 ch 更新为当前字符，计数器count 重置为1；\n每次内层循环结束时，计数器 count 和 字符 ch 追加到临时StringBuilder对象temp中，然后将temp赋值给初始的str；\n\n\n最后返回的str.toString()就是想要的结果。代码实现（Java）/**\n * @author : flower48237\n * @2020/3/25 21:20\n * @title : LeetCode精选TOP面试题38.外观数列\n */\npublic class Solution &#123;\n    public String countAndSay(int n)&#123;\n        StringBuilder str = new StringBuilder(\"1\");\n        for (int i = 2; i &lt;= n; i ++)&#123;\n            StringBuilder temp = new StringBuilder();\n            int count = 1;\n            char ch = str.charAt(0);\n            for (int j = 1; j &lt; str.length(); j ++)&#123;\n                if (str.charAt(j) == ch) &#123;\n                    count++;\t// 计数器加一\n                &#125; else &#123;\n                    temp.append(\"\" + count + ch);\t// 追加对上一串数值的部分描述\n                    ch = str.charAt(j);\t\t\t\t// 更新ch\n                    count = 1;\t\t\t\t\t\t// 重制计数器count 为 1\n                &#125;\n            &#125;\n            temp.append(\"\" + count + ch);\t// 追加对上一串数值的最后一部分描述\n            str = temp;\t\t\t\t\t\t// 将每次的描述结果赋值给str\n        &#125;\n        return str.toString();\n    &#125;\n&#125;\n\n\n","categories":["LeetCode"],"tags":["Java","LeetCode","面试","字符串","数据结构"]},{"title":"LeetCode精选TOP面试题160.相交链表","url":"/archives/2749d354.html","content":"题目描述编写一个程序，找到两个单链表相交的起始节点。返回值是ListNode类型。示例 1：\n输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], \n\t skipA = 2, skipB = 3\n输出：Reference of the node with value = 8\n输入解释：相交节点的值为 8 （注意，如果两个列表相交则不能为 0）。\n\t\t从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,0,1,8,4,5]。\n\t\t在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。\n\n示例 2：\n输入：intersectVal = 2, listA = [0,9,1,2,4], listB = [3,2,4], \n\t skipA = 3, skipB = 1\n输出：Reference of the node with value = 2\n输入解释：相交节点的值为 2 （注意，如果两个列表相交则不能为 0）。\n\t\t从各自的表头开始算起，链表 A 为 [0,9,1,2,4]，链表 B 为 [3,2,4]。\n\t\t在 A 中，相交节点前有 3 个节点；在 B 中，相交节点前有 1 个节点。\n\n示例 3：\n输入：intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2\n输出：null\n输入解释：从各自的表头开始算起，链表 A 为 [2,6,4]，链表 B 为 [1,5]。\n\t\t由于这两个链表不相交，所以 intersectVal 必须为 0，\n\t\t而 skipA 和 skipB 可以是任意值。\n解释：这两个链表不相交，因此返回 null。\n\n要求：\n\n如果两个链表没有交点，返回 null.\n在返回结果后，两个链表仍须保持原有的结构。\n可假定整个链表结构中没有循环。\n程序尽量满足 O(n) 时间复杂度，且仅用 O(1) 内存。\n\n解题思路\n分别遍历两个链表，统计两个链表各自的长度lenA和lenB；\n先对较长的链表进行遍历，向前遍历 | lenA - lenB | 次；\n然后利用while循环同时遍历两个链表：  + 如果遍历过程中找到两个链表的结点完全相等，那么返回这个结点；\n  + 如果遍历结束依然没有返回某个结点，那么就说明这两个链表不相交，返回null。\n\n时间复杂度 O(m + n)空间复杂度 O(1)\n代码实现（Java）package it160.getIntersectionNode;\n\nimport sun.nio.cs.ext.MacArabic;\n\n/**\n * @author : flower48237\n * @2020/3/27 9:52\n * @title : LeetCode精选TOP面试题160.相交链表\n */\n/**\n * 输入示例\n * 8\n *   [4,1,8,4,5]\n * [5,0,1,8,4,5]\n * 2\n * 3\n */\npublic class Solution &#123;\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) &#123;\n        int lenA = 0, lenB = 0; // 用来记录两个链表的长度\n        ListNode p = headA;\t\t\n        while (p != null)&#123;\n            lenA ++;\t\t\t// 得到链表A的长度\n            p = p.next;\n        &#125;\n        p = headB;\t\t\t\t\n        while (p != null)&#123;\n            lenB++;\t\t\t\t// 得到链表B的长度\n            p = p.next;\n        &#125;\n        if (lenA &lt; lenB)&#123;\t\t// B 更长\n            for (int i = 0; i &lt; lenB - lenA; i ++)&#123;\n            \t// 先对长的链表B遍历 lenB - lenA 次\n                headB = headB.next;\n            &#125;\n            while (headA != null &amp;&amp; headB != null)&#123;\n                if (headA == headB)&#123;\n                \t// 找到两个链表中完全相同的结点并返回\n                    return headA;\n                &#125;\n                headA = headA.next;\n                headB = headB.next;\n            &#125;\n        &#125;else &#123;\t\t\t\t\t// A 更长 或者 A 与 B 等长\n            for (int i = 0; i &lt; lenA - lenB; i ++)&#123;\n            \t// 先对长的链表B遍历 lenA - lenB 次\n                headA = headA.next;\n            &#125;\n            while (headA != null &amp;&amp; headB != null)&#123;\n                if (headA == headB)&#123;\n                \t// 找到两个链表中完全相同的结点并返回\n                    return headA;\n                &#125;\n                headA = headA.next;\n                headB = headB.next;\n            &#125;\n        &#125;\n        return null; // 不想交\n    &#125;\n&#125;\n\n","categories":["LeetCode"],"tags":["Java","LeetCode","数据结构","链表"]},{"title":"LeetCode精选TOP面试题268.缺失数字","url":"/archives/51e476ee.html","content":"题目回忆给定一个包含 0, 1, 2, …, n 中 n 个数的序列，找出 0 .. n 中没有出现在序列中的那个数。\n\n示例 1:\n输入: [3,0,1]\n输出: 2\n示例 2:\n输入: [9,6,4,2,3,5,7,0,1]\n输出: 8\n算法应具有线性时间复杂度。考虑只使用额外常数空间来实现。\n解题思路\n思路1：数学方法，简单粗暴找缺失的数，那我把1，2，3，···，n的累加和求出来，再把数组的累加和求出来，做个差就好了；\n思路2：关系判断判断下标1~n的元素是否等于其前一个元素值+1，不是就说明缺失了前一个元素值+1所代表的这个数字；\n思路3：借助哈希Set先把数组中的元素存入HashSet中，再遍历整数序列0，1，2，···，n，当存在某个元素item不被HashSet包含时，就返回这个元素item。代码实现（Java）\n\nimport java.util.HashSet;\nimport java.util.Set;\n/**\n * @author : flower48237\n * @2020/3/18 21:41\n * @title : LeetCode精选TOP面试题268.缺失数字\n */\npublic class Solution &#123;\n    public int missingNumber(int[] nums) &#123;\n        // 法 1\n        int sum = 0;\n        int stdsum = 0;\n        for (int i = 0; i &lt; nums.length; i++) &#123;\n            sum += nums[i];\n            stdsum += i + 1;\n        &#125;\n        return stdsum - sum;\n\n        // 法 2\n        Arrays.sort(nums);\n        // 判断 n 是否出现在末位\n        if (nums[nums.length-1] != nums.length) &#123;\n            return nums.length;\n        &#125;\n        // 判断 0 是否出现在首位\n        else if (nums[0] != 0) &#123;\n            return 0;\n        &#125;\n        // 此时缺失的数字一定在 (0, n) 中\n        for (int i = 1; i &lt; nums.length; i++) &#123;\n            if (nums[i] != nums[i-1] + 1) &#123;\n                return nums[i-1] + 1;\n            &#125;\n        &#125;\n        // 未缺失任何数字（保证函数有返回值）\n        return -1;\n\n        // 法 3\n        Set&lt;Integer> set = new HashSet&lt;Integer>();\n        for (int n : nums)&#123;\n            set.add(n);\n        &#125;\n        for (int i = 0; i &lt;= nums.length; i++)&#123;\n            if (!set.contains(i))&#123;\n                return i;\n            &#125;\n        &#125;\n        return -1;\n    &#125;\n&#125;\n\n","categories":["LeetCode"],"tags":["Java","数值计算","LeetCode","数组","遍历"]},{"title":"LeetCode精选TOP面试题190.颠倒二进制位","url":"/archives/a015845f.html","content":"题目描述颠倒给定的 32 位无符号整数的二进制位。\n示例 1：\n输入: 00000010100101000001111010011100\n输出: 00111001011110000010100101000000\n解释: 输入的二进制串 00000010100101000001111010011100 表示无符号整数 43261596，\n      因此返回 964176192，其二进制表示形式为 00111001011110000010100101000000。\n\n示例 2：\n\n输入：11111111111111111111111111111101\n输出：10111111111111111111111111111111\n解释：输入的二进制串 11111111111111111111111111111101 表示无符号整数 4294967293，\n      因此返回 3221225471 其二进制表示形式为 10101111110010110010011101101001。\n\n在 Java中，没有无符号整数类型。在这种情况下，输入和输出都将被指定为有符号整数类型，并且不应影响算法的实现，在 Java 中，编译器使用二进制补码记法来表示有符号整数。因此，在上面的示例 2 中，输入表示有符号整数 -3，输出表示有符号整数 -1073741825。\n\n解题思路\n思路1 ：接口实现，一行代码，不香，没有手动实现的乐趣；\n思路2 ：位运算实现，真香，参考大佬分析的思路叭。\n\n代码实现（Java）/**\n * @author : flower48237\n * @2020/3/18 21:25\n * @title : LeetCode精选TOP面试题190.颠倒二进制位\n * 思路1：接口实现\n */\npublic class Solution &#123;\n    // you need treat n as an unsigned value\n    public int reverseBits(int n) &#123;\n        return Integer.reverse(n);\n    &#125;\n&#125;\n\n/**\n * @author : flower48237\n * @2020/3/18 21:25\n * @title : LeetCode精选TOP面试题190.颠倒二进制位\n * 思路2：位运算实现\n */\npublic class Solution &#123;\n    // you need treat n as an unsigned value\n    public int reverseBits(int n) &#123;\n        int res = 0;\n        for (int bitsSize = 31; n != 0; n = n >>> 1, bitsSize--) &#123;\n            res += (n &amp; 1) &lt;&lt; bitsSize;\n        &#125;\n        return res;\n    &#125;\n&#125;","categories":["LeetCode"],"tags":["Java","LeetCode","遍历","位运算"]},{"title":"LeetCode精选TOP面试题121.买卖股票的最佳时机","url":"/archives/577c36e6.html","content":"题目描述给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。如果你最多只允许完成一笔交易（即买入和卖出一支股票一次），设计一个算法来计算你所能获取的最大利润。!!! 不能在买入股票前卖出股票 !!!\n\n解题思路思路1：一次遍历 O(N)\n\n1.维护两个整数，maxnum和minnum，用来记录区间最大值和最小值；\n\n2.遍历数组：\n\n当元素item 大于 maxnum 时，最大值mannum更新为item，此时比较最大值和最小值的差值 sub **与当前记录的临时最大利润profit**的大小关系，如果sub &gt; profit，就更新profit，小于则不更新；\n当元素item 小于 minnum 时，最小值minnum和最大值maxnum都更新为item；\n\n\n3.遍历结束后直接返回profit。思路2：两层遍历，暴力求解 O(N²)两层遍历的过程中不断比较两数之差与profit的大小关系，更新找到最大利润，思路比较通俗易懂，但是时间复杂度高。\n\n\n代码实现（Java）/**\n * @author : flower48237\n * @2020/3/23 16:46\n * @title : LeetCode精选TOP面试题121.买卖股票的最佳时机\n */\npublic class Solution &#123;\n    public int maxProfit(int[] prices) &#123;\n        if (prices.length == 0 || prices.length == 1)&#123;\n            return 0;\n        &#125;\n        // 法 1 ，一次遍历\n        int maxnum = prices[0], minnum = prices[0];\n        int profit= 0;\n        for (int i = 1; i &lt; prices.length; i++)&#123;\n            if (prices[i] > maxnum)&#123;\n                maxnum = prices[i];\n                if (maxnum - minnum > profit)&#123;\n                    profit= maxnum - minnum;\n                &#125;\n            &#125;\n            if (prices[i] &lt; minnum)&#123;\n                minnum = prices[i];\n                maxnum = prices[i];\n            &#125;\n\n        &#125;\n        return profit;\n\n\t\t/* 法 2 暴力求解\n        int maxprofit = 0;\n        for (int i = 0; i &lt; prices.length - 1; i++) &#123;\n            for (int j = i + 1; j &lt; prices.length; j++) &#123;\n                int profit = prices[j] - prices[i];\n                if (profit > maxprofit)\n                    maxprofit = profit;\n            &#125;\n        &#125;\n        return maxprofit;\n        */\n         \n    &#125;\n&#125;\n\n做完题之后膜拜大佬的解题思路，果然我是白痴级别，大佬的解题思路实在是太强了。labuladong大佬的文章：一个方法团灭 6 道股票问题\nivan_allen大佬的文章：dp 7 行简约风格\n\n","categories":["LeetCode"],"tags":["Java","LeetCode","数组","遍历","动态规划"]},{"title":"LeetCode精选TOP面试题202.快乐数","url":"/archives/f2d7b9d0.html","content":"题目描述编写一个算法来判断一个数是不是“快乐数”。题目来源：LeetCode一个“快乐数”定义为：对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和，然后重复这个过程直到这个数变为 1，也可能是无限循环但始终变不到 1。如果可以变为 1，那么这个数就是快乐数。\n\n示例: \n输入: 19\n输出: true\n解释: \n12 + 92 = 82\n82 + 22 = 68\n62 + 82 = 100\n12 + 02 + 02 = 1\n\n解题思路这是一个在编程的时候会出现死循环的问题，个人认为重点工作其实倒不是怎么判断是不是快乐数，而是找到打破循环的方法或者条件。\n\n思路1 ：快慢指针  慢指针slower每次前进一步（进行一次平方计算），快指针faster每次前进两步（进行两次平方计算），当slower和faster不相等的时候，就一直循环。那为啥还说能打破循环呢？  这是因为当快慢指针相等的时候会停止循环，相等的有两种情况：\n当慢指针和快指针都通过计算变成了1；\n当慢指针走过一圈之后，快指针肯定恰好走过了两圈，如果不是快乐数，快慢指针的值肯定是相同的；\n之所以选择快指针走两步而不是三步四步，是因为1，2公倍数最小，公约数最多，这样最节省空间和时间\n\n\n\n\n思路2 ：借助HashSet哈希Set特点就是不允许重复，那只要每次求和之后，判断当前的值n是否已经存在于hashset中就好啦，存在就不是快乐数，直接return false，不存在就添加进hashset，直到n 变成1跳出循环，或者返回false。\n思路3 ：投机取巧  小于10的数中，只有1和7是快乐数，借鉴leetcode上大神的思路，所以，投机取巧就很简单了:\n只要每次计算得到的n大于10，那么就继续计算;\n每次计算得到的n小于10，如果等于1或者7，就是快乐数，不等就不是。\n\n\n\n代码实现(Java)/**\n * @author : flower48237\n * @2020/3/16 20:38\n * title : LeetCode精选TOP面试题202.快乐数\n */\npublic class Solution3 &#123;\n    public boolean isHappy(int n) &#123;\n    \t// 法 1 -- 快慢指针\n        int slower = n;\n        int faster = n;\n        do &#123;\n            slower = getSqrtSum(slower);\n            faster = getSqrtSum(faster);\n            faster = getSqrtSum(faster);\n        &#125;while (slower != faster);\n        return slower == 1;// 返回slower和1是否相等的判定值\n        \n    \t// 法 2 -- 借助HashSet\n        HashSet&lt;Integer> hashset = new HashSet&lt;Integer>();\n        hashset.add(n);\n        if (n == 1)&#123;\n            return true;\n        &#125;\n        while (n != 1)&#123;\n            n = getSqrtSum(n);\n            if (hashset.contains(n))&#123;\n                return false;\n            &#125;\n            hashset.add(n);\n        &#125;\n        return true;\n        \n        // 法 3 -- 投机取巧\n        while (true)&#123;\n            if (n &lt; 10)&#123;\n                if (n == 1 || n == 7) &#123;\n                    return true;\n                &#125;else &#123;\n                    return false;\n                &#125;\n            &#125;\n            n = getSqrtSum(n);\n        &#125;\n    &#125;\n    // 三个方法都会用到的计算平方的步骤\n    public int getSqrtSum(int num)&#123;\n        int sum = 0;\n        while (num > 0)&#123;\n            int item = num % 10;\n            sum += item * item;\n            num /= 10;\n        &#125;\n        return sum;\n    &#125;\n&#125;\n","categories":["LeetCode"],"tags":["Java","数值计算","LeetCode"]},{"title":"LeetCode精选TOP面试题122.买卖股票的最佳时机II","url":"/archives/bbd4b07b.html","content":"题目描述给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。不能同时参与多笔交易（必须在再次购买前出售掉之前的股票）。\n\n示例 1:\n输入: [7,1,5,3,6,4]\n输出: 7\n解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。\n     随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。\n示例 2:\n输入: [1,2,3,4,5]\n输出: 4\n解释: 在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。\n     注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。\n     因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。\n示例 3:\n\n输入: [7,6,4,3,1]\n输出: 0\n解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。\n解题思路\n思路1 ：一步一计算定义入手价格变量 in ，遍历数组，判断当前元素item与in的大小关系，如果item &gt; in， 那么直接卖出，利润累加；如果item &lt; in， 更新in为item，表示可以用比之前更低的价格买入。考虑以下两种情况：股票一路走低，那就直接不用买了，只更新in，但是利润不要累加；股票一路走高，那就每次都第二天先卖出赚利润后再买入，利润不断累加，符合题意，并可以引出思路2。\n思路2：只计算上升曲线，啥意思呢？就是只考虑思路1的第二步，当今天的股价比前一天高，就把差价累加到利润中，很明显，当股票走低转折的时候，作为买家我是不会在前一天购买的，这其实并不合理，因为股价很难预测，但是题目要求是根据给定数组推算利润，所以这是可行的。代码实现（Java）/**\n * @author : flower48237\n * @2020/3/16 17:23\n * title : LeetCode精选TOP面试题122.买卖股票的最佳时机II\n */\npublic class Solution &#123;\n    public int maxProfit(int[] prices) &#123;\n        if (prices.length == 0)&#123;\n        \t// 判断数组是否为空\n            return 0;\n        &#125;\n        int interest = 0; // 利润初始化为0\n        // 法1\n        int in = prices[0];\n        for (int i = 1; i &lt; prices.length; i++)&#123;\n            if (prices[i] > in)&#123;\n            \t// 那么直接卖出，利润累加\n                interest += prices[i] - in;\n                // 更新入手价in\n                in = prices[i];\n            &#125;else if (prices[i] &lt; in)&#123;\n            \t// 更新入手价in\n                in = prices[i];\n            &#125;\n        &#125;\n        \n        // 法 2\n        for (int i = 1; i &lt; prices.length; i++)&#123;\n            if (prices[i] > prices[i - 1])&#123;\n            \t// 只计算上升曲线，差价累加\n            \t// 很容易考虑如果在曲线图内，连续的差值实际上就等于\n            \t// 波峰-波谷 = 极高价卖出 - 极低价买入\n                interest += prices[i] - prices[i - 1];\n            &#125;\n        &#125;\n        return interest;\n    &#125;\n&#125;\n\n其实就是贪心算法的思路\n\n\n\n","categories":["LeetCode"],"tags":["Java","LeetCode","数组","遍历","动态规划"]},{"title":"笔试题6-数值统计","url":"/archives/ff9dabc7.html","content":"题目回顾一串数字，逗号分割输入，排序，统计出最大值max、最大值出现的次数count、平均数avg，并输出排序后的数组和三个统计得到的值。样例：输入：93,90,94,94,94输出：90 93 94 94 94 ,max:94,count:3,avg:93\n\n解题思路不需要思路，遍历数组，统计就完事了，借用Java现成的接口它不香么。\n代码（Java）import java.util.Scanner;\n/**\n *\t@author : flower48237\n *\t@version: 2020年3月11日 下午9:12:24 \n *  @note : 统计\n */\npublic class Main &#123;\n\tpublic static void main(String[] args) &#123;\n\t\t// TODO Auto-generated method stub\n\t\tScanner in = new Scanner (System.in);\n\t\tString str = in.next();\n\t\tString [] arr = str.split(\",\"); // 分割，获取数字\n\t\tint count = 1;\t// 计数器\n\t\tint sum = 0;\t// 累加和\n\t\tArrays.sort(arr); // 使用sort接口排序\n\t\tString max = arr[0];\t// 初始化最大值为首元素\n\t\tfor (String ch : arr) &#123;\n\t\t\tSystem.out.print(ch + \" \");\n\t\t\tif (Integer.parseInt(ch) == Integer.parseInt(max)) &#123;\n\t\t\t\t// 最大值出现的次数计数\n\t\t\t\tcount ++;\n\t\t\t&#125;\n\t\t\tif (Integer.parseInt(ch) > Integer.parseInt(max)) &#123;\n\t\t\t\t// 当有新的最大值时，更新最大值max，重制计数器为1\n\t\t\t\tmax = ch;\n\t\t\t\tcount = 1;\n\t\t\t&#125;\n\t\t\tsum += Integer.parseInt(ch);\t// 求累加和\n\t\t&#125;\n\t\t// 按要求输出\n\t\tSystem.out.print(\",max:\" + max);\n\t\tSystem.out.print(\",count:\" + count);\n\t\tSystem.out.print(\",avg:\" + sum / arr.length);\n\t&#125;\n&#125;\n\n联通软件研究院2020春招面试题之一，依然是考基础。\n\n","categories":["笔试题"],"tags":["Java","数值计算","字符串"]},{"title":"笔试题5-十六进制转十进制","url":"/archives/5071d281.html","content":"题目回顾十六进制与十进制的转换，输入一个十六进制字符串，转换成十进制数输出。\n解题思路需要思路么？大概不需要，遍历字符串，把字符0~9的当做一类处理，字符A ~ F的当做一类处理，转成整数后按照转换规则对每一位进行指数、乘法操作并累加就好啦。\n\n代码（Java）import java.util.Scanner;\n/**\n *\t@author : flower48237\n *\t@version: 2020年3月11日 下午9:12:13 \n *\t@note : OX to Ten\n */\npublic class Main &#123;\n\n\tpublic static void main(String[] args) &#123;\n\t\t// TODO Auto-generated method stub\n\t\tScanner in = new Scanner(System.in);\n\t\tString str = in.nextLine();\n\t\t//用long定义sum是为了防止溢出\n\t\tlong sum = 0;\t\n\t\tint len = str.length();\n\t\tfor (int i = 0; i &lt; len; i++) &#123;\n\t\t\t char ch = str.charAt(i);\n\t\t\t int chval = (int)ch;\n\t\t\t if(chval - 48 > 9)&#123;\n                 if(str.charAt(i) == 'a')\n                     sum += 10 * Math.pow(16,len-i-1);\n                 else if(ch == 'b')\n                     sum += 11*Math.pow(16,len-i-1);\n                 else if(ch == 'c')\n                     sum += 12*Math.pow(16,len-i-1);\n                 else if(ch == 'd')\n                     sum += 13*Math.pow(16,len-i-1);\n                 else if(ch == 'e')\n                     sum += 14*Math.pow(16,len-i-1);\n                 else if(ch == 'f')\n                     sum += 15*Math.pow(16,len-i-1);\n             &#125;\n             else&#123;\n                 sum+=(chval - 48) * Math.pow(16,len-i-1);\n             &#125;\n\t\t&#125;\n\t\tSystem.out.print(sum);\n\t&#125;\n&#125;\n\n联通软件研究院笔试编程题之一，感觉考的很重视基础。\n\n","categories":["笔试题"],"tags":["Java","字符串","进制转换"]},{"title":"LeetCode精选TOP面试题283. 移动零","url":"/archives/63e5cd3d.html","content":"题目描述给定一个数组 nums，编写函数将所有 0 移动到数组的末尾，且保持非零元素的相对顺序。\n示例:\n输入: [0,1,0,3,12]\n输出: [1,3,12,0,0]\n\n要求:1.必须在原数组上操作，不能拷贝额外的数组。2.尽量减少操作次数。\n\n解题思路思路1：先复制最后置0，复制完成后数组中没有0元素两个标志位同时向后移动，遇到非零元素则将其向前复制，最后当第一个标志位到数组末尾时，将两个标志位之间的元素全部置0。思路2：一边遍历一边交换，始终保持原数组本身的数据组成两个标志位同时先后移动，遇到非零元素则将两个标志位所指向的元素互换（此时会包含两个标志位指向同一个元素，本身和本身互换的情况，对算法本身没有影响），遍历到最后，零元素就全部位于数组末尾了。以上两种思路均能保持非零元素的相对顺序\n\n思路3：利用辅助数组这个比较好理解，遇到非零元素就复制到新数组，剩下的位补0，但是这是违背要求的。\n\n代码实现（Java）// 思路1：先复制最后置0，复制完成后数组中没有0元素\npublic class Solution &#123;\n    public void moveZeros(int[] nums)&#123;\n        int len = nums.length;\n        if (len == 0)&#123;\n            return;\n        &#125;\n        int count = 0;\n        for (int i = 0; i &lt; len; i++)&#123;\t// 先复制\n            if (nums[i] != 0)&#123;\n                nums[count++] = nums[i];\n            &#125;\n        &#125;\n        // 此时数组中没有0元素了\n        for (int i = count; i &lt; len; i++)&#123;// 然后置末尾的i 和j之间的元素全为0\n            nums[i] = 0;\n        &#125;\n    &#125;\n&#125;\n\n// 思路2：：一边遍历一边交换，始终保持原数组本身的数据组成\npublic class Solution &#123;\n    public void moveZeros(int[] nums)&#123;\n        int len = nums.length;\n        if (len == 0)&#123;\n            return;\n        &#125;\n        int i, j = 0;\n        for (i = 0; i &lt; len; i++)&#123;\n        \t// 交换呀交换，只要遇到0元素，i和j总能错开的，所有肯定保证非零元素和零元素的交换\n            if (nums[i] != 0)&#123;\n                int temp = nums[i];\n                nums[i] = nums[j];\n                nums[j++] = temp;\n            &#125;\n        &#125;\n    &#125;\n&#125;\n","categories":["LeetCode"],"tags":["Java","LeetCode","数组","遍历"]},{"title":"LeetCode精选TOP面试题13.罗马数字转整数","url":"/archives/2e2e399.html","content":"题目描述罗马数字包含以下七种字符: I， V， X， L，C，D 和 M。\n字符          数值\nI             1\nV             5\nX             10\nL             50\nC             100\nD             500\nM             1000\n例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做  XXVII, 即为 XX + V + II 。通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例。\n\n例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况：\nI 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。\nX 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。 \nC 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。\n给定一个罗马数字，将其转换成整数。输入确保在 1 到 3999 的范围内。\n\n示例 1:\n输入: \"III\"\n输出: 3\n\n示例 2:\n输入: \"IV\"\n输出: 4\n\n示例 3:\n输入: \"IX\"\n输出: 9\n\n示例 4:\n输入: \"LVIII\"\n输出: 58\n解释: L = 50, V= 5, III = 3.\n\n示例 5:\n输入: \"MCMXCIV\"\n输出: 1994\n解释: M = 1000, CM = 900, XC = 90, IV = 4.\n\n解题思路1.遍历字符串，把当前遍历得到的元素curnum和它的前一个元素prenum进行比较；2.如果prenum  &lt; curnum，那么令累加和sum减去prenum的值；3.如果prenum  &gt; curnum，那么令累加和sum加上prenum的值；4.每次遍历的 加/减 运算之后，更新prenum为当前元素值curnum；5.当遍历结束之后，累加和sum需要加上最后一个字符代表的罗马数字的值，因为这个值没有被处理。\n代码（Java）/**\n * @author : flower48237\n * @2020/3/4 19:15\n * explanation: LeetCode精选TOP面试题13.罗马数字转整数\n */\npublic class Solution &#123;\n    public int romanToInt(String s)&#123;\n        int prenum = getVal(s.charAt(0));\t// 前一个元素，初始化为首元素\n        int curnum = 0;\t\t\t\t\t\t// 当前元素，初始化为0\n        int sum = 0;\t\t\t\t\t\t// 累加和，初始化为0\n        for (int i = 1; i &lt; s.length(); i ++)&#123;\t// 从 下标 1 开始遍历\n            curnum = getVal(s.charAt(i));\t// 获取字符对应的数字值\n\n            if (prenum &lt; curnum)&#123;\n            \t// 如果prenum&lt;curnum，那么令累加和sum减去prenum的值\n                sum = sum - prenum;\n            &#125;else &#123;\t\t\n            \t// 如果prenum  > curnum，那么令累加和sum加上prenum的值\n                sum = sum + prenum;\n            &#125;\n\t\t\t// 每次遍历的 加/减 运算之后，更新prenum为当前元素值curnum\n            prenum = curnum;\n        &#125;\n\t\t//遍历结束之后，累加和sum需要加上最后一个字符代表的罗马数字的值，因为这个值没有被处理\n        sum += prenum;\n        return sum;\n    &#125;\n    \n    // getVal函数获取字符对应的整数值，用switch来做，比if else判断要快。\n    public int getVal(char ch)&#123;\n        switch(ch) &#123;\n            case 'I':\n                return 1;\n            case 'V':\n                return 5;\n            case 'X':\n                return 10;\n            case 'L':\n                return 50;\n            case 'C':\n                return 100;\n            case 'D':\n                return 500;\n            case 'M':\n                return 1000;\n            default: return 0;\n        &#125;\n    &#125;\n&#125;\n\n个人感觉这个问题，只要理解了，当前元素比它的前一个元素小，和就加，当前元素比它的前一个元素大，和就减，把这个事情想清楚就好解决了，比较不容易理解的地方在最后一个字符对应值的处理方式，最后一个字符前面的元素，比他大，那么直接加上值，比他小，那么实际上在循环的最后一步已经从和里减去了，这个题的思路是提前一步解决和差问题。\n\n","categories":["LeetCode"],"tags":["Java","数值计算","LeetCode","面试","字符串"]},{"title":"笔试题4-字符串序列的转换","url":"/archives/d161f5a8.html","content":"\n2020年2月 TapTap × 心动网络的一个笔试题，原题记不太清了，只能回忆一下了。\n\n题目回忆给定两个字符串str1和str2，拿str1 = “asd”， str2 = “dsa” 举例。把str1的末尾字符取下，放到栈中，这个操作记为 E ；判断栈顶元素是否与str2 的首字符相同，如果相同，那么栈顶元素出栈，这个操作记为 D。现在给定任意的两个字符串，需要判断字符串1能否通过合理的E、D操作得到字符串2，并将E、D操作序列输出。规定每个字符串中没有相同的字符，每个字符都是唯一的。\n样例1\ninput: asd dsa\noutput: EDEDED\n\n样例2: \ninput: qwert twerq\noutput: EDEEEDDDED\n\n解题思路\n设置遍历下标index用于顺序遍历字符串2，以便进行判等操作；\n逆序遍历字符串1进行入栈操作，每次入栈后，在结果字符串中追加 E 操作；\n每次入栈之后，借助while循环，对栈顶元素和字符串2当前的首字符进行判断，如果两者相等，那么栈顶元素出栈，index后移，同时在结果字符串中追加 D 操作，这里必须用while循环一直判断到 栈空 或者栈顶元素和字符串2首字符不相等 为止，单纯的if判断一次是不能解决问题的；\n当字符串1遍历结束之后，若栈不空，对栈内元素进行遍历，思路与步骤3大致相同，但是当遍历到栈顶元素与字符串2的首字符不相同时，直接跳出循环，这里就很明显的可以判定 字符串1不能通过E、D操作得到字符串2了，栈内只剩这点儿元素，但是还有不匹配的，那肯定不行了；\n最后的输出工作：若栈不空 就不能得到，若栈空，就是能得到，输出ED操作序列。\n\n代码实现（Java）import java.util.Scanner;\nimport java.util.Stack;\n\npublic class Main &#123;\n\tpublic static void main(String[] args) &#123;\n\t\t// TODO Auto-generated method stub\n\t\tScanner in = new Scanner(System.in);\n\t\tString str1 = in.next();\n\t\tString str2 = in.next();\n\t\t// 字符串的合法性判断\n\t\tif (str1 == null || str2 == null) &#123;\n\t\t\tSystem.out.print(-1);\n\t\t&#125;\n\t\t// 借助StringBuffer，追加的时候比较方便\n\t\t// 相对于String而言节省内存\n\t\tStringBuffer res = new StringBuffer();\n\t\tStack&lt;Character> stack = new Stack&lt;Character>();\n\t\tint len = str1.length();\n\t\t// 位置下标index用于对str2进行顺序遍历\n\t\tint index = 0;\t\n\t\t// 逆序遍历str1\n\t\tfor (int i = len - 1; i >= 0; i --) &#123; \n\t\t\tchar ch = str1.charAt(i);\t// 为了下面使用起来方便\n\t\t\tstack.add(ch);\t\t\t\t// 入栈\n\t\t\tres.append('E');\t\t\t// 完成 E 操作\n\t\t\t// 下面的while循环必须先对栈进行判空操作，\n\t\t\t// 栈空了再怎么比较也没意义，而且会报错\n\t\t\twhile (!stack.isEmpty() &amp;&amp; stack.peek() == str2.charAt(index)) &#123;\n\t\t\t\tstack.pop();\t // 匹配 -- 栈顶元素出栈\n\t\t\t\tindex ++;\t\t // 位置下标index递增，用于后面的匹配\n\t\t\t\tres.append('D'); // 完成 D 操作\n\t\t\t&#125;\n\t\t&#125;\n\t\twhile(!stack.isEmpty()) &#123; // 栈不空，继续判断剩下的\n\t\t\tif (stack.peek() == str2.charAt(index)) &#123;\n\t\t\t\tstack.pop();\n\t\t\t\tindex ++;\n\t\t\t\tres.append('D');\n\t\t\t&#125;\n\t\t\telse &#123;\t// 只要出现不匹配，直接跳出就行了，肯定不能完成目标\n\t\t\t\tbreak;\n\t\t\t&#125;\n\t\t&#125;\n\t\tif (!stack.isEmpty()) &#123;\n\t\t\tSystem.out.print(\"Error Operation\");\n\t\t&#125;else &#123;\n\t\t\tSystem.out.print(res);\t// 输出合法ED操作序列\n\t\t&#125;\n\t&#125;\n&#125;\n","categories":["笔试题"],"tags":["Java","字符串","栈"]},{"title":"LeetCode精选TOP面试题104.二叉树的最大深度","url":"/archives/b88b3653.html","content":"题目描述给定一个大小为 n 的数组，找到其中的多数元素。多数元素是指在数组中出现次数大于 ⌊ n/2 ⌋ 的元素。数组是非空的，并且给定的数组总是存在多数元素。\n示例 1:\n输入: [3,2,3]\n输出: 3\n示例 2:\n输入: [2,2,1,1,1,2,2]\n输出: 2\n\n解题思路根据题目描述，给定的数组总是存在多数元素，而多数元素的定义指在数组中出现次数大于 ⌊ n/2 ⌋ 的元素。那么这个题就很容易想了，直接排序，排序后返回数组中下标是nums.length / 2 的元素即可。要保证其出现次数大于  ⌊ n/2 ⌋ ，那么这个数肯定横跨在nums.length / 2 的左右，不管nums.length是奇数还是偶数。举个例子：\n\nnums.length 是 6 的时候，多数元素出现的次数肯定大于⌊ 6 / 2 ⌋  = 3，也就是出现的次数 ≥ 4 ，那么这个多数元素肯定会出现在排序后数组的 中间位置2 和 3上，很容易理解。\nnums.length 是 7 的时候，多数元素出现的次数肯定大于⌊ 7 / 2 ⌋ = 3，也就是出现的次数 ≥ 4 ，那么这个多数元素肯定会出现在排序后数组的中间位置 （3 和4）或者 （4 和5）上，也很容易理解。代码（Java）\n\nclass Solution &#123;\n    public int majorityElement(int[] nums) &#123;\n        Arrays.sort(nums); // 排序\n        return nums[nums.length/2];// 返回结果\n    &#125;\n&#125;\n","categories":["LeetCode"],"tags":["Java","LeetCode","数组"]},{"title":"【剑指offer】面试题33-二叉搜索树的后序遍历序列","url":"/archives/9451e2de.html","content":"题目输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。如果是则输出Yes,否则输出No。假设输入的数组的任意两个数字都互不相同。\n样例1\ninput：7，4，6，5\noutput：false\n\n样例2\ninput：2，4，3，6，8，7，5\noutput：true\n\n解题思路二叉搜索树的特点，左子树中结点的值小于根结点的值，右子树中结点的值大于根结点的值。思路1  递归后序遍历的特点，序列的最后一个元素是当前树的“根结点”。所以每次先在最后找到根结点，再根据大小关系划分左右子树，递归判断左右子树是否满足二叉搜索树+后序遍历的两个特点即可。思路2  非递归抽象的变换一下形式。把二叉搜索树的左子树，当成其右子树最左边结点的左子树，把每次遍历确定的“根结点”独立出来为一个结点。那么就很容易来通过循环判断了。这个后序遍历序列，最后一个数（即根结点的值）一定比最开始左子树的大，比最开始右子树的小，那么每次遍历的时候通过二叉搜索树和后序遍历序列的特点来对一个下标变量index进行累加，外层循环每次都对index和序列总长度进行比较：\n\n当index和总长度不想等时，证明这个序列不是合法的后续遍历序列；\n当index和总长度不想等时，证明这个序列是合法的后续遍历序列，此时把序列长度减去1，即每次把根节点去掉，再进行循环判断，根基上面提到的两个特点我们可以确定，这样的循环是合理的。\n\n白话一点描述上面的非递归思路：\n\n左子树结点值一定比右子树结点值小，因此去掉根结点后，数字分为left，right两部分；\nright部分的最后一个数字是右子树的根结点，他也比左子树所有值大，因此每次只看右子树是否符合后序遍历的条件即可；\n即使到达了左子树，左子树也可以看成是由左、右子树组成的树，依然像右子树那样处理；\n对于左子树的处理就像回到了原问题；\n对于右子树，左子树的所有值都比右子树的根结点值小，可以暂时把他看成右子树的左子树，只需判断右子树的右子树是否符合要求即可。代码（Java实现）\n\n思路1  递归代码\n/**\n *\t@author : flower48237\n *\t@version: 2020年3月3日 下午3:28:17 \n */\npublic class Solution &#123;\n\tpublic boolean VerifySquenceOfBST(int []sequence) &#123;\n\t\tint size = sequence.length;\n        if(0==size)return false;\n        while(--size != 0)\n        &#123;\n        \tint i = 0;\n            while(sequence[i++]&lt;sequence[size]);\n            while(i &lt; size &amp;&amp; sequence[i++]>sequence[size]);\n \t\t\t// 第二个while循环的i &lt; size 是为了防止数组下标越界\n            if(i&lt;size)\n            \treturn false;\n        &#125;\n        return true;\n\t&#125;\n&#125;\n\n思路2  非递归代码\npackage kd33.VerifySquenceOfBST;\n/**\n *\t@author : flower48237\n *\t@version: 2020年3月3日 下午4:57:02 \n */\npublic class Solution2 &#123;\n\tpublic boolean leaper(int [] sequence, int start, int end) &#123;\n\t\t// leaper是递归函数\n\t\tif (end &lt;= start) \n        \treturn true;\n        int root = sequence[end];\n        \n        int i = start;\n        for (; i &lt; end; i++) &#123;\n        \tif (sequence[i] > root) &#123;\n        \t\tbreak;\n        \t&#125;\n        &#125;\n        \n        int j = i;\n        for (; j &lt; end; j++) &#123;\n        \tif (sequence[j] &lt; root) &#123;\n        \t\treturn false;\n        \t&#125;\n        &#125;\n        return leaper(sequence, start, i - 1) &amp;&amp;leaper(sequence, i, end - 1);\n\t&#125;\n\t\n\tpublic boolean VerifySquenceOfBST(int []sequence) &#123;\n\t\tint size = sequence.length;\n\t\tif(size == 0)\n        \treturn false;\n\t\treturn leaper(sequence, 0, size - 1);\n\t&#125;\n&#125;\n","categories":["剑指offer"],"tags":["Java","遍历","数据结构","二叉树","DFS","算法"]},{"title":"LeetCode精选TOP面试题412. Fizz Buzz","url":"/archives/3f5518c6.html","content":"题目描述写一个程序，输出从 1 到 n 数字的字符串表示。1.如果 n 是3的倍数，输出“Fizz”；2. 如果 n 是5的倍数，输出“Buzz”；3.如果 n 同时是3和5的倍数，输出 “FizzBuzz”\n\n解题思路思路1对1到n范围内的数进行遍历，并对每个遍历到的数字number进行条件判断：\n\n如果number % 3 = 0 但 number % 5  != 0，列表新增元素”Fizz”;\n如果number % 5 = 0 但 number % 3  != 0，列表新增元素”Buzz”;\n如果number % 3 = 0 且 number % 5 = 0，列表新增元素”FizzBuzz”;\n如果以上条件均不满足，则列表新增元素 i (转变成字符串形式) 。\n\n思路2\n借助额外的StringBuffer类型的变量strbuf，以减少对判断条件的依赖性，因为当判断条件过多时，思路1的编程是很麻烦的。\n\n如果number % 3 = 0 ，strbuf追加”Fizz”串;\n这之后，如果number % 5 = 0 ，strbuf追加”Buzz”串;\n然后，如果strbuf是空串的话，就追加 i 的字符串形式\n每次将strbuf的字符串形式（即strbuf.toString()）作为新元素，添加到结果列表中，并清空strbuf，用于下一次的判定追加。\n\n这样做的好处是减少了对判断条件的依赖性，当判断题目过多时减少代码量。\n代码（Java）思路1代码\nclass Solution &#123;\n    public List&lt;String> fizzBuzz(int n) &#123;\n\t\tList&lt;String> res = new ArrayList&lt;String>();\n        for (int i = 1; i &lt;= n; i++)&#123;\n            if (i % 3 == 0 &amp;&amp; i % 5 != 0)&#123;\n                res.add(\"Fizz\");\n            &#125;else if (i % 5 == 0 &amp;&amp; i % 3 != 0)&#123;\n                res.add(\"Buzz\");\n            &#125;else if (i % 3 == 0 &amp;&amp; i % 5 == 0)&#123;\n                res.add(\"FizzBuzz\");\n            &#125;else &#123;\n                res.add(i + \"\");\n            &#125;\n        &#125;\n        return  res;\n    &#125;\n&#125;\n思路2代码\npublic class Solution &#123;\n    public List&lt;String> fizzBuzz(int n)&#123;\n        List&lt;String> res = new ArrayList&lt;String>();\n        StringBuffer strbuf = new StringBuffer();\n        for (int i = 1; i &lt;= n; i++)&#123;\n            if (i % 3 == 0)&#123;\n                strbuf.append(\"Fizz\");\n            &#125;\n            if (i % 5 == 0)&#123;\n                strbuf.append(\"Buzz\");\n            &#125;\n            if (strbuf.toString().equals(\"\"))&#123;\n                strbuf.append(i + \"\");\n            &#125;\n            res.add(strbuf.toString());\n            strbuf.delete(0,strbuf.length());\n        &#125;\n        return res;\n    &#125;\n&#125;\n","categories":["LeetCode"],"tags":["Java","LeetCode","字符串","遍历"]},{"title":"LeetCode精选TOP面试题191.位1的个数","url":"/archives/a6ecccb7.html","content":"题目描述编写一个函数，输入是一个无符号整数，返回其二进制表达式中数字位数为 ‘1’ 的个数（也被称为汉明重量）。\n\n示例 1：\n输入：00000000000000000000000000001011\n输出：3\n解释：输入的二进制串 00000000000000000000000000001011 中，共有三位为 '1'。\n示例 2：\n输入：00000000000000000000000010000000\n输出：1\n解释：输入的二进制串 00000000000000000000000010000000 中，共有一位为 '1'。\n示例 3：\n输入：11111111111111111111111111111101\n输出：31\n解释：输入的二进制串 11111111111111111111111111111101 中，共有 31 位为 '1'。\n解题思路\n思路1转换成二进制字符串，for循环统计字符1出现的次数，并返回    最终的和；\n思路2遍历数字的 32 位，进行按位与运算，如果某一位是 1 ，计数器就加       1，在此过程中让辅助的与运算对象不断左移，这样来保证按位与；\n思路3 在思路2按位与的基础上进行优化，让n不断和和n - 1 进行与运算，并把每次与运算的结果赋值给n，这样能保证只要n 等于 0，那么统计就结束了，每进行一次与运算，就说明当前n的二进制中还有1存在。\n\n代码（Java）\n思路1  \n// 字符串 - 循环计数\npublic class Solution &#123;\n    public int hammingWeight(int n)&#123;\n        int count = 0;\n        String str = Integer.toBinaryString(n);\n        for (int i = 0; i &lt; str.length(); i++)&#123;\n            if (str.charAt(i) == '1')&#123;\n                count ++;\n            &#125;\n        &#125;\n        return count;\n    &#125;\n&#125;\n思路2  \n// 按位与\npublic class Solution &#123;\n    public int hammingWeight(int n)&#123;\n        int count = 0;\n        int mask = 1;\n        for (int i = 0; i &lt; 32; i++) &#123;\n            if ((n &amp; mask) != 0) &#123;\n                count++;\n            &#125;\n            mask &lt;&lt;= 1;\n        &#125;\n        return count;\n    &#125;\n&#125;\n\n思路3\n// 优化的按位与\npublic class Solution &#123;\n    public int hammingWeight(int n)&#123;\n        int count= 0;\n        while (n != 0) &#123;\n            count++;\n            n &amp;= (n - 1);\n        &#125;\n        return count;\n    &#125;\n&#125;\n\n\n\n\n​    \n","categories":["LeetCode"],"tags":["Java","LeetCode","字符串","整数","位运算","汉明码"]},{"title":"LeetCode精选TOP面试题118.杨辉三角","url":"/archives/e09ed3e9.html","content":"题目描述给定一个非负整数 numRows，生成杨辉三角的前 numRows 行。在杨辉三角中，每个数是它左上方和右上方的数的和。\n示例:\n输入: 5\n输出:\n[\n     [1],\n    [1,1],\n   [1,2,1],\n  [1,3,3,1],\n [1,4,6,4,1]\n]\n\n解题思路1.第一行单独处理，只有一个元素 1；2.处理第 2 到 n 行：（1）每一行的第一个元素是 1, 单独处理（2）根据杨辉三角的特点，每一行的第 2 (当 行数 &gt; 2 时)到 “行数- 1” 个元素的值, 是它左上方和右上方的数的和；（3）每一行的最后一个元素也是 1,单独处理\n代码（Java实现）import java.util.ArrayList;\nimport java.util.List;\n\n/**\n * @author : flower48237\n * @2020/2/25 22:09\n * explanation: LeetCode精选TOP面试题118.杨辉三角\n */\npublic class Solution &#123;\n    public List&lt;List&lt;Integer>> generate(int numRows) &#123;\n        List&lt;List&lt;Integer>> triangle = new ArrayList&lt;List&lt;Integer>>();\n        if(numRows &lt; 1)&#123; // 判断合法性\n            return triangle;\n        &#125;\n        // 第一行单独处理，只有一个元素 1\n        List&lt;Integer> first = new ArrayList&lt;>();\n        first.add(1);\n        triangle.add(first);\n\n        // 处理第 2 到 n 行\n        for (int rownum = 1; rownum &lt; numRows; rownum ++)&#123;\n            // 创建新的一行\n            List&lt;Integer> newrow = new ArrayList&lt;>();\n            // 获取当前新行的上一行\n            List&lt;Integer> prerow = triangle.get(rownum - 1);\n            // 每一行的第一个元素是 1, 单独处理\n            newrow.add(1);\n            // 根据杨辉三角的特点\n            // 每一行的第 2 (当 行数 > 2 时)到 “行数- 1” 个元素的值, 是它左上方和右上方的数的和\n            for (int k = 1; k &lt; rownum; k ++)&#123;\n                newrow.add(prerow.get(k - 1) + prerow.get(k));\n            &#125;\n            \n\n            // 每一行的最后一个元素也是 1,单独处理\n            newrow.add(1);\n            triangle.add(newrow);\n         &#125;\n        return triangle;\n    &#125;\n&#125;\n\n","categories":["LeetCode"],"tags":["Java","LeetCode","列表"]},{"title":"笔试题2-句子倒置","url":"/archives/e540efdf.html","content":"\n2020年2月24日找工作参加某所的笔试，刚踩的坑，虽然测试样例过了，能想到的几种情况也有测试能通过，但总感觉还是有遗漏的情况没考虑到。\n\n题目倒置句子，标点符号不倒置，倒置之后句子的标点不变位置，输出时候以空格分隔。\n样例\n输入： I like China.\n输出： China. like I\n\n思路1.字符串长度为 0，不是合法的输入，直接return；2.字符串长度不为0， 合法输入，用split(“ “) 分割字符串，这个时候也许会存在一种不合法的输入情况，输入一个或者多个空格，个人认为这也是不合法的输入，所以在正常倒置步骤之前把这个情况也单独拿出来处理了；3.正常的输入，将分割得到的字符串数组逆序输出即可。\n代码import java.util.Scanner;\npublic class Main &#123;\n\tpublic static void main(String[] args) &#123;\n\t\t// TODO Auto-generated method stub\n\t\tScanner in = new Scanner(System.in);\n\t\tString str = in.nextLine();\n\t\t//System.out.println(str.length());\n\t\tif (str.length() == 0) &#123;       // 字符串长度为0的时候，无意义\n\t\t\treturn; \n\t\t&#125; else &#123;    // 字符串长度\n\t\t\tString[] item = str.split(\" \");\n\n\t\t\tint len = item.length;\n\t\t\tSystem.out.println(len);\n\t\t\tif (len == 0)&#123;\t// 输入的字符串里只有空格，没有句子\n\t\t\t\treturn;\n\t\t\t&#125;\n\t\t\tSystem.out.print(item[len - 1]);\n\t\t\tfor (int i = len - 2; i >= 0; i--) &#123;\n\t\t\t\tSystem.out.print(\" \" + item[i]);\n\t\t\t&#125;\n\t\t&#125;\n\t&#125;\n&#125;\n\n对这个题用这种思路解答是否正确并不敢确定，也许会有漏解的情况，欢迎各位大佬批评指正！\n\n","categories":["笔试题"],"tags":["Java","字符串"]},{"title":"笔试题2-约瑟夫问题：n个数字形成的圆圈中循环删除第m个数字","url":"/archives/491299a6.html","content":"\n2020年2月24日找工作过程中的笔试题之一\n\n题目描述n个数字（1, 2, … , n）形成一个圆圈。从数字1开始，每次从这个圆圈中删除第m个数字（第一个为当前数字本身，第二个为当前数字的下一个数字）。当一个数字删除后，从被删除数字的下一个继续删除第m个数字。求出在这个圆圈中剩下的最后一个数字。\n\n思路\n思路1     个人笔试时候的做法，把问题复杂化了感觉(1) 用循环队列，初始化队列元素的值为n个连续的数(2) 循环报数，用累加器来辅助找到每次需要被删除的元素(3) 每次有人被淘汰，先把这个数删除掉，队列的长度减1(4) 当循环队列长度为1的时候，输出仅存的这个数(5) 用数组模拟循环队列 or 用链表模拟\n\n思路2    后来网上查阅到的容易理解的做法先构建递推公式，再使用循环或者递归都能轻松求解。这个问题的其实就是约瑟夫问题的小变形，数据范围由约瑟夫问题的0到N-1，变为了 1 到 N由于我们要求解的是n个元素，第m个数字，要找到最后留下的一个数字，那么我在这里假设得到的结果是f(n,m),根据“左加右减”的数学原理和环形的特征，得到递推公式：              { 0                            ，n = 1f(n,m)= {              { (f(n-1,m) + m)%n   ，n &gt; 1\n根据这个来调整代码，就可以得到数据范围是1 到 N ， 目标值是M的答案\n代码思路1代码\npublic class Joseph &#123;\n\tpublic int getResult(int n, int m) &#123;\n\t\tif (m == 1) &#123;\t// m 是 1，直接返回n 就行了，不需要多跑程序\n\t\t\treturn n;\n\t\t&#125;\n\t\tListNode head = new ListNode(1);\n\t\tListNode p = head;\n\t\tint counts = 1; // 创建用的计数器\n\t\twhile (counts &lt; n) &#123;\n\t\t\t// 尾插法创建单链表\n\t\t\tListNode q = new ListNode(counts + 1);\n\t\t\tq.next = p.next;\n\t\t\tp.next = q;\n\t\t\tp = p.next;\n\t\t\tcounts ++;\n\t\t&#125;\n\t\t// 使单链表变为循环链表\n\t\tp.next = head;\n\n\t\tint count = 0; // 删除用的计数器\n\t\tListNode del = head;\n\t\twhile (del.next != del) &#123; // 使其一直遍历、计数、删除\n\t\t\tcount++;\n\t\t\tSystem.out.println(del.val + \" \" + count);\n\t\t\tif (count == m) &#123;\n\t\t\t\t// 删除这个结点\n\t\t\t\tdel.val = del.next.val;\n\t\t\t\tdel.next = del.next.next;\n\t\t\t\tcount = 1; // 计数器清零\n\t\t\t&#125;\n\t\t\tdel = del.next;\n\t\t&#125;\n\t\treturn del.val;\n    &#125;\n&#125;\n思路2代码\npublic class Jpseph2 &#123;\n\tpublic int getResult(int n, int m) &#123;\n        int fn = 1;\n        for (int i = 2; i &lt;= n; i++) &#123;\n        \tfn = (fn + m - 1) % i;\n        &#125;\n\t\treturn fn;\n    &#125;\n&#125;\n","categories":["笔试题"],"tags":["Java","数组","递归","队列"]},{"title":"LeetCode精选TOP面试题171. Excel表列序号","url":"/archives/f8ecd9c1.html","content":"题目描述给定一个Excel表格中的列名称，返回其相应的列序号。\n\n\n例如，\n    A -&gt; 1\n    B -&gt; 2\n    C -&gt; 3\n    ...\n    Z -&gt; 26\n    AA -&gt; 27\n    AB -&gt; 28 \n    ...\n示例 1:\n输入: &quot;A&quot;\n输出: 1\n示例 2:\n输入: &quot;AB&quot;\n输出: 28\n\n示例 3:\n输入: &quot;ZY&quot;\n输出: 701\n解题思路循环暴力求解，没啥简单办法，只要确定了字母和整数之间的转换关系就能解题了。相当于26进制与10进制的转换。时间复杂度O(N) 。\n代码class Solution &#123;\n    public int titleToNumber(String s) &#123;\n        int len = s.length();\n        int sum = 0;\n        for (int i = 0; i &lt; len; i++)&#123;\n            sum += (s.charAt(i) - 'A' + 1) * Math.pow(26, len - i - 1);\n            System.out.println(Math.pow(26, len - i - 1));\n            System.out.println(sum);\n        &#125;\n\n        return sum;\n    &#125;\n&#125;","categories":["LeetCode"],"tags":["Java","LeetCode","面试","字符串","遍历","进制转换"]},{"title":"【剑指offer】面试题29-顺时针打印矩阵","url":"/archives/900c1741.html","content":"题目描述输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字，例如，如果输入如下4 X 4矩阵： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 则依次打印出数字1,2,3,4,8,12,16,15,14,13,9,5,6,7,11,10.\n\n1.思路\n参考官方思路来的，复述一下官方思路：\n\n\n1.观察每一圈左上角元素的下标，其横纵坐标是相同的，设为(start, start)；\n2.考虑不同的矩阵形状，我们 假设矩阵的行数为row，列数为col ，可以总结出一个规律，循环执行的条件是row &gt; start * 2 &amp;&amp; clo &gt; start * 2 ；\n3.下面考虑怎样打印每一圈：把打印一圈分成四部分，（1）从左到右打印一行：不管形状怎么样，因为是顺时针打印，所以这一步是必须执行的，不需要考虑这一行的元素有多少，直接找到两端遍历打印就可以了；（2）从上到下打印一列：如果只有一行，那就不需要执行这一步，所以要执行这一步的条件是起始行号大于起始列号 ；（3）从右到左打印一行：如果只有一列，那么这一步不需要执行，所以执行条件是列数不少于2，即终止列号大于起始列号 ；（4）从下到上打印一列：如果要执行这一步，那么矩阵至少要有三行两列，因此要求终止行号比起始行号至少大2，同时终止列号要大于起始列号 。2. 代码（Java实现）\n\nimport java.util.ArrayList;\n/**\n * @author : Eleven482-LiQiang\n * @version: 2020年2月16日 上午11:15:03\n */\npublic class Solution &#123;\n\tArrayList&lt;Integer> list = new ArrayList&lt;>();\n\tpublic ArrayList&lt;Integer>  printMatrix(int[][] matrix) &#123;\n\n\t\tint start = 0;\n\t\tint row = matrix.length;\n\t\tint col = matrix[0].length;\n\n\t\twhile (col > start * 2 &amp;&amp; row > start * 2) &#123;\n\t\t\tPrintMatrixCircle(matrix, col, row, start,list);\n\t\t\t++start;\n\t\t&#125;\n\t\treturn list;\n\t&#125;\n\n\tprivate void PrintMatrixCircle(int[][] matrix, int col, int row, int start,ArrayList&lt;Integer> list) &#123;\n\t\t// TODO Auto-generated method stub\n\t\tint endX = col - 1 - start;\n\t\tint endY = row - 1 - start;\n\n\t\t// 从左到右打印一行\n\t\tfor (int i = start; i &lt;= endX; i++) &#123;\n\t\t\tlist.add(matrix[start][i]);\n\t\t\t// System.out.print(matrix[start][i] + \" \");\n\t\t&#125;\n\n\t\t// 从上到下打印一列\n\t\tif (start &lt; endY) &#123;\n\t\t\tfor (int i = start + 1; i &lt;= endY; i++) &#123;\n\t\t\t\tlist.add(matrix[i][endX]);\n\t\t\t\t// System.out.print(matrix[i][endX] + \" \");\n\t\t\t&#125;\n\t\t&#125;\n\n\t\t// 从右到左打印一行\n\t\tif (start &lt; endX &amp;&amp; start &lt; endY) &#123;\n\t\t\tfor (int i = endX - 1; i >= start; i--) &#123;\n\t\t\t\tlist.add(matrix[endY][i]);\n\t\t\t\t// System.out.print(matrix[endY][i] + \" \");\n\t\t\t&#125;\n\t\t&#125;\n\n\t\t// 从下到上打印一列\n\t\tif (start &lt; endX &amp;&amp; start &lt; endY - 1) &#123;\n\t\t\tfor (int i = endY - 1; i >= start + 1; i--) &#123;\n\t\t\t\tlist.add(matrix[i][start]);\n\t\t\t\t// System.out.print(matrix[i][start] + \" \");\n\t\t\t&#125;\n\t\t&#125;\n\n\t&#125;\n&#125;\n\ntips：把抽象的问题图形化，往往能更快的找到思路\n\n","categories":["剑指offer"],"tags":["Java","遍历","矩阵"]},{"title":"【剑指offer】面试题32-从上到下打印二叉树","url":"/archives/394445a5.html","content":"题目从上往下打印出二叉树的每个节点，同层节点从左至右打印。\n\n1. 思路二叉树的广度优先遍历（BFS），借助队列实现，遍历得到的结点元素值存储在列表里。\n2.代码（Java实现）import java.util.ArrayList;\nimport java.util.LinkedList;\nimport java.util.Queue;\npublic class Solution &#123;\n   public ArrayList&lt;Integer> PrintFromTopToBottom(TreeNode root) &#123;\n\t   ArrayList&lt;Integer> list = new ArrayList&lt;Integer>();\n       if (root == null) &#123;\n       \t\t// 空二叉树，只输出 [] \n\t\t\tSystem.out.println(\"[]\");\n    \t\treturn list;\n    \t&#125;\n    \tQueue&lt;TreeNode> queue = new LinkedList&lt;TreeNode>();\n    \tqueue.add(root);\t// 根结点入队\n    \twhile(!queue.isEmpty()) &#123;\t// 循环退出条件是队列为空\n    \t\tTreeNode p = queue.poll();\t// 取出队头结点\n    \t\tlist.add(p.val);\t\t\t// 队头结点的值添加进列表\n    \t\tif(p.left != null) &#123;\t\t// 取出的队头结点为有左子树\n    \t\t\tqueue.add(p.left);\t\t// 其左子树入队\n    \t\t&#125;\n    \t\tif(p.right != null) &#123;\t\t// 取出的队头结点为有右子树\n    \t\t\tqueue.add(p.right);\t\t// 其右子树入队\n    \t\t&#125;\n       \t&#125;\n    \tSystem.out.print(list);\n    \treturn list;\n    &#125;\n&#125;\n","categories":["剑指offer"],"tags":["Java","遍历","二叉树","BFS"]},{"title":"LeetCode精选TOP面试题344.反转字符串","url":"/archives/a3767f0f.html","content":"题目描述编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 char[] 的形式给出。不要给另外的数组分配额外的空间，必须原地修改输入数组、使用 O(1) 的额外空间解决这一问题。假设数组中的所有字符都是 ASCII 码表中的可打印字符。\n\n思路思路1： 非递归\n\n长度len为0不合法，直接返回；\n①长度不为0时，借助for循环进行元素交换，时间复杂度O(N)，空间复杂度O(1)，实际运行次数是 n / 2；②每次循环交换下标为 i 和下标为 len - i - 1 的字符。\n\n思路2： 递归来自官方题解的思路，借助递归实现，时间复杂度O(N)，空间复杂度O(N)。\n代码（Java实现）// 思路 1 代码\npublic class Solution &#123;\n    public void reverseString(char[] s) &#123;\n        int len = s.length;\n        if (len == 0)&#123;\t// 长度为0 ，直接返回\n            return;\n        &#125;\n        char temp;\t\t// 辅助字符temp，用于交换元素\n        for (int i = 0; i &lt; len / 2; i++)&#123;\n            temp = s[i];\n            s[i] = s[len-i-1];\n            s[len-i-1] = temp;\n    &#125;\n&#125;\n\n// 思路 2 代码\nclass Solution &#123;\n  public void helper(char[] s, int left, int right) &#123;\n    if (left >= right) &#123;\n\t\t// 递归边界\n\t\treturn;\n\t&#125;\n\t// 交换元素\n    char tmp = s[left];\n    s[left++] = s[right];\n    s[right--] = tmp;\n    helper(s, left, right);\t// 递归\n  &#125;\n  \n  public void reverseString(char[] s) &#123;\n    helper(s, 0, s.length - 1);\t// 首次调用递归函数\n  &#125;\n&#125;\n附官方题解\n","categories":["LeetCode"],"tags":["Java","LeetCode","字符串","反转"]},{"title":"LeetCode精选TOP面试题108.将有序数组转换为二叉搜索树","url":"/archives/cd1152fa.html","content":"题目描述将一个按照升序排列的有序数组，转换为一棵高度平衡二叉搜索树。一个高度平衡二叉树是指一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1。将有序数组转换为二叉搜索树的结果肯定是不唯一的，因为存在多种建树方法。\n\n思路思路一： 中序遍历–始终选择中间位置左边元素作为根节点；思路二： 中序遍历–始终选择中间位置右边元素作为根节点；思路三： 中序遍历–选择任意一个中间位置元素作为根节点。以上三个思路借助的都是递归法+二叉树的中序遍历 ，中序遍历的定义就是访问结点的顺序为左-&gt;中-&gt;右\n代码（Java实现）import java.util.*;\npublic class Solution &#123;\n    int[] nums;\n    public TreeNode Transfer(int left, int right) &#123;\n        if (left > right)&#123;\n            // 退出递归的边界条件\n            return null;\n        &#125;\n        // 思路 1 ：始终选择中间位置左边元素作为根节点\n        int midloc = (left + right) / 2;\n\n        // 思路 2 ：始终选择中间位置右边元素作为根节点\n        /*int midloc = (left + right) / 2;\n        if ((left + right) % 2 == 1) &#123;\n            midloc ++;\n        &#125;*/\n\n        // 思路 3 ：选择任意一个中间位置元素作为根节点\n        /*int midloc = (left + right) / 2;\n        Random rand = new Random();\n        if ((left + right) % 2 == 1)&#123;\n            midloc += rand.nextInt(2);\n        &#125;*/\n\n        // 递归建树\n        TreeNode root = new TreeNode(nums[midloc]);\n        root.left = Transfer(left, midloc - 1);   // 左递归\n        root.right = Transfer(midloc + 1, right);  // 右递归\n        return root;\n    &#125;\n\n    public TreeNode sortedArrayToBST(int[] nums) &#123;\n        this.nums = nums;\n        return Transfer(0, nums.length - 1);\n    &#125;\n&#125;\n\n详解可参照LeetCode官方题解完整的可运行代码请点击此处下载\n","categories":["LeetCode"],"tags":["Java","LeetCode","面试","数组","遍历","二叉树"]},{"title":"【剑指offer】面试题31-栈的压入、弹出序列","url":"/archives/d7646f6a.html","content":"题目描述输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否可能为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如序列6,7,8,9,10是某栈的压入顺序，序列4,5,3,2,1是该压栈序列对应的一个弹出序列，但9,10,8,6,7就不可能是该压栈序列的弹出序列。（注意：这两个序列的长度是相等的）\n\n1.思路思路1 ：根据出栈顺序的特点循环判断 – &gt; O(n²) \n\n1.创建并初始化数组remindex元素全部为0，用来记录给定的弹出序列的各个元素，在初始给定的压栈序列中的位置（从1开始，均是正整数）；\n2.判断remindex中元素是否全部为0，如果是，说明给定的压栈序列和弹出序列中包含的元素并不相同，不是合法的序列；\n3.如果序列合法，就根据正确的弹出序列特性来进行判断给定弹出序列是否合法，任何出栈的元素后面出栈的元素必须满足以下三点：（1）在原序列中相对位置比它小的，必须是逆序（2）在原序列中相对位置比它大的，顺序没有要求（3）以上两点可以间插进行\n返回真假结果。\n\n思路2 ：借助栈，通过处理后栈的空满状态来判断 \n\n借用一个辅助的栈，遍历压栈顺序，先讲第一个放入栈中，这里是6；\n然后判断栈顶元素是不是出栈顺序的第一个元素，这里是9，很显然6≠9，所以我们继续压栈，直到相等以后开始出栈；\n出栈一个元素，则将出栈顺序向后移动一位，直到不相等，这样循环等压栈顺序遍历完成；\n如果辅助栈还不为空，说明弹出序列不是该栈的弹出顺序。\n\n2.代码（Java实现）思路1代码 ：根据出栈顺序的特点循环判断 – &gt; O(n²) \nimport java.util.ArrayList;\npublic class Main &#123;\n\tpublic static void main(String[] args) &#123;\n\t\t// 吧啦吧啦吧啦------创建对象，调用IsPopOrder()\n\t&#125;\n&#125;\nclass Solution &#123;\n    public boolean IsPopOrder(int [] pushA,int [] popA) &#123;\n    \tint len = pushA.length;\n        int [] remindex = new int[len];\t// 辅助数组\n        \n        for (int i = 0; i &lt; len; i++)&#123;\t// 记录位置\n            for (int j = 0; j &lt; len; j++)&#123;\n                if (popA[j] == pushA[i])&#123;\n                    remindex[j] = i + 1;\n                &#125;\n            &#125;\n        &#125;\n        int flag = 0;\t\t// 合法性标志\n        for (int i = 0; i &lt; len; i++)&#123;\n            if (remindex[i] != 0)&#123;\n                flag = 1;\t// 合法\n                break;\n            &#125;\n        &#125;\n        if (flag == 0)&#123;\t\t// 不合法\n            return false;\n        &#125;\n        \n        /**\n         * 任何出栈的元素后面出栈的元素必须满足以下三点：\n　　\t\t * 1、在原序列中相对位置比它小的，必须是逆序；\n\t\t * 2、在原序列中相对位置比它大的，顺序没有要求；\n\t\t * 3、以上两点可以间插进行。\n         */\n        for (int k = 0; k &lt; len - 1; k++)&#123;\n            for (int t = k + 1; t &lt; len; t++)&#123;\n                    if (remindex[t] &lt;= remindex[k] &amp;&amp; remindex[t] > remindex[t - 1])&#123;\n         \t\t\t\t// 不满足上面的特点 1\n                        return false;\n                    &#125;\n             &#125;\n        &#125;\n        return true;\t// 是一个合法的弹出序列\n    &#125;\n&#125;\n思路2 ：借助栈，通过处理后栈的空满状态来判断 \nimport java.util.ArrayList;\nimport java.util.Stack;\npublic class Solution &#123;\n    public boolean IsPopOrder(int [] pushA,int [] popA) &#123;\n  \t\t// 借助辅助栈\n        Stack&lt;Integer> stack= new Stack&lt;Integer>();\n        // 用于标识弹出序列的位置\n        int popIndex = 0;\n        for(int i = 0; i&lt; pushA.length;i++)&#123;\n        \t// 将压入序列中的元素依次入栈\n            stack.push(pushA[i]);\n            // 如果栈不为空，且栈顶元素等于弹出序列\n            while(!stack.empty() &amp;&amp; stack.peek() == popA[popIndex])&#123;\n                // 匹配出栈\n                stack.pop();\n                // 待对比查询的弹出序列下标后移 1 位\n                popIndex++;\n            &#125;\n        &#125;\n        // 辅助栈的空满刚好可以代弹出序列的正确性\n        return stack.empty();\t\n    &#125;\n&#125;\n","categories":["剑指offer"],"tags":["Java","栈"]},{"title":"LeetCode算法题2.两数相加","url":"/archives/7a0b06bd.html","content":"题目给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储一位 数字。如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。可以假设除了数字 0 之外，这两个数都不会以 0 开头。\n示例：\n输入：(2 -> 4 -> 3) + (5 -> 6 -> 4)\n输出：7 -> 0 -> 8\n原因：342 + 465 = 807\n\n解题思路1.确定解题方法对两个链表对应位置的元素进行求和，然后将最终处理好的和元素item尾插法插入新链表的对应节点中，遍历过程中若两个链表不等长，那么只需要把仍然存在的链表的元素尾插法放进新链表即可。2.提交前考虑到的问题（1）两数相加，要注意进位，设置flag代表进位，初始化为0，如果flag为1，说明有进位，item需要加1，加1后置flag为0（2）两数相加≥10的时候，flag置1，并且将item对10取余后的值存入链表3.测试时踩过的坑（1）新建的链表的时候需要有个值来初始化头结点，这个结点不出现在最后的结果链表中（2）最后一对节点的和需要进位的时候，需要处理这单独的1，新建一个val值为1的结点，把它尾插到当前结果链表的最后（3）最开始的坑，其实是解题方法不对，先遍历两个链表把数拼接起来，然后求和sum，再把sum的每一位尾插到新链表，这个方法的错误之处就在于不能解决很大的数据求和，超过int或者long的表示范围就很难受了。\n代码/**\n * Definition for singly-linked list.\n * public class ListNode &#123;\n *     int val;\n *     ListNode next;\n *     ListNode(int x) &#123; val = x; &#125;\n * &#125;\n */\nclass Solution &#123;\n    public ListNode addTwoNumbers(ListNode l1, ListNode l2) &#123;\n        int item = 0;\n    \tint flag = 0;\n    \tListNode res = new ListNode(0);\n        ListNode q = res;\n    \twhile(l1 !=null || l2 != null)&#123;\n    \t\tif(l1 !=null &amp;&amp; l2 !=null) &#123;\n    \t\t\titem = l1.val + l2.val;\n                l1 = l1.next;\n                l2 = l2.next;\n    \t\t&#125;\n    \t\telse if (l1 !=null &amp;&amp; l2 ==null ) &#123;\n    \t\t\titem = l1.val;\n                l1 = l1.next;\n    \t\t&#125;\n    \t\telse if (l1 ==null &amp;&amp; l2 !=null ) &#123;\n    \t\t\titem = l2.val;\n                l2 = l2.next;\n    \t\t&#125;\n            \n            if (flag == 1) &#123;\t// 判断是否有进位\n            \titem += 1;\t\t// 有进位就+1\n            \tflag = 0;\t\t// 进位标志符置为0\n            &#125;\n            if (item >= 10) &#123;\t// 判断是否能产生进位\n            \tflag = 1;\t\t// 能产生进位就置flag为1\n            \titem = item % 10;\t// 只保留item的个位的数值\n            &#125;\n            ListNode p = new ListNode(item);\n            q.next = p;\t\t\t// 尾插法\n            q = q.next; \t\t// 让q始终指向的是结果链表res的尾部\n        &#125;\n        // 已有元素求和完毕后，如果进位标志符仍然为1，说明和的位数增加了\t\t\n        // 一位，新链表的长度比原来的两个链表中的最长的一个还需要多一个\t\n        // 结点，且结点的val值为1。\n    \tif (flag == 1) &#123;\t\t\n    \t\tq.next = new ListNode(flag);\n            q.next.next = null;\n    \t&#125;\n        return res.next;\n    &#125;\n&#125;\n官方题解链接\n","categories":["LeetCode"],"tags":["Java","数值计算","LeetCode","面试"]},{"title":"LeetCode精选TOP面试题104.二叉树的最大深度","url":"/archives/b88b3653.html","content":"题目描述给定一个二叉树，找出其最大深度。二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。说明: 叶子节点是指没有子节点的节点。示例：给定二叉树 [3,9,20,null,null,15,7]返回它的最大深度 3 。\n\n思路思路1非递归借助任意一种二叉树的遍历方法进行最大深度的求解，先序、中序、后续都可以，代码大体流程是相同的，层次遍历的话是单独的模式。借助两个栈，一个存储当前结点，一个存储当前结点的深度，那么通过比较当前深度与最大深度，不断更新最大深度，当遍历结束后，就可以直接返回最大深度了。思路2递归递归的方法也不难理解，当遇到叶子节点就返回0 （这也是这个递归程序的边界） ，否则继续递归，并返回深度值加1。理解不了的画个递归的图解就行了。\n代码（Java实现）1.非递归代码\nimport java.util.Stack;\npublic class Solution &#123;\n    public int maxDepth(TreeNode root) &#123;\n        if (root == null)&#123;\n       \t\t// 空树，深度是0\n            return 0;\n        &#125;\n        \n        // 前序遍历 - 借助栈\n        Stack&lt;TreeNode> stack = new Stack&lt;TreeNode>();// 存放结点\n        Stack&lt;Integer> remDeep = new Stack&lt;Integer>();// 存放深度\n\t\t\n\t\t// 定义一个新的结点指向目标树的根节点，用于遍历\n        TreeNode tmp = root;\n        int maxDepth = 0；\t// 记录最大深度\n        int curDepth = 0;\t// 记录遍历时的‘当前’深度\n\n        curDepth ++ ;\t\t// 树不空，当前深度肯定>=1，所以先加上1\n        // 先序遍历的模式\n        while (!stack.isEmpty() || tmp != null)&#123;\n            while (tmp != null)&#123;\n            \t// 不断向左\n                stack.add(tmp);\n                remDeep.add(curDepth);\n                tmp = tmp.left;\n                curDepth ++;\n            &#125;\n            \n            tmp = stack.pop();\t\t\t// 退回到当前结点的双亲节点\n            curDepth = remDeep.pop();\t// 当前深度也退回到双亲节点所在的深度\n            if (tmp.right == null &amp;&amp; tmp.left == null)&#123;\n                if (curDepth > maxDepth)&#123;\n                \t// 更新最大深度\n                    maxDepth = curDepth;\t\n                &#125;\n            &#125;\n            tmp = tmp.right; // 访问右子树\n            curDepth ++;\t // 当前深度+1\n        &#125;\n        return maxDepth;\n    &#125;\n&#125;\n2.递归代码\npublic class Solution2 &#123;\n    public int maxDepth(TreeNode root) &#123;\n        if (root == null)&#123;\t\t// 叶子节点是边界值\n            return 0;\t\n        &#125;\n        else &#123;\n            int ldepth = maxDepth(root.left);\t// 递归求左子树深度\n            int rdepth = maxDepth(root.right);\t// 递归求右子树深度\n            // 哪个大哪个就是当前子树的最大深度，\n            // 层层返回之后就是目标数的最大深度\n            return ldepth > rdepth ? ldepth + 1 : rdepth + 1;\n        &#125;\n    &#125;\n&#125;\n","categories":["LeetCode"],"tags":["Java","LeetCode","遍历","二叉树","DFS","BFS"]},{"title":"【剑指offer】面试题27-二叉树的镜像","url":"/archives/1a194623.html","content":"题目操作给定的二叉树，将其变换为源二叉树的镜像。\n\n1.思路（1）借助队列，完成二叉树的层次遍历；（2）在遍历过程中，每遇到一个节点，就将它的左右子树的根结点入队，然后进行互换；（3）这样就能保证每一个结点的左右子树都被镜像了一次，当遍历结束时，整个二叉树就被镜像了。\n2.代码（Java实现）import java.util.LinkedList;\nimport java.util.Queue;\n\npublic class Main &#123;\n\t// 这里提供一个简单的测试样例\n\t//       2\n\t//     /   \\\n\t//    1     3\n\tpublic static void main(String[] args) &#123;\n\t\t// TODO Auto-generated method stub\n\t\tSolution solution = new Solution();\n\t\tTreeNode root = new TreeNode(2);\n\t\troot.left = new TreeNode(1);\n\t\troot.right = new TreeNode(3);\n\t\tsolution.Mirror(root);\n\t\tSystem.out.println(root.val);\n\t\tSystem.out.println(root.left.val);\n\t\tSystem.out.println(root.right.val);\n\t&#125;\n&#125;\n\nclass TreeNode &#123;\n\tint val = 0;\n\tTreeNode left = null;\n\tTreeNode right = null;\n\tpublic TreeNode(int val) &#123;\n\t\tthis.val = val;\n\t&#125;\n&#125;\n\nclass Solution &#123;\n\tpublic void Mirror(TreeNode root) &#123;\n\t\tif (root != null) &#123;\n\t\t\t// 层次遍历 逐层镜像\n\t\t\tQueue&lt;TreeNode> queue = new LinkedList&lt;TreeNode>();\n\t\t\tqueue.add(root);\n\t\t\twhile (!queue.isEmpty()) &#123;\n\t\t\t\tTreeNode p = queue.poll();\n\t\t\t\tif (p.left != null) &#123;\n\t\t\t\t\t// 左子树不空则入队\n\t\t\t\t\tqueue.add(p.left);\n\t\t\t\t&#125;\n\t\t\t\tif (p.right != null) &#123;\n\t\t\t\t\t// 右子树不空则入队\n\t\t\t\t\tqueue.add(p.right);\n\t\t\t\t&#125;\n\t\t\t\t// 将当前访问的结点的左右子树进行镜像\n\t\t\t\tTreeNode tmp = p.left;\n\t\t\t\tp.left = p.right;\n\t\t\t\tp.right = tmp;\n\t\t\t&#125;\n\t\t&#125;\n\t&#125;\n&#125;\n\n苏大计算机考研，数据结构曾经考过原题\n\n","categories":["剑指offer"],"tags":["Java","遍历","二叉树"]},{"title":"LeetCode精选TOP面试题237.删除链表中的结点","url":"/archives/9a53ad75.html","content":"题目描述请编写一个函数，使其可以删除某个链表中给定的（非末尾）节点，你将只被给定要求被删除的节点。现有一个链表 – head = [4,5,1,9]，它可以表示为:\n示例 1:\n输入: head = [4,5,1,9], node = 5\n输出: [4,1,9]\n解释: 给定你链表中值为 5 的第二个节点，那么在调用了你的函数之后，该链表应变为 4 -> 1 -> 9.\n示例 2:\n输入: head = [4,5,1,9], node = 1\n输出: [4,5,9]\n解释: 给定你链表中值为 1 的第三个节点，那么在调用了你的函数之后，该链表应变为 4 -> 5 -> 9.\n\n说明:\n链表至少包含两个节点。\n链表中所有节点的值都是唯一的。\n给定的节点为非末尾节点并且一定是链表中的一个有效节点。\n不要从你的函数中返回任何结果。\n\n思路\n踩坑了踩坑了，这跟脑筋急转弯似的，给的直接是要删除的结点，参数里连原链表都没传进来，所以只能是按照偷梁换柱的路子来做。\n\n1.修改前结点的值（偷梁），把当前结点的next结点的值复制过来，即node.value = node.next.val;2.修改当前结点的后继指针（换柱），让它指向它的后继节点的后继节点，即node.next = node.next.next；\n代码（Java）/**\n * Definition for singly-linked list.\n * public class ListNode &#123;\n *     int val;\n *     ListNode next;\n *     ListNode(int x) &#123; val = x; &#125;\n * &#125;\n */\nclass Solution &#123;\n    public void deleteNode(ListNode node) &#123;\n        ListNode latter = node.next;\n        node.val = latter.val;\t\t// 偷梁\n        node.next = latter.next;\t// 换柱\n        latter.next = null;\n    &#125;\n&#125;\n\n如果正常题目，可能会参数给一个链表，一个指定值，然后我们遍历找到与指定值相等的结点元素值，在此过程中也始终记录前驱结点，这样修改前驱结点的后继指针来删除确定的结点。\n\n","categories":["LeetCode"],"tags":["Java","LeetCode","遍历","链表"]},{"title":"【剑指offer】面试题26-树的子结构","url":"/archives/88c06e29.html","content":"题目输入两棵二叉树A，B，判断B是不是A的子结构。（ps：我们约定空树不是任意一个树的子结构）\n\n1.思路\n最开始用自己的思路，没有做对。我的思路是分别对两个树进行先/中/后序遍历，并将结点的值追加到字符串里，最后判断字符串1是否包含字符串2，包含就是子树，反之则不是。后来想了想，可能会出现并不是子树，但是先序遍历后其字符串顺序的确是会出现子串关系的情况。还是太菜了。。。\n\n剑指offer的思路：1. 首先设置标志位result = false，因为一旦匹配成功result就设为true，剩下的代码不会执行，如果匹配不成功，默认返回false；2. 递归思想，如果根节点相同则递归调用DoesTree1HaveTree2()，如果根节点不相同，则判断tree1的左子树和tree2是否相同，再判断右子树和tree2是否相同；3. HasSubTree中，若两棵树都不为空才进行判断，DoesTree1HasTree2中，若Tree2为空，则说明第二棵树遍历完了，即匹配成功，tree1为空有两种情况（1）如果tree1为空&amp;&amp;tree2不为空说明不匹配，（2）如果tree1为空，tree2为空，说明匹配。\n2. 代码（Java实现）// 剑指offer的\npublic class Solution&#123;\n    public boolean HasSubtree(TreeNode root1,TreeNode root2) &#123;\n        boolean result = false;\n        if(root1 != null &amp;&amp; root2 != null)&#123;\n             if(root1.val == root2.val)&#123;\n                 result = DoesTree1HaveTree2(root1,root2);\n             &#125;\n             if(!result)&#123;\n                 result = HasSubtree(root1.left, root2);\n             &#125;\n             if(!result)&#123;\n                 result = HasSubtree(root1.right, root2);\n             &#125;\n         &#125;\n         return result;\n    &#125;\n    public boolean DoesTree1HaveTree2(TreeNode root1,TreeNode root2)&#123;\n            if(root2 == null) \n                return true;\n            if(root1 == null) \n                return false;\n            if(root1.val != root2.val) \n                return false;\n            return DoesTree1HaveTree2(root1.left, root2.left) &amp;&amp; DoesTree1HaveTree2(root1.right, root2.right);\n     &#125;\n&#125;","categories":["剑指offer"],"tags":["Java","遍历","递归","二叉树"]},{"title":"笔试题1-根据投资关系确定股东和股东之间是否有关联","url":"/archives/cee74ffa.html","content":"\n题目来源：2020年2月某国企校招其中一道编程笔试题回忆。备注：笔试的时候并没有做出来，现在的代码不能保证没有逻辑错误，请各位大佬批评指正，感谢！\n\n题目回忆Pi代表股东，Ej代表公司（其中 i 和 j 代表正整数），Pi可以投资不同的Ej，这样就导致Pi和Ej之间是多对多的关系。  股东之间有关联 的定义如下：①Pi与其本身有关联；②如果Px投资了Ej，并且Py也投资了Ej，则Px和Py有关联。\n输入样例\nP2；P1，E1；P2，E1，E2；P3，E3\n其中第一个分号之前只有一个Pi，是目标股东；\n我们要做的就是找出所有和Pi有关联的股东；\n之后的每一个分号，分割了每个股东及其投资的公司。\n\n对输入样例就可以解释为：\n已知P1投资了E1；P2投资了E1、E2；P3投资了E3；\n求所有和股东P2有关联的股东。\n输出结果：\nP1，P2\n输出结果要按照字典序从小到大的顺序输出，相邻两个股东之间用逗号分隔。\n\n思路1. 借助split方法对输入的字符串按照分号进行分割，获取目标股东以及每个股东和他投资的所有公司；2. 计算一共有多少投资人；3. 借助HashMap&lt;String, String&gt; 来记录每个股东人与他所投资的公司之间的对应关系，将每个投资人作为key，这个投资人投资的所有公司的输入顺序子串作为value存储起来，如输入样例中有三组键值对，分别是 &lt;key：”P1”，value：”E!”&gt;，&lt;key：”P2”，value：”E1,E2”&gt;，&lt;key：”P3”，value：”E3”&gt; ；将这个Map命名为result；4. 确定目标股东在字符串的位置，并将他记录下来；5. 遍历result的key，找到目标股东对应的那一组键值对，如样例输入中会找到&lt;key：”P2”，value：”E1,E2”&gt;，找到之后，把这一个键值对的value值，按照逗号 “,” 进行分割，这样会得到目标股东投资的所有公司，把这些公司逐个记录到列表listval中；6. 双重循环，外层遍历列表listval，取出目标股东投资的所有公司名称Ez ，挨个与之前创建的Map（即result）中的所有键值对的value值进行比对，如果result的某一个键值对的value值（是一个字符串）中包含Ez这个子串，那么就把这个键值对的key值添加进listkey中记录下来，listkey是用TreeSet定义的；7. 之所以要用TreeSet是因为我们要做到有序输出，而且Set中不会包含重复元素的，重复元素添加是不被完成的；8. 按照输出要求对listkey进行遍历输出。\n代码import java.util.HashMap;\nimport java.util.IdentityHashMap;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Scanner;\nimport java.util.TreeSet;\n\npublic class Main &#123;\n\n\tpublic static void main(String[] args) &#123;\n\t\t// TODO Auto-generated method stub\n\t\tScanner in = new Scanner(System.in);\n\t\tString str = in.next();\n\t\t// 借助split方法对输入的字符串按照分号进行分割，获取目标股东以及每个股东和他投资的所有公司\n\t\tString [] relation = str.split(\";\");\n\t\t// 计算一共有多少投资人\n\t\tint count = -1;\n\t\tfor (String s : relation) &#123;\n\t\t\tcount ++;\n\t\t&#125;\t\t\n\t\t// 借助HashMap来记录每个股东人与他所投资的公司之间的对应关系\n\t\tMap&lt;String, String> result = new HashMap&lt;String, String>();\n\t\t// 将每个投资人作为key，这个投资人投资的所有公司的输入顺序子串作为value存储起来\n\t\tfor (int i = 1; i &lt;= count; i++) &#123;\n\t\t\t// 定位投资人\n\t\t\tString pp = relation[i].substring(0, 2); \n\t\t\t// 定位该投资人投资的所有公司组成的字符串\n\t\t\tresult.put(pp, relation[i].substring(3, relation[i].length()));\n\t\t&#125;\n\t\t\n\t\t// 确定目标股东在字符串的位置\n\t\tint i = 0;\n\t\tfor (i = 0; i &lt; str.length(); i++) &#123;\n\t\t\tif (str.charAt(i) == ';') &#123;\n\t\t\t\tbreak;\n\t\t\t&#125;\n\t\t&#125;\n\t\t// 将目标股东target记录下来\n\t\tString target = str.substring(0, i);\n\t\t\n\t\t// listval用来记录目标股东投资的所有公司\n\t\tList&lt;String> listval = new LinkedList&lt;String>();\t\n\t\t// listkey用来记录与目标股东有关联的所有股东（包含他自己）\n\t\tTreeSet&lt;String> listkey = new TreeSet&lt;String>();\n\t\tfor (String key : result.keySet()) &#123;\n\t\t\t// 输出检查有没有出错 : System.out.println(key + \" \" + result.get(key) + \" \");\n\t\t\tif (key.equals(target)) &#123;\t// 找到目标股东对应的那一组键值对\n\t\t\t\t// 把这一个键值对的value值，按逗号进行分割，这样会得到目标股东投资的所有公司\n\t\t\t\tString [] relationee = result.get(key).split(\",\");\n\t\t\t\t\n\t\t\t\t// 把目标股东投资的所有公司都添加到listval列表中用于后期的对比\n\t\t\t\tfor (int index = 0; index &lt; relationee.length; index++) &#123;\n\t\t\t\t\tlistval.add(relationee[index]);\n\t\t\t\t\t// 输出检查有没有出错 : System.out.print(relationee[index] + \" \" + index + '\\n');\n\t\t\t\t&#125;\n\t\t\t&#125;\n\t\t&#125;\n\t\t\n\t\t// 遍历列表listval，取出目标股东投资的所有公司名称\n\t\tfor(Object one : listval) &#123; \n\t\t\t// 输出检查有没有出错 : System.out.println(one.toString());\n\t\t\tfor (Map.Entry&lt;String, String> entry : result.entrySet()) &#123;\n\t\t\t\t// 目标股东投资的所有公司名称挨个与之前创建的Map（即result）中的所有键值对的value值进行比对，\n\t\t\t\t// 如果result的某一个键值对的value值（是一个字符串）中包含Ez这个子串，\n\t\t\t\t// 那么就把这个键值对的key值添加进**listkey**中记录下来\n\t\t\t\t// 输出检查有没有出错 : System.out.println(entry.getValue() + \" entry.getValue()\");\n\t\t\t\tif (entry.getValue().contains(one.toString())) &#123;\n\t\t\t\t\tlistkey.add(entry.getKey().toString());\n\t\t\t\t\t// 输出检查有没有出错 : System.out.println(entry.getKey() + \" key \");\n\t\t\t\t&#125;\n\t\t\t&#125;\n\t\t&#125;\n\t\t\n\t\t// 按照输出要求对listkey进行遍历输出\n\t\tSystem.out.print(listkey.pollFirst());\n\t\twhile(!listkey.isEmpty()) &#123;\n\t\t\tSystem.out.print(\",\" + listkey.pollFirst());\n\t\t&#125;\n\t\t//输入样例:  P2;P1,E1;P2,E1,E2;P3,E3\n\t\t//输出样例:  P1,P2\n\t&#125;\n&#125;","categories":["笔试题"],"tags":["Java","字符串","哈希表","链表"]},{"title":"【剑指offer】面试题25-合并两个排序的链表","url":"/archives/2b7e4ff.html","content":"题目输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则。\n\n1.思路（1）创建一个新链表newlist，尾插法不断将原来的两个链表的结点拼接到其尾部。（2）当两个链表均不空，同时遍历两个链表，进行元素大小判断，摘下元素值较小的结点尾插到newlist，同时指针后移继续比较。（3）循环跳出的时候有三种情况①两个链表都到头了，不需要继续处理；②list1没到头，newlist.next直接指向list1的剩余结点就好，因为原本就是有序单调递增的；③list2没到头，newlist.next直接指向list2的剩余结点就好。（4）返回新的合并后的单调递增的链表\n2.代码（Java实现）public class Solution &#123;\n    public ListNode Merge(ListNode list1,ListNode list2) &#123;\n        ListNode newlist = new ListNode(10086);\n    \tListNode newindex = newlist;\n    \tListNode index1 = list1;\n    \tListNode index2 = list2;\n    \t// 两个链表均不空\n    \twhile(list1 != null &amp;&amp; list2 != null) &#123;\n    \t\tif(list1.val &lt; list2.val) &#123;\n    \t\t\t// list1 比 list2 的元素值小\n    \t\t\tindex1 = index1.next;\n    \t\t\tlist1.next = newindex.next;\n    \t\t\tnewindex.next = list1;\n    \t\t\tnewindex = newindex.next;\n    \t\t\tlist1 = index1;\n    \t\t\t\n    \t\t&#125;else &#123;\n    \t\t\t// list2 比 list1 的元素值小\n    \t\t\tindex2 = index2.next;\n    \t\t\tlist2.next = newindex.next;\n    \t\t\tnewindex.next = list2;\n    \t\t\tnewindex = newindex.next;\n    \t\t\tlist2 = index2;\n    \t\t&#125;\n    \t&#125;\n    \tif(list1 != null) &#123;\n    \t\t// list1不空\n    \t\tnewindex.next = list1;\n    \t&#125;else &#123;\n    \t\t// list2不空\n    \t\tnewindex.next = list2;\n    \t&#125;\n    \treturn newlist.next;\n    &#125;\n&#125;\n\n苏州大学计算机考研依然考过这个题，手写代码实现。\n\n","categories":["剑指offer"],"tags":["Java","遍历","链表","指针"]},{"title":"LeetCode精选TOP面试题7.整数反转","url":"/archives/31b79d53.html","content":"题目描述给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。\n示例 1:\n输入: 123\n输出: 321\n\n 示例 2:\n输入: -123\n输出: -321\n\n示例 3:\n输入: 120\n输出: 21\n假设我们的环境只能存储得下 32 位的有符号整数，则其数值范围为 [−231,  231 − 1]。请根据这个假设，如果反转后整数溢出那么就返回 0。LeetCode解题思路原文\n\n解题思路(1) 先不考虑正负号的问题，将输入的整数用StringBuilder进行逐位记录，然后对其是否溢出进行判断，借助long类型的数暂时接收反转后的数，进行合法性判断，最终返回合法的反转整数。(2) 在解题时会有很多需要注意的情况：①原数不合法；②原数合法，反转后不合法；③直接将负数边界值单独拿出来讨论，不晓得为什么在eclipse不单独判断也能对，但是LeetCode线上是错的，可能是我有什么地方没考虑到。\n\nPS：各位看官老爷如果晓得上面的③是什么原因麻烦帮我解答一下疑惑，感激不尽！\n\n代码（Java实现）import java.util.Scanner;\npublic class Main &#123;\n\tpublic static void main(String[] args) &#123;\n\t\t// TODO Auto-generated method stub\n\t\tSolution solution = new Solution();\n\t\tScanner in = new Scanner(System.in);\n\t\tint result = solution.reverse(in.nextInt());\n\t\tSystem.out.println(result);\n\t&#125;\n&#125;\nclass Solution &#123;\n\tpublic int reverse(int x) &#123;\n\t\tint temp = x;\n\t\tStringBuffer str = new StringBuffer();\n\t\tif (x == -2147483648) &#123;\n\t\t\treturn 0;\n\t\t&#125;\n\t\tif (x &lt; 0) &#123;\n\t\t\tx = -x;\n\t\t&#125; else if (x == 0) &#123;\n\t\t\treturn 0;\n\t\t&#125;\n\t\twhile (x != 0) &#123;\n\t\t\tstr.append(x % 10);\n\t\t\tx /= 10;\n\t\t&#125;\n\t\t// 借助long类型的数暂时接收反转后的整数\n\t\tlong res = Long.parseLong(str.toString());\n\t\t// 原数是负数，且转换后溢出\n\t\tif (temp &lt; 0 &amp;&amp; res > 2147483647) &#123;\n\t\t\treturn 0;\n\t\t&#125;\n\t\t// 原数是正数，且转换后溢出，因为这里直接使用2147483647会报错，提示超出范围，\n\t\t// 所以我们用相反数进行合法性判定\n\t\tif (temp > 0 &amp;&amp; -res &lt; -2147483648) &#123;\n\t\t\treturn 0;\n\t\t&#125;\n\t\t// 将符号补上\n\t\tif (temp &lt; 0) &#123;\n\t\t\tres = -res;\n\t\t&#125;\n\t\treturn (int) res;\n\t&#125;\n&#125;\nLeetCode官方题解\n","categories":["LeetCode"],"tags":["Java","LeetCode","面试","整数"]},{"title":"【剑指offer】面试题24-反转链表","url":"/archives/ec1cf20c.html","content":"题目输入一个链表，反转链表后，输出新链表的表头。\n\n1.思路思路1遍历链表，将链表的结点逐个摘下，用尾插法拼接到新的空链表尾部。思路2遍历两次链表：第一次遍历链表，找到链表的最后一个结点lastnode；第二次遍历链表，把链表的结点逐个用头插法拼接到lastnode之后。\n2.代码（Java实现）解题代码在第三部分，三部分组成完整的代码。\n\npublic class Main &#123;\n\tpublic static void main(String[] args) &#123;\n\t\tListNode head = new ListNode(0);\n\t\tListNode tail = head;\n\t\t// 尾插法创建一个简单的链表\n\t\tfor (int i = 1; i &lt; 5; i++) &#123;\n\t\t\tListNode p = new ListNode(i);\n\t\t\ttail.next = p;\n\t\t\ttail = tail.next;\n\t\t&#125;\n\t\tListNode check = head;\n\t\twhile(check != null) &#123;\n\t\t\tSystem.out.print(check.val + \" \");\n\t\t\tcheck = check.next;\n\t\t&#125;\n\t\tSolution solution = new Solution();\t\t\n\t\t// 输出检查链表是否逆置\n\t\tListNode checks = solution.ReverseList(head);\n\t\twhile(checks != null) &#123;\n\t\t\tSystem.out.print(checks.val + \" \");\n\t\t\tchecks = checks.next;\n\t\t&#125;\n\t\t\n\t&#125;\n&#125;\nclass ListNode&#123;\n\t// 链表结点数据结构\n    int val;\n    ListNode next = null;\n    ListNode(int val) &#123;\n        this.val = val;\n    &#125;\n&#125;\n// 方法 1：借助新的空链表，尾插法逆置\nclass Solution &#123;\n\tpublic ListNode ReverseList(ListNode head) &#123;\n\t\t// 创建空链表  \n\t\tListNode old = head;\n\t\tListNode temp = null;\n\t\tListNode flag = null;\n\t\t// 尾插法创建链表\n\t\twhile(old != null) &#123;\n\t\t\ttemp = old;\n\t\t\told = old.next;\n\t\t\ttemp.next = flag;\n\t\t\tflag = temp;\n\t\t&#125;\n\t\treturn flag;*/\n\t\tif (head == null) &#123;\n\t\t\treturn null;\n\t\t&#125;\n\t\tListNode result = head;\n\t\twhile(result.next != null) &#123;\n\t\t\tresult = result.next;\n\t\t&#125;\n\t\t\n\t\tListNode index = head;\n\t\tListNode item = null;\n\t\t// 头插法创建链表\n\t\twhile(index != result) &#123;\n\t\t\titem = index;\n\t\t\tindex = index.next;\n\t\t\titem.next = result.next;\n\t\t\tresult.next = item;\n\t\t&#125;\n\t\treturn result;\n    &#125;\n&#125;\n// 方法 2：头插法，只靠原链表完成逆置\nclass Solution &#123;\n\tpublic ListNode ReverseList(ListNode head) &#123;\n\t\tif (head == null) &#123;\t// 判断链表是否为空\n\t\t\treturn null;\n\t\t&#125;\n\t\tListNode result = head;\n\t\t// 遍历找到链表的最后一个结点\n\t\twhile(result.next != null) &#123;\n\t\t\tresult = result.next;\n\t\t&#125;\n\t\tListNode index = head;\n\t\tListNode item = null;\n\t\t// 头插法逆置链表\n\t\twhile(index != result) &#123;\n\t\t\titem = index;\n\t\t\tindex = index.next;\n\t\t\titem.next = result.next;\n\t\t\tresult.next = item;\n\t\t&#125;\n\t\treturn result;\n    &#125;\n&#125;\n","categories":["剑指offer"],"tags":["Java","遍历","递归","迭代","链表"]},{"title":"【剑指offer】面试题22-链表的倒数第k个结点","url":"/archives/e31dcbb2.html","content":"题目输入一个链表，输出该链表中倒数第k个结点。\n\n1. 思路第一次遍历链表，计算链表长度length；第二次遍历链表，让指针向后移动length - k次，就可以得到倒数第k个结点。\n2.代码（Java实现/* 链表结点的数据结构\npublic class ListNode &#123;\n    int val;\n    ListNode next = null;\n    ListNode(int val) &#123;\n        this.val = val;\n    &#125;\n&#125;*/\npublic class Solution &#123;\n    public ListNode FindKthToTail(ListNode head,int k) &#123;\n        if (head == null) &#123;\t// 空链表，返回null\n        \treturn null;\t\n        &#125;\n    \tListNode p = head, r = head;\n        int  len = 0;\n        while(r != null)&#123;\n            r = r.next;\n            len ++;\t\t\t// 计算链表长度\n        &#125;\n        if (len &lt; k)&#123;\t\t// 判断k值是否合法\n            return null;\t// 如果k值比链表长度还大，不合法，返回null\n        &#125;\n        for (int i = 0; i &lt; len - k; i++) &#123;\n        \tp = p.next;\t\t// 指针向后移动length-k次。得到目标结点\n        &#125;   \n        return p;\n    &#125;\n&#125;\n补充如果我们输入的链表和k值都合法，那么这个题其实用下面的说法更好理解一些。思路设两个指针first 和second ，初始时均指向头结点，first 向后移动k - 1次，此时first 指向的是正数第k个结点，在这之后，当first的后继节点不为空时，second和first就同时后移，当first的后继节点为空，就说明first已经指向了链表的尾结点，那此时second指向的结点，就是倒数第k个结点，因为first和second之间的距离刚好是k-1。各位看官老爷画图看看就会明白了，很容易理解。代码\nclass Solution &#123;\n    public ListNode FindKthToTail(ListNode head,int k) &#123;\n    \tif (head == null) &#123;\n        \treturn null;\n        &#125;\n    \tListNode first = head, second = head;\n    \tint count = 1;// 计数器count，初始化为1，因为已经指向了头结点\n        while(first.next != null) &#123;\n        \tif (count &lt; k)\t\t\t\t// first先后移走 k - 1 次\n        \t\tcount ++;\n        \telse &#123;\n        \t\tsecond = second.next; \t// second跟随后移\n        \t&#125;\n        \tfirst = first.next;\n        &#125;  \n        return r;\n    &#125;\n&#125;\nPS：印象里苏大计算机考研有个编程题是写这个，倒数第k个结点。\n","categories":["剑指offer"],"tags":["Java","遍历","链表","指针"]},{"title":"【剑指offer】面试题21-调整数组顺序使奇数位于偶数前面","url":"/archives/7110c12.html","content":"题目输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于数组的后半部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变。\n\n1.思路思路1： 插入排序   —-  时间O(n²)，空间O(1)双重循环，遇到偶数在前奇数在后的相邻两个元素就马上进行交换；这样能保证交换后奇数与奇数之间、偶数与偶数之间相对前后位置不变，即保证排序的稳定性。思路2： 牺牲空间换时间    —-   时间O(n)，空间O(n)新建两个数组，分别用来存放原数组中的奇数、偶数；然后再将这两个数组的元素重新赋值给原数组，即筛选–分类–覆盖。从原数组中筛选奇、偶数；分类到奇数数组和偶数数组中分别存放；依次将奇数数组元素、偶数数组元素重新写回原数组去覆盖原数组的值。\n2.代码（Java实现）// 思路1.插入排序排序\nclass Solution &#123;\n\tpublic void reOrderArray(int [] array) &#123;\n\t\t// 1.插入排序排序\n\t\tfor(int i = 0;i &lt; array.length - 1; i ++)&#123;\n            for(int j = 0; j &lt; array.length-1-i; j ++)&#123;\n                if(array[j] % 2 == 0 &amp;&amp; array[j + 1] % 2 != 0)&#123;\n                    int t = array[j];\n                    array[j] = array[j + 1];\n                    array[j + 1] = t;\n                &#125;\n            &#125;\n        &#125;\n    &#125;\n&#125;\nclass Solution &#123;\n\tpublic void reOrderArray(int [] array) &#123;\n\t\t// 思路2. 空间换时间\n\t\tint len1 = 0,len2 = 0;\n\t\tfor (int i = 0; i &lt; array.length ; i ++)&#123;\n            if (array[i] % 2 != 0)&#123;\n                len1 ++;\n            &#125;\n            if (array[i] % 2 == 0)&#123;\n                len2 ++;\n            &#125;\n        &#125;\n\t\tint []odd = new int[len1];\n        int []even = new int[len2];\n        int j = 0,k = 0;\n        for (int i = 0; i &lt; array.length ; i ++)&#123;\n            if (array[i] % 2 != 0)&#123;\n                odd[j++] = array[i];\n            &#125;\n            if (array[i] % 2 == 0)&#123;\n                even[k++] = array[i];\n            &#125;\n        &#125;\n        for (int i = 0; i &lt; len1; i ++)&#123;\n             array[i] = odd[i] ;\n        &#125;\n        for (int i = 0; i &lt; len2; i ++)&#123;\n             array[len1 + i] = even[i] ;\n        &#125;\n    &#125;\n&#125;\n开始解题的时候没有考虑到保证稳定性，使用了类似于简单选择排序的方法，如果不要求稳定性，那么这个方法还是不错的。时间复杂度O(n),空间复杂度O(1)思路：（1）前后各设一个游标，前为i，后为j；（2）当array[i]是奇数，i后移，当array[j]是偶数，j前移，当array[i]是偶数    且array[j]是奇数，两者互换；（3）i &lt;= j为限定条件。代码\npublic class Solution &#123;\n    public void reOrderArray(int [] array) &#123;\n        for (int i = 0, j = array.length - 1; i &lt;= j ; i ++, j --) &#123;\n            if(array[i] % 2 != 0) &#123;\n                i ++;\n            &#125;\n            if(array[j] % 2 == 0) &#123;\n                j --;\n            &#125;\n            if (array[i] % 2 == 0 &amp;&amp; array[j] % 2 != 0) &#123;\n                int temp = array[i];\n                array[i] = array[j]; \n                array[j] = array[i]; \n            &#125;\n        &#125;\n    &#125;\n&#125;\n","categories":["剑指offer"],"tags":["Java","数组","排序","奇偶性"]},{"title":"【剑指offer】面试题16-数值的整数次方","url":"/archives/bd1d9b76.html","content":"题目给定一个double类型的浮点数base和int类型的整数exponent。求base的exponent次方。保证base和exponent不同时为0。\n\n1 思路思路1： 借助Java的函数 Math.pow(base, exponent)，直接可以返回结果思路2：（1）手动实现求整数次方，借助循环，累乘，得到积result；（2）判断指数的正负，若是正数则result就是最终结果，若是负数，则用1.0除以result得到最终result。\n2. 代码public class Solution &#123;\n\tpublic double Power(double base, int exponent) &#123;\n\t\t// 思路1，借助函数\n\t\t// return Math.pow(base, exponent);\n\t\t\n\t\t// 思路2 手动实现\n\t\t// 保证base和exponent不同时为0\n\t\tif (base == 0) &#123;\n\t\t\treturn 0.0;\n\t\t&#125;\n\t\tif (base != 0 &amp;&amp; exponent == 0) &#123;\n\t\t\treturn 1.0;\n\t\t&#125;\n\t\tdouble result = 1.0;\n\t\tfor (int i = 1; i &lt;= Math.abs(exponent); i++) &#123;\n\t\t\tresult *= base;\n\t\t&#125;\n\t\tif (exponent &lt; 0) &#123;\n\t\t\tresult = 1.0  / result;\n\t\t&#125;\n\t\treturn result;\n\n\t&#125;\n&#125;\n","categories":["剑指offer"],"tags":["Java","数值计算"]},{"title":"【剑指offer】面试题15-二进制中1的个数","url":"/archives/afdcdcc9.html","content":"题目输入一个整数，输出该数二进制表示中1的个数。其中负数用补码表示。\n\n1.思路1.借助Java的Integer.toBinaryString()函数，将十进制数转成二进制字符串str；2.for循环，循环str.length()次，遇到字符1（用单引号不是双引号哦）时，计数器就加一；3.返回计数器sum\n2.代码（Java）public class Solution &#123;\n\tpublic int NumberOf1(int n)&#123;\n\t\tint sum = 0;\n\t\tString str  = Integer.toBinaryString(n);\n\t\tfor (int i = 0; i &lt; str.length(); i ++) &#123;\n\t\t\tif (str.charAt(i) == '1') &#123;\n\t\t\t\tsum ++;\n\t\t\t&#125;\n\t\t&#125;\n\t\treturn sum;\n\t&#125;\n&#125;\n\nPS：下面是手动实现十进制转二进制的代码\nStringBuffer strs = new StringBuffer(); \n// strs用来存储转换后的二进制数\nif (n &lt; 0) &#123;\t\n\t// 如果是负数，用移位的方法方便理解。\n\t// 将最高位的数移至最低位（移31位），除过最低位其余位置清零，\n\t// 使用 &amp; 操作符，与 1 相与\n\t// 因为1在内存中除过最低位是1，其余31位都是零，\n\t// 然后把这个数按十进制输出；再移次高位，\n\t// 重复以上操作，直到最后一位\n\tfor(int i = 31;i >= 0; i--)\n         strs.append(n >>> i &amp; 1);\n\t\n&#125;else &#123; \n\t// 如果是正数，用while循环不断对2取余\n\t// 并将取余结果保存下来前插进strs\n\twhile (n != 0) &#123;\n\t\tstrs.insert(0, n % 2);\n\t\tn /= 2;\n\t&#125;\n&#125;\n\nSystem.out.print(strs);  // 检查转换后的二进制数是否正确\n// for 循环统计二进制中 1 的个数\nfor (int i = 0; i &lt; strs.length(); i++) &#123;\n\tif (strs.charAt(i) == '1') &#123;\n\t\tsum++;\n\t&#125;\n&#125;\n","categories":["剑指offer"],"tags":["Java","进制转换"]},{"title":"【剑指offer】面试题10(4)-矩形覆盖","url":"/archives/ce61152f.html","content":"题目我们可以用21的小矩形横着或者竖着去覆盖更大的矩形。请问用n个21的小矩形无重叠地覆盖一个2*n的大矩形，总共有多少种方法？\n\n1.思路宏观分析依然是斐波那契数量问题的变形题。先把2 * n 的覆盖方法记作F(n)。用第一个2×1的小矩形去覆盖大矩形的左上角时，有两种选择：横着或者竖着。竖着放的时候，其右侧还剩2 × (n - 1)大小的区域，这种状态下的覆盖方法记作F(n - 1)，若第一块是横着放在，那么左下角必须放一个2 × 1 的小矩阵，此时整体还剩2 × (n - 2) 大小的区域，这种状态下的覆盖方法记作F(n - 2)。因此可以推到出，F(n) = F(n - 1) + F(n - 2)，即这是一道斐波那契数列的变形题。（1）递归①n &lt;= 0 时，F(n) = 0；②n = 1 时，F(n) = 1 – &gt; 只有一种摆放的方法；③n = 2 时，F(n) = 2 – &gt; 有两种摆放的方法，两个矩形都横着，或者都竖着，都能满足铺满2 × 2的大矩形的需求；④n &gt; 2 时，F(n) = F(n - 1) + F(n - 2)。（2）非递归（借助数组）效率高①n &lt;= 0 时，返回0；②n = 1 时，返回1 – &gt; 只有一种摆放的方法；③n = 2 时，返回2 – &gt; 有两种摆放的方法，两个矩形都横着，或者都竖着，都能满足铺满2 × 2的大矩形的需求；④n &gt; 2 时，用空间换时间，创建一个大小为n的数组dp[n]，初始化dp[0] = 1; dp[1] = 2; 那么当n大于2时，使用一个次数为n - 2 的循环，记录全部的递推中间值，并将最后的dp[n - 1]返回即可，斐波那契数列本身就是递推关系定义的。\n2.代码（Java实现）public class Solution &#123;\n\tpublic int RectCover(int target) &#123;\n\t\tif (target == 0) &#123;\n\t\t\treturn 0;\n\t\t&#125; else if (target == 1) &#123;\n\t\t\treturn 1;\n\t\t&#125; else if (target == 2) &#123;\n\t\t\treturn 2;\n\t\t&#125; else &#123;\n\t\t\t// 方法1：递归\t\n\t\t\t// return RectCover(target-1)+RectCover(target-2);\n\t\t\t// 方法2：非递归\n\t\t\tint[] dp = new int[target];\n\t\t\tdp[0] = 1;\n\t\t\tdp[1] = 2;\n\t\t\tfor (int i = 2; i &lt; target; i++) &#123;\n\t\t\t\tdp[i] = dp[i - 1] + dp[i - 2];\n\t\t\t&#125;\n\t\t\treturn dp[target - 1];\n\t\t&#125;\n    &#125;\n&#125;\nPS：斐波那契数列问题就全部做完啦，拖了好久终于把这几个题的博客写完了。斐波那契数列所有题目的Java解题代码都可以在 我的主页  里找到，如果有不对的地方欢迎各位批评指正，感谢！\n","categories":["剑指offer"],"tags":["Java","递归","动态规划"]},{"title":"【剑指offer】面试题10(3)-变态跳台阶","url":"/archives/2ebd96bf.html","content":"题目一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。\n\n1.思路其实刚开始没太读懂题，看了下牛客网上大佬们的解答，原来就是求2的n次方的问题。\n2.代码（Java实现）// 简单粗暴，用移位的方法求n次方。\npublic class Solution &#123;\n    public int JumpFloorII(int target) &#123;\n        return 1&lt;&lt;(target-1);\n    &#125;\n&#125;\n\n","categories":["剑指offer"],"tags":["Java","递归"]},{"title":"【剑指offer】面试题10(2)-跳台阶","url":"/archives/a644e50e.html","content":"题目一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法（先后次序不同算不同的结果）。\n\n1.思路这个题是斐波那契数列问题的变形。\n思路（1）用【剑指offer】面试题10（1）-斐波那契数列中解答斐波那契数列问题的思路即可：创建并初始化两个变量FibonacciFirst = F(0)和FibonacciSecond = F(1)，在求解过程中不断更新FibonacciFirst和FibonacciSecond，即依次把已经得到的两个数列中间项保存起来，这样就可以根据定义，对斐波那契数列递推地进行求解了，而且不会产生重复计算时间复杂度是O(n)，空间复杂度是O(1)。\n思路（2）根据题目可以推理出等式：到达第 i 阶的方法总数 = 第 i -1 阶方法数 + 第 i - 2 阶方法数所以利用创建一个大小为n的数组就可以根据等式关系求解问题，虽然空间复杂度不如第一种方法，但是代码比较容易理解。 时间复杂度是O(n) ，空间复杂度是O(n) ，\n2.代码（Java实现）// 思路（1）斐波那契\npublic class Solution &#123;\n\tpublic long JumpFloor(int target) &#123;\n        if(target == 1) &#123;\n            return 1;\n        &#125;\n        if(target == 2) &#123;\n            return 2;\n        &#125;\n        \n        long FibonacciFirst = 1;\n        long FibonacciSecond = 2;\n        long FibonacciN = 0;\n        for (int i = 2; i &lt; target; i ++) &#123;\n            FibonacciN = FibonacciFirst + FibonacciSecond;\n             \n            FibonacciFirst = FibonacciSecond;\n            FibonacciSecond = FibonacciN;\n        &#125;\n        return FibonacciN;\n    &#125;\n&#125;//时间复杂度： O(n) ；空间复杂度：O(1) \n\n// 思路（2）借助数组\npublic class Solution &#123;\n    public int JumpFloor(int target) &#123;\n        if (target == 1) &#123;\n\t\t\treturn 1;\n\t\t&#125;\n\t\tint[] dp = new int[target];\n\t\tdp[0] = 1;\n\t\tdp[1] = 2;\n\t\tfor (int i = 2; i &lt; target; i++) &#123;\n\t\t\tdp[i] = dp[i - 1] + dp[i - 2];\n\t\t&#125;\n\t\treturn dp[target - 1];\n    &#125;\n&#125;//时间复杂度： O(n) ；空间复杂度：O(n) ","categories":["剑指offer"],"tags":["Java","递归","动态规划"]},{"title":"【剑指offer】面试题10(1)-斐波那契数列","url":"/archives/8bc2d320.html","content":"题目大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项（从0开始，第0项为0）。\n\n1.思路接触过编程语言的，在学递归的时候应该都是第一个就学斐波那契数列吧哈哈，就像程序员的第一句话永远是Hello World！\n来自官方的斐波那契数列定义复制用一下：斐波那契数列以如下被以递推的方法定义，F(1)=1，F(2)=1, F(n)=F(n - 1)+F(n - 2)（n ≥ 3，n ∈ N）*.**\n（1）递归方法的思路 –  时间复杂度高，效率低斐波那契数列的特点，就是递归程序的边界！个人观点写递归程序的第一步是确定退出递归的边界条件。\n那根据斐波那契数列的定义，程序的边界应该有两个：①明面上的n = 1 或 n = 2时，F(n) = 1；②另一个是n &lt;= 0 的时候，F(n) = 0，我们传参的时候并不能保证参数都是符合定义要求的，所以需要人为设定返回值为0，来保证代码的健壮性。\n（2）时间复杂度低的思路第一种思路之所以效率低，是因为重复计算太多，所以避免重复计算就可以降低时间复杂度。创建并初始化两个变量FibonacciFirst = F(0)和FibonacciSecond =  F(1)，在求解过程中不断更新FibonacciFirst和FibonacciSecond，即依次把已经得到的两个数列中间项保存起来，这样就可以根据定义，对斐波那契数列递推地进行求解了，而且不会产生重复计算。时间复杂度——O(n)。\n2.代码（Java实现）思路（1）代码\npublic class Solution &#123;\n    public int Fibonacci(int n) &#123;\n        if(n &lt;= 0)&#123;\n            return 0;\n        &#125;else if(n == 2 || n == 1)&#123;\n            return 1;\n        &#125;else &#123;\n            return Fibonacci(n - 1) + Fibonacci(n - 2);\n        &#125;\n    &#125;\n&#125;\n当然这么写好像不怎么优雅下面更优雅的代码\npublic class Solution &#123;\n    public int Fibonacci(int n) &#123;\n        if(num &lt; 1)\n        \treturn 0;\n    \tif(num &lt; 3)\n        \treturn 1;\n    \treturn fibRec(num - 1) + fibRec(num - 2);\n    &#125;\n&#125;\n But！思路（2）的代码写起来那可是更优雅\n// 建议代码使用long定义所有整数，根据实际情况调整吧。\npublic class Solution&#123;\n\tpublic int Fibonacci(int n) &#123;\n\t\tint FibonacciFirst = 0;\n\t\tint FibonacciSecond = 1;\n\t\tint FibonacciN = 0;\n\t\tif(n == 0)&#123;\n\t\t\treturn FibonacciFirst;\n\t\t&#125;\n\t\tif(n == 1)&#123;\n\t\t\treturn FibonacciSecond;\n\t\t&#125;\n\t\tfor (int i = 2; i &lt;= n; i++)&#123;\n\t\t\t// 递推地求 F(n)\n\t\t\tFibonacciN = FibonacciFirst + FibonacciSecond;\n\t\t\t// 下面更新保存数组的中间值\n\t\t\tFibonacciFirst = FibonacciSecond;\n\t\t\tFibonacciSecond = FibonacciN;\n\t\t\t\n\t\t&#125;\n\t&#125;\n&#125;\n\n拜个晚年！祝大家平平安安度过春节，一切顺心！\n","categories":["剑指offer"],"tags":["Java","递归","动态规划"]},{"title":"【剑指offer】面试题11-旋转数组的最小数字","url":"/archives/8588f4a0.html","content":"题目把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个非递减排序的数组的一个旋转，输出旋转数组的最小元素。例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。\n\n1.思路逆序遍历数组，当找到相邻两个元素，满足前一个元素大于后一个元素时，返回后一个元素。很明显旋转数组的特点是，①可以将整个数组分为前后两个非递减排序的数组②而且前一个数组的所有元素都比后一个数组的元素大。那么只要逆序遍历找到他们的分界线就好啦！~补充（2020年1月25日  22：23：50）：顺序遍历也可以，找到相邻两个数，前一个恰好比后一个大，这样也是对的，1月23日写博客的时候用的逆序遍历的方法，感觉还是用顺序遍历更便于写代码一些。代码就不补充上了，比逆序要更容易敲。\n2.代码（Java实现）(1)顺序遍历查找–O(n)\nimport java.util.ArrayList;\npublic class Solution &#123;\n    public int minNumberInRotateArray(int [] array) &#123;\n        int len = array.length;\n\t\tif(len == 0) &#123;\t\n\t    \treturn 0;\t//数组大小为0，返回0\n\t    &#125;else &#123;\n\t    \tint res = array[len - 1];\t\n\t\t\tfor(int i = len - 1; i > 0; i--) &#123;\n\t\t\t\tif(array[i - 1] > array[i]) &#123;\t//找到分界位置\n\t\t\t\t\tres = array[i];\n\t\t\t\t\tbreak;\n\t\t\t\t&#125;\n\t\t\t&#125;\n\t\t\treturn res;\n\t    &#125;\n    &#125;\n&#125;\t//O(n)\n\n(2)二分查找–O(logn)\nimport java.util.ArrayList;\npublic class Solution &#123;\n\tpublic int minNumberInRotateArray(int [] array) &#123;\n\t\tint len = array.length;\n\t\tif(len == 0) &#123;\t\n\t    \treturn 0;\t//数组大小为0，返回0\n\t    &#125;else &#123;\n\t    \tint low = 0; \n\t    \tint high = len - 1;\n\t    \tint mid = 0;\n\t    \twhile (array[low] >= array[high])&#123;\n\t    \t\tif(high - low == 1) &#123;\t//找到分界了\n\t    \t\t\tmid = high;\t//定位最小元素\n\t    \t\t\tbreak;\t\t//跳出循环\n\t    \t\t&#125;\n\t    \t\tmid = low + (high - low) / 2; //防止溢出\n\t    \t\t//上一句的原型是int mid = （low + high）/ 2\t    \n\t    \t\tif(array[mid] >= array[low])&#123;\n\t    \t\t\tlow = mid;\n\t    \t\t&#125;else if(array[mid] &lt;= array[high])&#123;\n\t\t\t\t\thigh = mid;\n\t\t\t\t&#125;\n\t    \t&#125;\n\t\t\treturn array[mid];\n\t    &#125;\n    &#125;\n&#125;\n","categories":["剑指offer"],"tags":["Java","数组"]},{"title":"【剑指offer】面试题8-二叉树的下一个结点","url":"/archives/691459e8.html","content":"题目给定一个二叉树和其中的一个节点，请找出中序遍历顺序的下一个节点并且返回。注意，树中的节点不仅包含左右子节点，同时包含指向父节点的指针。\n\n1.思路def：指定节点为pNode；中序遍历顺序的下一个节点为res（1）如果pNode有右子树，那么res一定存在于是pNode的右子树中按照中序遍历的规律，①如果pNode的右子树有左子树，那么res一定存在于是pNode的右子树的左子树的逻辑位置最左节点，这样只需要while循环找下去就可以了；②如果pNode的右子树没有左子树，那么res就是pNode.right；（2）如果pNode没有右子树，那么顺着pNode.next回溯上去，有两种情况①res.next.left == res，此时需要返回res.next②res.next.left != res，继续回溯上去，直至满足条件（2）①，或者满足不了，即代表pNode没有下一个节点。\n2. 代码（Java）// 二叉树节点类\npublic class TreeLinkNode &#123;\n    int val;\n    TreeLinkNode left = null;\n    TreeLinkNode right = null;\n    TreeLinkNode next = null;\n    \n    TreeLinkNode(int val) &#123;\n        this.val = val;\n    &#125;\n&#125;\n//解题代码\npublic class Solution &#123;\n\tpublic TreeLinkNode GetNext(TreeLinkNode pNode) &#123;\n\t\tif (pNode == null) &#123;\n\t\t\treturn null;\n\t\t&#125;\n\t\t// pNode存在，其实按照题目要求pNode一定合法存在的\n\t\tTreeLinkNode res = pNode;\n\t\tif (res .right != null) &#123;\n\t\t\tres = res.right;\n\t\t\twhile (res.left != null) &#123;\n\t\t\t\tres= res.left;\n\t\t\t&#125;\n\t\t\treturn res;\n\t\t&#125; else if (res.right == null) &#123;\n\t\t\twhile (res.next != null) &#123;\n\t\t\t\tif (res.next.left == res)\n\t\t\t\t\treturn res.next;\n\t\t\t\tres = res.next;\n\t\t\t&#125;\n\t\t&#125;\n\t\treturn null;\n\t&#125;\n&#125;\nps：最开始做题的时候思路错了，理解成需要借助中序遍历来求解答案，但是题目的参数中并没有原始的树，这样的思路就明显不对了，考虑复杂了。直接利用题目中描述的二叉树的特点，尤其是还有next指针指向其双亲节点这一条进行解答就可以。\n","categories":["剑指offer"],"tags":["Java","二叉树","遍历算法"]},{"title":"【剑指offer】面试题66-构建乘积数组","url":"/archives/c0bea5f6.html","content":"题目给定一个数组A[0,1,…,n-1],请构建一个数组B[0,1,…,n-1],其中B中的元素B[i]=A[0]A[1]…A[i-1]*A[i+1]…*A[n-1]。不能使用除法。\n\n1. 思路思路1 两层循环—&gt;O(n²)（1）对数组B的所有元素赋初值为1，借助Arrays.fill(B, 1)即可实现，数组定义之后元素默认值为0，不初始化为1的话就白给了（2）双重循环解决问题，仅当内层循环的下标 i 与外层循环的下标 j 相同时,才使B[i]累乘A[j]。\n思路2 分部分相乘–&gt;O(n)思路来自《剑指offer》书籍，做题时没有考虑到这个方法，这里不再赘述思路，各位看官老爷自行查阅资料。大体意思就是利用上、下三角矩阵的性质，分部分累乘，对B的各元素进行分步赋值，在两次时间复杂度均为O(n)的循环之后，赋值完成。\n2. 代码（Java实现）思路1\nimport java.util.ArrayList;\nimport java.util.Arrays;\npublic class Solution &#123;\n\tpublic int[] multiply(int[] A) &#123;\n\t\tint len = A.length;\n\t\tint[] B = new int[len];\n\t\tArrays.fill(B, 1); // 数组B的元素全部赋值为1\n\t\t// def: B[i] = A[0]*A[1]* …… *A[i-1]*A[i+1]* …… *A[n];\n\t\tfor (int i = 0; i &lt; len; i++) &#123;\n\t\t\tfor (int j = 0; j &lt; len; j++) &#123;\n\t\t\t\tif (j != i) &#123;\t\t\t\t\n\t\t\t\t\tB[i] *= A[j];\n\t\t\t\t&#125;\n\t\t\t&#125;\n\t\t&#125;\n\t\treturn B;\n\t&#125;\n&#125;\t//O(n²)\n思路2\nimport java.util.ArrayList;\nimport java.util.Arrays;\npublic class Solution &#123;\n\tpublic int[] multiply(int[] A) &#123;\n\t\tint len = A.length;\n\t\tint[] B = new int[len];\n\t\tArrays.fill(B, 1); // 数组B的元素全部赋值为1\n\t\t// def: B[i] = A[0]*A[1]* …… *A[i-1]*A[i+1]* …… *A[n];\n\t\t\n\t\tint index = 1;\n\t\tfor (index = 0; index &lt; len; index++) &#123;\n\t\t\tif(index > 0) &#123;\t\t\t//B[0] = 1\n\t\t\t\tB[index] = B[index - 1] * A[index - 1];\n\t\t\t&#125;\n\t\t&#125;\n\t\tint temp = 1;\n\t\tfor (index = len - 1; index >= 0; index--) &#123;\n\t\t\tif(index &lt; len - 1) &#123;\t//B[len-1] = A[n-1]\n\t\t\t\ttemp *= A[index + 1];\n\t\t\t&#125;\n\t\t\tB[index] *= temp;\t\n\t\t&#125;\n\t\t// 输出检验\n\t\t//for (int j = 0; j &lt; len; j++) &#123;\n\t\t//System.out.print(B[j] + \" \");\n\t\t//&#125;\n\t\treturn B;\n\t&#125;\n&#125;\n本想把数组类型的题全部做完，结果一下就到了66题，在《剑指offer》的书上这一小节的名字是“发散思维能力”，果然还是没能想到时间复杂度最小的解题办法，还是按部就班的按照题目顺序来做吧。\n","categories":["剑指offer"],"tags":["Java","数组","循环"]},{"title":"【剑指offer】面试题9-用两个栈实现队列","url":"/archives/ea6627bd.html","content":"题目用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。\n\n1.思路（1）stack1只用来负责push()操作，只要push()就对stack1进行入栈操作，即queue.push  – 对应– stack1.push()；（2）stack1和stack2协同完成pop()操作，queue.pop()时会有两种情况：①stack2非空，此时直接对stack2进行stack2.pop()操作即可;②stack2为空，此时需要先从stack1中将全部元素出栈，然后依次压入栈stack2中，从而实现模拟队列的先进先出特性。\n2.代码（Java实现）import java.util.Stack;\npublic class Solution &#123;\n\tStack&lt;Integer> stack1 = new Stack&lt;Integer>();\n\tStack&lt;Integer> stack2 = new Stack&lt;Integer>();\n\t// 模拟push()\n\tpublic void push(int node) &#123;\n\t\tstack1.add(node);\n\t&#125;\n\t// 模拟pop()\n\tpublic int pop() &#123;\n\t\tif (stack2.isEmpty()) &#123;\t\t\t\t//stack2为空\n\t\t\twhile (!stack1.isEmpty()) &#123;\t\t//将stack1中元素全部出栈\n\t\t\t\tstack2.push(stack1.pop());\t//依次压入栈stack2中\n\t\t\t&#125;\n\t\t&#125;\n\t\treturn stack2.pop();\n\t&#125;\n&#125;\nPS：苏大计算机考研真题也曾考过这个题，用简答的形式对用两个栈实现队列进行描述。\n","categories":["剑指offer"],"tags":["Java","队列","栈"]},{"title":"【剑指offer】面试题7-重建二叉树","url":"/archives/bbf8687.html","content":"题目输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。\n\n1. 思路（1）确定根（2）左右递归建树——&gt;为了方便递归传参，代码中使用了//arraycopy()方法初始化每次用于构建新子树的两个数组。arraycopy()方法用于将一个数组的元素快速拷贝到另一个数组。在使用时需要注意避免发生数组越界，即目标数组的空间不足。\n//形式:\nSystem.arraycopy(src, srcPos, dest, destPos, length);\n\n//参数介绍：\nsrc \t--> 源数组\nsrcPos\t--> 源数组中拷贝元素的起始位置。\ndest \t--> 目标数组\ndestPos --> 拷贝到目标数组的起始位置\nlength \t--> 被拷贝元素的个数\n\n\n2. 代码（Java实现）// 树节点定义\npublic class TreeNode &#123;\n\tint val;\n\tTreeNode left;\n\tTreeNode right;\n\tTreeNode(int x) &#123; val = x; &#125;\n\n&#125;\npublic class Solution &#123;\n    public TreeNode reConstructBinaryTree(int [] pre,int [] in) &#123;\n        TreeNode  tree = new TreeNode(pre[0]);\n        int length = pre.length;\n        if(length == 1) &#123;\n        \ttree.left = tree.right = null;\n        \treturn tree;\n        &#125;\n        else &#123; \n            int index = 0;\n            while(index &lt; in.length)&#123;\n            \tif(in[index] == tree.val) &#123;\n            \t\t//在中序序列中找到根的位置下标index记录下来\n            \t\tbreak;\n            \t&#125;\n            \tindex++;\n            &#125;\n            \n            //递归构建左子树\n            if(index > 0) &#123;\n                int [] preleft = new int [index];  //左子树的pre数组\n                int [] inleft = new int [index];   //左子树的in数组\n                System.arraycopy(pre, 1, preleft, 0, index);//arraycopy()方法，很方便\n                System.arraycopy(in, 0, inleft, 0, index);\n                tree.left = reConstructBinaryTree(preleft, inleft);//递归调用\n            &#125;else &#123;\n            \ttree.left = null;\t//index = 0，代表左边没节点，左子树空\n            &#125;\n            \n             //递归构建右子树\n            int rlen = length - index - 1;\n            //怕麻烦，就先用变量代替rlen出来了这个长度，如果不对的话也方便修改，只修改等号右边就可以\n            if(rlen > 0) &#123;\n            \tint [] preright = new int [rlen];\t//右子树的pre数组\n            \tint [] inright = new int [rlen];\t//右子树的in数组\n                System.arraycopy(pre, index + 1, preright, 0, rlen);\t\n                System.arraycopy(in, index + 1, inright, 0, rlen);\n                reConstructBinaryTree(preright, inright);\n                tree.right = reConstructBinaryTree(preright, inright);//递归调用\n            &#125;else &#123;\n            \ttree.right = null;\t//length - index - 1 = 0，代表右边没节点，右子树空\n            &#125;\n            return tree;\n        &#125;\n    &#125;\n&#125;\n\n","categories":["剑指offer"],"tags":["Java","二叉树","遍历算法"]},{"title":"【剑指offer】面试题6-从头到尾打印链表","url":"/archives/20e208b.html","content":"题目输入一个链表，按链表从尾到头的顺序返回一个ArrayList。\n\n1.思路解法1：遍历单链表，头插法逆置链表。解法2：借助栈。解法3：递归。\n2.代码（Java实现）结点类定义\n/**\n*    public class ListNode &#123;\n*        int val;\n*        ListNode next = null;\n*\n*        ListNode(int val) &#123;\n*            this.val = val;\n*        &#125;\n*    &#125;\n*\n*/\n\n(1)解法1：头插法\nimport java.util.ArrayList;\npublic class Solution &#123;\n    public ArrayList&lt;Integer> printListFromTailToHead(ListNode listNode) &#123;\n        ListNode p = listNode;\n        ListNode q = p;\n        ListNode r = new ListNode(0);\n        r.next = null;\n        while(p!=null)&#123;\t//头插法逆置链表\n        \tq = p.next;\n            p.next = r.next;\n            r.next = p;\n            p = q;\n        &#125;\n        ArrayList&lt;Integer> array = new ArrayList&lt;Integer>();\n        ListNode ss = r.next;\n  \t\t//遍历新链表，将结点的值赋给数组\n        while(ss!=null) &#123;\n        \tarray.add(ss.val);\n        \tss = ss.next;\n        &#125;\n       \t// 检验是否逆置成功\n\t\t// System.out.print(array);\n        return array;\n    &#125;\n&#125;\n\n(2)解法2：借助栈\nimport java.util.ArrayList;\nimport java.util.Stack;\npublic class Solution &#123;\n    public ArrayList&lt;Integer> printListFromTailToHead(ListNode listNode) &#123;\n        Stack&lt;ListNode> stack = new Stack&lt;ListNode>();\n\t\tListNode p = listNode;\n\t\twhile (p != null) &#123; \n\t\t\tstack.push(p);\n\t\t\tp = p.next;\n\t\t&#125;\n\t\tArrayList&lt;Integer> array = new ArrayList&lt;Integer>();\n\t\twhile (!stack.isEmpty()) &#123; // 头插法逆置链表\n\t\t\tarray.add(stack.pop().val);\n\t\t&#125;\n\t\tSystem.out.print(array);\n\t\treturn array;\n    &#125;\n&#125;\n\n(3)解法3：递归\n//以下代码在自己的IDE上调试的时候需要修改，但是在线代码测试是可以通过的，因为样例是一个一个来的\nimport java.util.ArrayList;\npublic class Solution &#123;\n    ArrayList&lt;Integer> array = new ArrayList&lt;Integer>();\n\tpublic  ArrayList&lt;Integer> printListFromTailToHead(ListNode listNode) &#123;\n\t\tif (listNode != null) &#123;\n\t\t\tprintListFromTailToHead(listNode.next); //递归调用\n            array.add(listNode.val);\n\t\t&#125; \n\t\treturn array;\n\t&#125;\n&#125;\n","categories":["剑指offer"],"tags":["Java","链表"]},{"title":"【剑指offer】面试题3-数组中的重复数字","url":"/archives/575f52f1.html","content":"题目在一个长度为n的数组里的所有数字都在0到n-1的范围内。 数组中某些数字是重复的，但不知道有几个数字是重复的。也不知道每个数字重复几次。请找出数组中任意一个重复的数字。 例如，如果输入长度为7的数组{2,3,1,0,2,5,3}，那么对应的输出是第一个重复的数字2。\n1.思路（1）新建一个数组index，遍历原数组numbers，用numbers[i]作为下标访问数组index，并将index[ numbers[i] ] ++；（2）遍历数组index，如果遇到index[i] &gt;= 2,说明有重复数字，返回true，否则遍历结束之后返回false即可。\n2.代码（Java实现）public class Solution &#123;\n    public boolean duplicate(int numbers[],int length,int [] duplication) &#123;\n        int [] index = new int[length+1];\t//index的容量多设些\n        int i = 0;\n        //遍历numbers数组并更新index数组\n        for(i = 0; i &lt; length; i++)&#123;\n            index[numbers[i]] ++;\n        &#125;\n        //判断有没有重复数字\n        for(i = 0; i &lt; length; i++)&#123;\n            if(index[i] >= 2)&#123;\n                duplication[0] = i;\n                return true;\n            &#125;\n        &#125;\n        return false;\n    &#125;\n&#125;\t//O(n)\n","categories":["剑指offer"],"tags":["Java","数组"]},{"title":"【剑指offer】面试题5-替换空格","url":"/archives/cd501261.html","content":"题目请实现一个函数，将一个字符串中的每个空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。\n\n1. 思路（1）遍历StringBuffer，找到每一个空格；（2）用StringBuffer类的replace(int start, int end, String str)方法使用给定的字符串“%20”替换此序列的子字符串中的空格。\n2.代码（Java实现）public class Solution &#123;\n    public String replaceSpace(StringBuffer str) &#123;\n    \tchar st = ' ';\n        for(int i = 0; i &lt; str.length(); i++)&#123;\n            if(st == str.charAt(i))&#123;\n                str.replace(i, i + 1, \"%20\");\n            &#125;\n        &#125;\n        return str.toString();\t\n        //如果函数返回值也和参数一样都是StringBuffer的话只返回str就好\n    &#125;\n&#125;\t//O(n)\n","categories":["剑指offer"],"tags":["Java","字符串"]},{"title":"【剑指offer】面试题4-二维数组中的查找","url":"/archives/88e3e437.html","content":"题目：在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。\n\n1.思路（1）获取数组的长和宽以二维数组右上角或者左下角元素作为标志位进行遍历（这里以右上角举例）。\n（2）遍历并比较判断①若右上角元素值与目标值target相等，返回true；②若右上角元素值大于（&gt;）目标值taiget，则令遍历数组的列下标减1；原因：当前右上角元素所在的列可以全部被忽略，以后不再遍历，因为这一列的元素值肯定都比target大，搜索区域减少一列。③若右上角元素值小于（＜）目标值taiget，则令遍历数组的行下标加1。原因：当前右上角元素所在的行可以全部被忽略，以后不再遍历，因为这一行的元素值肯定都比target小，搜索区域减少一行。\n2.代码（Java实现）public class Solution &#123;\n    public boolean Find(int target, int [][] array) &#123;\n        int col = array.length;\t\t//获取列数\n\t\tint row = array[0].length;\t//获取行数\n\t\tint i = col - 1;\t\t\t//设置遍历的起始列下标\n\t\tint j = 0;\t\t\t\t\t//设置遍历的起始行下标\n\t\t//System.out.print(col + \" \" + row);\n\t\twhile(i >=0 &amp;&amp; j &lt; row) &#123;\t//下标合法性判断\n\t\t\tif(target == array[i][j]) &#123;\t//匹配\n\t\t\t\treturn true;\n\t\t\t&#125;else if (target >= array[i][j]) &#123;\n\t\t\t\tj ++;\t\t\t\t//行数+1\n\t\t\t&#125;else if (target &lt;= array[i][j]) &#123;\n\t\t\t\ti --;\t\t\t\t//列数-1\n\t\t\t&#125;\n\t\t&#125;\n\t\treturn false;\n    &#125;\n&#125; // O(m+n)\nPS:苏州大学考研真题，有一年考过这个题\n","categories":["剑指offer"],"tags":["Java","数组","查找","考研"]},{"title":"修改用户名推送测试","url":"/archives/518103f6.html","content":"二级标题index.ejs后期修改部分\n&lt;% if(post.excerpt) &#123; %>\n              &lt;%- post.excerpt %>\n                &lt;% &#125; else &#123; %>\n                  &lt;%- post.content %>\n                    &lt;% &#125; %>\n\n\n\n三级标题四级标题正文\n语言测试\n\n==正文结束==\n\n\n测测测测测测\n","categories":["其他"],"tags":["其他"]}]